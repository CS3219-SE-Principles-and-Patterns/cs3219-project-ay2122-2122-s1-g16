id,question_id,content
1,1,"#include <stdio.h>
 #include <iostream>
 #include <vector>
 #include <set>
 #include <algorithm>
 using namespace std;
 /*
  * Similar like ""Two Number"" problem, we can have the simlar solution.
  *
  * Suppose the input array is S[0..n-1], 3SUM can be solved in O(n^2) time on average by 
  * inserting each number S[i] into a hash table, and then for each index i and j, 
  * checking whether the hash table contains the integer - (s[i]+s[j])
  *
  * Alternatively, the algorithm below first sorts the input array and then tests all 
  * possible pairs in a careful order that avoids the need to binary search for the pairs 
  * in the sorted list, achieving worst-case O(n^n)
  *
  * Solution: Quadratic algorithm
  * http://en.wikipedia.org/wiki/3SUM
  *
  */
 vector<vector<int> > threeSum(vector<int> &num) {
  vector< vector<int> > result;
  if(num.size() == 0 || num.size() == 1 || num.size() == 2) return result;
  //sort the array, this is the key
  sort(num.begin(), num.end());
  int n = num.size();
  for (int i=0; i<n-2; i++) {
  //skip the duplication
  if (i > 0 && num[i - 1] == num[i]) continue;
  int a = num[i];
  int low = i + 1;
  int high = n - 1;
  while (low < high) {
  int b = num[low];
  int c = num[high];
  if (a + b + c == 0) {
  //got the soultion
  vector<int> v;
  v.push_back(a);
  v.push_back(b);
  v.push_back(c);
  result.push_back(v);
  // Continue search for all triplet combinations summing to zero.
  //skip the duplication
  while(low < n - 1 && num[low] == num[low + 1]) low++; 
  while(high > 0 && num[high] == num[high - 1]) high--; 
  low++;
  high--;
  } else if (a+b+c > 0) {
  //skip the duplication
  while(high > 0 && num[high] == num[high - 1]) high--;
  high--;
  } else {
  //skip the duplication
  while(low < n - 1 && num[low] == num[low + 1]) low++;
  low++;
  } 
  }
  }
  return result;
 }
 //using combination method could meet <<Time Limit Exceeded>> error
 vector<vector<int> > combination(vector<int> &v, int k);
 bool isSumZero(vector<int>& v);
 int sum(vector<int>& v);
 vector<vector<int> > threeSum2(vector<int> &num) {
  vector< vector<int> > result;
  vector< vector<int> > r = combination(num, 3);
  for (int i = 0; i < r.size(); i++) {
  if (isSumZero(r[i])) {
  result.push_back(r[i]);
  }
  }
  return result;
 }
 bool isSumZero(vector < int>& v) {
  return sum(v) == 0;
 }
 int sum(vector<int>& v) {
  int s = 0;
  for(int i = 0; i < v.size(); i++) {
  s += v[i];
  }
  return s;
 }
 vector<vector<int> > combination(vector<int> &v, int k) {
  vector<vector<int> > result;
  vector<int> d;
  int n = v.size();
  for (int i = 0; i < n; i++) {
  d.push_back( (i < k) ? 1 : 0 );
  }
  //1) from the left, find the [1,0] pattern, change it to [0,1]
  //2) move all of the 1 before the pattern to the most left side
  //3) check all of 1 move to the right
  while(1) {
  vector<int> tmp;
  for(int x = 0; x < n; x++) {
  if (d[x]) tmp.push_back(v[x]);
  }
  sort(tmp.begin(), tmp.end());
  result.push_back(tmp);
  //step 1), find [1,0] pattern
  int i;
  bool found = false;
  int ones = 0;
  for(i = 0; i < n - 1; i++) {
  if (d[i] == 1 && d[i + 1] == 0) {
  d[i] = 0; d[i + 1] = 1;
  found = true;
  //step 2) move all of right 1 to the most left side
  for (int j = 0; j < i; j++) {
  d[j] = ( ones > 0 ) ? 1 : 0;
  ones--;
  }
  break;
  }
  if (d[i] == 1) ones++;
  }
  if (!found) {
  break;
  }
  }
  return result;
 }
 void printMatrix(vector<vector<int> > &matrix)
 {
  for(int i = 0; i < matrix.size(); i++) {
  printf(""{"");
  for(int j = 0; j < matrix[i].size(); j++) {
  printf(""%3d "", matrix[i][j]) ;
  }
  printf(""}\n"");
  }
  cout << endl;
 }
 int main()
 {
  //int a[] = { -1, 0, 1, 2, -1, 1, -4 };
  int a[] = { -1, 1, 1, 1, -1, -1, 0,0,0 };
  vector<int> n(a, a + sizeof(a)/sizeof(int));
  vector< vector<int> > result = threeSum(n);
  printMatrix(result); 
  return 0;
 }"
2,2,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <set>
 #include <algorithm>
 using namespace std;
 #define INT_MAX 2147483647
 //solution: http://en.wikipedia.org/wiki/3SUM
 //the idea as blow:
 // 1) sort the array.
 // 2) take the element one by one, calculate the two numbers in reset array.
 //
 //notes: be careful the duplication number.
 //
 // for example:
 // [-4,-1,-1,1,2] target=1
 // 
 // take -4, can cacluate the ""two number problem"" of the reset array [-1,-1,1,2] while target=5
 // [(-4),-1,-1,1,2] target=5 distance=4
 // ^ ^ 
 // because the -1+2 = 1 which < 5, then move the `low` pointer(skip the duplication)
 // [(-4),-1,-1,1,2] target=5 distance=2
 // ^ ^ 
 // take -1(skip the duplication), can cacluate the ""two number problem"" of the reset array [1,2] while target=2
 // [-4,-1,(-1),1,2] target=2 distance=1
 // ^ ^ 
 int threeSumClosest(vector<int> &num, int target) {
  //sort the array
  sort(num.begin(), num.end());
  int n = num.size();
  int distance = INT_MAX;
  int result;
  for (int i=0; i<n-2; i++) {
  //skip the duplication
  if (i > 0 && num[i - 1] == num[i]) continue;
  int a = num[i];
  int low = i + 1;
  int high = n - 1;
  //convert the 3sum to 2sum problem
  while (low < high) {
  int b = num[low];
  int c = num[high];
  int sum = a + b + c;
  if (sum - target == 0) {
  //got the final soultion
  return target;
  } else {
  //tracking the minmal distance
  if (abs(sum - target) < distance ) {
  distance = abs(sum - target);
  result = sum;
  }
  if (sum - target > 0) {
  //skip the duplication
  while(high > 0 && num[high] == num[high - 1]) high--;
  //move the `high` pointer
  high--;
  } else {
  //skip the duplication
  while(low < n && num[low] == num[low + 1]) low++;
  //move the `low` pointer
  low++;
  }
  }
  }
  }
  return result;
 }
 int main()
 {
  int a[] = { -1, 2, 1, -4 };
  vector<int> n(a, a + sizeof(a)/sizeof(int));
  int target = 1;
  cout << threeSumClosest(n, target) << endl;
  return 0;
 }"
3,3,"#include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 vector<vector<int> > threeSum(vector<int> num, int target); 
 /*
  * 1) Sort the array,
  * 2) traverse the array, and solve the problem by using ""3Sum"" soultion.
  */
 vector<vector<int> > fourSum(vector<int> &num, int target) {
  vector< vector<int> > result;
  if (num.size() < 4) return result;
  sort( num.begin(), num.end() );
  for(int i = 0; i < num.size() - 3; i++) {
  //skip the duplication
  if (i > 0 && num[i - 1] == num[i]) continue;
  vector<int> n(num.begin()+i+1, num.end());
  vector<vector<int> > ret = threeSum(n, target-num[i]);
  for(int j = 0; j < ret.size(); j++) {
  ret[j].insert(ret[j].begin(), num[i]);
  result.push_back(ret[j]);
  }
  }
  return result; 
 }
 vector<vector<int> > threeSum(vector<int> num, int target) {
  vector< vector<int> > result;
  //sort the array (if the qrray is sorted already, it won't waste any time)
  sort(num.begin(), num.end());
  int n = num.size();
  for (int i = 0; i < n - 2; i++) {
  //skip the duplication
  if (i > 0 && num[i - 1] == num[i]) continue;
  int a = num[i];
  int low = i + 1;
  int high = n - 1;
  while (low < high) {
  int b = num[low];
  int c = num[high];
  if (a + b + c == target) {
  //got the soultion
  vector<int> v;
  v.push_back(a);
  v.push_back(b);
  v.push_back(c);
  result.push_back(v);
  // Continue search for all triplet combinations summing to zero.
  //skip the duplication
  while(low < n && num[low] == num[low + 1]) low++;
  while(high > 0 && num[high] == num[high - 1]) high--;
  low++;
  high--;
  } else if (a + b + c > target) {
  //skip the duplication
  while(high > 0 && num[high] == num[high - 1]) high--;
  high--;
  } else {
  //skip the duplication
  while(low < n && num[low] == num[low + 1]) low++;
  low++;
  }
  }
  }
  return result;
 }
 int printMatrix(vector< vector<int> > &vv)
 {
  for(int i = 0; i < vv.size(); i++) {
  cout << ""["";
  for(int j = 0; j < vv[i].size(); j++) {
  cout << "" "" << vv[i][j];
  }
  cout << ""]"" << endl;;
  }
 }
 int main()
 {
  int a[] = { 1, 0, -1, 0, -2, 2 };
  vector<int> n(a, a+6);
  int t = 0;
  vector< vector<int> > v = fourSum(n, t);
  printMatrix(v);
  n.clear();
  int b[] = { -1, -5, -5, -3, 2, 5, 0, 4 };
  n.insert(n.begin(), b, b+8);
  t = -7;
  v = fourSum(n, t);
  printMatrix(v);
  return 0;
 }"
4,4,"//Bad Performance Solution
 class Solution_Time_Limit_Exceeded {
 public:
  // We can orginze all relevant emails to a chain,
  // then we can use Union Find algorithm
  // Besides, we also need to map the relationship between name and email.
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
  unordered_map<string, string> emails_chains; // email chains
  unordered_map<string, string> names; // names to email chains' head
  //initialization
  for(int i = 0 ; i<accounts.size();i++) {
  auto& account = accounts[i];
  auto& name = account[0];
  for (int j=1; j<account.size(); j++) {
  auto& email = account[j];
  if ( names.find(email) == names.end() ) {
  emails_chains[email] = email;
  names[email] = name;
  }
  join(emails_chains, account[1], email);
  }
  }
  //reform the emails
  unordered_map<string, set<string>> res;
  for( auto& acc : accounts ) {
  string e = find(emails_chains, acc[1]);
  res[e].insert(acc.begin()+1, acc.end());
  }
  //output the result
  vector<vector<string>> result;
  for (auto pair : res) {
  vector<string> emails(pair.second.begin(), pair.second.end());
  emails.insert(emails.begin(), names[pair.first]);
  result.push_back(emails);
  }
  return result;
  }
  string find(unordered_map<string, string>& emails_chains,
  string email) {
  while( email != emails_chains[email] ){
  email = emails_chains[email];
  }
  return email;
  }
  bool join(unordered_map<string, string>& emails_chains,
  string& email1, string& email2) {
  string e1 = find(emails_chains, email1);
  string e2 = find(emails_chains, email2);
  if ( e1 != e2 ) emails_chains[e1] = email2;
  return e1 == e2;
  }
 };
 //
 // Performance Tunning
 // -----------------
 //
 // The above algorithm need to do string comparison, it causes lots of efforts
 // So, we allocated the ID for each email, and compare the ID would save the time.
 //
 // Furthermore, we can use the Group-Email-ID instead of email ID,
 // this would save more time.
 //
 class Solution {
 public:
  // We can orginze all relevant emails to a chain,
  // then we can use Union Find algorithm
  // Besides, we also need to map the relationship between name and email.
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
  unordered_map<string, int> emails_id; //using email ID for union find
  unordered_map<int, int> emails_chains; // email chains
  unordered_map<int, string> names; // email id & name
  //initialization & join
  for(int i = 0 ; i<accounts.size();i++) {
  // using the account index as the emails group ID,
  // this could simplify the emails chain.
  emails_chains[i] = i;
  auto& account = accounts[i];
  auto& name = account[0];
  for (int j=1; j<account.size(); j++) {
  auto& email = account[j];
  if ( emails_id.find(email) == emails_id.end() ) {
  emails_id[email] = i;
  names[i] = name;
  }else {
  join( emails_chains, i, emails_id[email] );
  }
  }
  }
  //reform the emails
  unordered_map<int, set<string>> res;
  for(int i=0; i<accounts.size(); i++) {
  int idx = find(emails_chains, i);
  res[idx].insert(accounts[i].begin()+1, accounts[i].end());
  }
  //output the result
  vector<vector<string>> result;
  for (auto pair : res) {
  vector<string> emails( pair.second.begin(), pair.second.end() );
  emails.insert(emails.begin(), names[pair.first]);
  result.push_back(emails);
  }
  return result;
  }
  int find(unordered_map<int, int>& emails_chains, int id) {
  while( id != emails_chains[id] ){
  id = emails_chains[id];
  }
  return id;
  }
  bool join(unordered_map<int, int>& emails_chains, int id1, int id2) {
  int e1 = find(emails_chains, id1);
  int e2 = find(emails_chains, id2);
  if ( e1 != e2 ) emails_chains[e1] = e2;
  return e1 == e2;
  }
 };"
5,5,"#include <string.h>
 #include <iostream>
 #include <string>
 using namespace std;
 const int MAX_CHARS = 26;
 /*Trie Node*/
 class TrieNode {
 public:
  TrieNode():isWord(false) {
  memset(childern, 0, sizeof(childern));
  }
  TrieNode* & operator [] (char idx){
  int i = (idx-'a') % MAX_CHARS;
  return childern[i];
  }
  TrieNode* & operator [] (int idx){
  int i = idx % MAX_CHARS;
  return childern[i];
  }
  bool isWord;
 private:
  TrieNode* childern[MAX_CHARS];
 };
 /*Trie Tree*/
 class TrieTree {
 public:
  TrieTree():root(new TrieNode()){ }
  ~TrieTree() { freeTree(root); }
  void put(string &s) {
  TrieNode* node = root;
  for (int i=0; i<s.size(); i++){
  if ((*node)[s[i]] == NULL){
  (*node)[s[i]] = new TrieNode();
  }
  node = (*node)[s[i]];
  }
  node->isWord = true;
  }
  bool search(string &s){
  return get(s, this->root);
  }
 private:
  bool get(string &s, TrieNode* root, int idx=0){
  TrieNode* node = root;
  for (int i=idx; i<s.size(); i++){
  if (s[i]!='.'){
  node = (*node)[s[i]];
  if (node == NULL) return false;
  }else{
  for (int j=0; j<MAX_CHARS; j++) {
  TrieNode *p = (*node)[j];
  if (p == NULL ) {
  continue;//try next
  }
  // p!=NULL
  if (i<s.size()-1) {
  if (this->get(s, p, i+1)) {
  return true;
  }
  continue; //try next
  }
  // p!=NULL && i == s.size()-1
  if (p->isWord) {
  return true;
  }
  }
  return false;
  }
  }
  return node->isWord; 
  }
 private:
  void freeTree(TrieNode* root){
  for(int i=0; i<MAX_CHARS; i++){
  if ((*root)[i]!=NULL){
  freeTree((*root)[i]);
  }
  }
  delete root;
  }
  TrieNode *root;
 };
 class WordDictionary {
 public:
  // Adds a word into the data structure.
  void addWord(string word) {
  tree.put(word);
  }
  // Returns if the word is in the data structure. A word could
  // contain the dot character '.' to represent any one letter.
  bool search(string word) {
  return tree.search(word);
  }
 private:
  TrieTree tree;
 };
 // Your WordDictionary object will be instantiated and called as such:
 // WordDictionary wordDictionary;
 // wordDictionary.addWord(""word"");
 // wordDictionary.search(""pattern"");
 int main()
 {
  WordDictionary wd;
  wd.addWord(""a"");
  cout << wd.search(""a."") <<endl;;
  cout << wd.search("".a"") << endl;;
  wd.addWord(""bad"");
  cout << wd.search(""bad"") <<endl;;
  cout << wd.search(""b.."") <<endl;;
  return 0;
 }"
6,6,"#include <iostream>
 #include <string>
 using namespace std;
 string addBinary(string a, string b) {
  int alen = a.size();
  int blen = b.size();
  bool carry = false;
  string result;
  while( alen>0 || blen>0) {
  int abit = alen<=0 ? 0 : a[alen-1]-'0';
  int bbit = blen<=0 ? 0 : b[blen-1]-'0';
  int cbit = carry ? 1 : 0;
  result.insert(result.begin(), '0' + ((abit+bbit+cbit) & 1) );
  carry = (abit+bbit+cbit>1);
  alen--; blen--;
  }
  if (carry){
  result.insert(result.begin(), '1');
  }
  return result;
 }
 int main(int argc, char** argv) 
 {
  string a = ""11"";
  string b = ""1"";
  if (argc>2){
  a = argv[1];
  b = argv[2];
  }
  cout << a << ""+"" << b << ""="" << addBinary(a, b) << endl;
 }"
7,7,"class Solution {
  public:
  int addDigits(int num) {
  switch(random()%5+1){
  case 1: return addDigits01(num);
  case 2: return addDigits02(num);
  case 3: return addDigits03(num);
  case 4: return addDigits04(num);
  default: return addDigits05(num);
  }
  }
  //regualr way
  int addDigits01(int num) {
  while(num > 9) {
  int sum;
  for(sum=0; num > 0; sum += num%10 , num/=10);
  num = sum;
  }
  return num;
  }
  //This solution looks is very tricky, but acutally it is easy to understand.
  //it just keep adding the last digital until the num < 10
  int addDigits02(int num) {
  while(num > 9) {
  num = num / 10 + num % 10;
  }
  return num;
  }
  // Let's observe the pattern
  // 1 1
  // 2 2
  // ... ...
  // 8 8 
  // 9 9 
  // 10 1
  // 11 2
  // 12 3 
  // ... ...
  // 17 8
  // 18 9
  // 19 1
  // 20 2
  // ... ...
  // It looks most of number just simply %9 is the answer, 
  // but there are some edge cases.
  // 9%9=0 but we need 9. 
  // 18%9=0 but we need 9
  // so we can find the solution is:
  // 1) num <=9, return num
  // 2) num > 9, reutrn num%9 if num%9>0
  // return 9 if num%9 ==0
  int addDigits03(int num) {
  return num >9 ? ((num %9)==0 ? 9:num%9) : num;
  }
  //But actually, we can use (num-1)%9 + 1 to make all cases right.
  int addDigits04(int num){
  return (num - 1) % 9 + 1;
  }
  //This solution is similar with pervious solution.
  int addDigits05(int num){
  return num - 9 * ((num - 1)/9);
  }
 };"
8,8,"class Solution {
 public:
  bool isAdditiveNumber(string num) {
  int len = num.size();
  for(int i=1; i<len/2+1; i++) {
  string n1 = num.substr(0, i);
  if ( n1.size()>1 && n1[0] == '0') break;
  for(int j=i+1; j<len; j++) {
  string n2 = num.substr(i, j-i);
  if ( n2.size()>1 && n2[0] == '0') break;
  string n3 = num.substr(j);
  if (isAdditiveNumberHelper(n1, n2, n3)) return true;
  }
  }
  return false;
  }
 private:
  bool isAdditiveNumberHelper(string& n1, string& n2, string& n3){
  string add = StringAdd(n1, n2);
  if (add.size() > n3.size()) return false;
  if (add == n3 ) return true;
  //split the n3 to 2 parts, and keep going.
  string cut = n3.substr(0, add.size());
  if (add == cut) {
  string rest = n3.substr(add.size());
  return isAdditiveNumberHelper(n2, add, rest);
  }
  return false;
  }
  string StringAdd(string n1, string n2) {
  if (n1.size() < n2.size()) {
  string tmp = n1;
  n1 = n2;
  n2 = tmp;
  }
  int carry=0;
  string result;
  for (int i=n1.size()-1, j=n2.size()-1; i>=0; i--, j--) {
  int n = n1[i] - '0' + carry;
  if ( j >= 0) {
  n += n2[j] - '0';
  } 
  char ch = n % 10 + '0';
  carry = n/10;
  result = ch + result;
  }
  if (carry>0) result = (char)(carry+'0') + result;
  return result;
  }
 };"
9,9,"class Solution {
 public:
  string addStrings(string num1, string num2) {
  string& longstr = ( num1.size() >= num2.size() ? num1 : num2 );
  string& shortstr = ( num1.size() < num2.size() ? num1 : num2 );
  int longlen = longstr.size();
  int shortlen = shortstr.size();
  char carry = 0;
  int i, j;
  string result;
  for (i = longlen-1, j=shortlen-1; i>=0; i--, j--) {
  int add = 0;
  if (j>=0) {
  add = longstr[i] + shortstr[j] - 2 * '0' + carry;
  }else{
  add = longstr[i] - '0' + carry;
  }
  carry = add/10;
  result = char('0' + add % 10) + result;
  }
  if (carry) {
  result = '1' + result;
  }
  return result;
  }
 };"
10,10,"class Solution {
 public:
  vector<int> addToArrayForm(vector<int>& A, int K) {
  int carry = K;
  for (int i = A.size() - 1; i >= 0 && carry > 0; i--) {
  int a = A[i] + carry;
  A[i] = a % 10 ;
  carry = a / 10;
  }
  while ( carry > 0 ) {
  A.insert(A.begin(), carry%10);
  carry /= 10;
  }
  return A;
  }
 };"
11,11,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
  int x=0, y=0, carry=0, sum=0;
  ListNode *h=NULL, **t=&h;
  while (l1!=NULL || l2!=NULL){
  x = getValueAndMoveNext(l1);
  y = getValueAndMoveNext(l2);
  sum = carry + x + y;
  ListNode *node = new ListNode(sum%10);
  *t = node;
  t = (&node->next);
  carry = sum/10;
  }
  if (carry > 0) {
  ListNode *node = new ListNode(carry%10);
  *t = node;
  }
  return h;
  }
 private:
  int getValueAndMoveNext(ListNode* &l){
  int x = 0;
  if (l != NULL){
  x = l->val;
  l = l->next;
  }
  return x;
  }
 };"
12,12,"class Solution {
 public:
  vector< vector<string> > groupAnagrams(vector<string> &strs) {
  vector< vector<string> > result;
  map<string, int> m;
  for(int i=0; i<strs.size(); i++){
  string word = strs[i];
  sort(word.begin(), word.end());
  if (m.find(word)==m.end()){
  vector<string> v;
  v.push_back(strs[i]);
  result.push_back(v);
  m[word] = result.size()-1;
  }else{
  result[m[word]].push_back(strs[i]);
  }
  }
  for(int i=0; i<result.size(); i++){
  sort(result[i].begin(), result[i].end());
  }
  return result;
  }
  //using multiset 
  vector< vector<string> > groupAnagrams01(vector<string> &strs) {
  vector< vector<string> > result;
  map<string, multiset<string>> m;
  for(int i=0; i<strs.size(); i++){
  string word = strs[i];
  sort(word.begin(), word.end());
  m[word].insert(strs[i]);
  }
  for(auto item : m){
  vector<string> v(item.second.begin(), item.second.end());
  result.push_back(v);
  }
  return result;
  }
  //NOTICE: the below solution has been depracated as the problem has been updated!
  vector<string> anagrams(vector<string> &strs) {
  vector<string> result;
  map<string, int> m;
  for(int i=0; i<strs.size(); i++){
  string word = strs[i];
  //sort it can easy to check they are anagrams or not
  sort(word.begin(), word.end()); 
  if (m.find(word)==m.end()){
  m[word] = i;
  }else{
  if (m[word]>=0){
  result.push_back(strs[m[word]]);
  m[word]=-1;
  }
  result.push_back(strs[i]);
  }
  }
  return result;
  }
 };"
13,13,"class Solution {
 public:
  //stupid way - but easy to understand - 76ms
  bool isAnagram01(string s, string t) {
  sort(s.begin(), s.end());
  sort(t.begin(), t.end());
  return s == t;
  }
  //using a map to count every chars in the string.
  bool isAnagram02(string s, string t) {
  int map[26] ={0} ; //only lowercase alphabets
  //memset(map, 0, sizeof(map));
  // count each char for s
  for (int i=0; i<s.size(); i++) {
  map[s[i]-'a']++;
  }
  // decrease the count for t
  for (int i=0; i<t.size(); i++) {
  map[t[i]-'a']--;
  }
  //if all alphabets is zero, then they are anagram 
  for (int i=0; i<sizeof(map)/sizeof(map[0]); i++) {
  if (map[i]!=0) return false;
  }
  return true;
  }
  bool isAnagram(string s, string t) {
  return isAnagram02(s,t); //12ms
  return isAnagram01(s,t); //76ms
  }
 };"
14,14,"class Solution {
 public:
  //
  // It's easy to find out how many 3-length slices in an arithmetic array with N length.
  //
  // len = 3, then 1 slices, sum(1)
  // len = 4, then 3 slices, sum(1,2) - TWO 3-length slices + ONE 4-length slice
  // len = 5, then 6 slices, sum(1,2,3) - THREE 3-length slices + TWO 4-length slices + ONE 5-length slice
  // len = 6, then 10 slices, sum(1,2,3,4) - ...
  // len = 7, then 15 slices, sum(1,2,3,4,5) - ..
  //
  // So, with N length arithmetic array, there are Sum[1, N-3+1] 3-length slices
  //
  // And, we know the formula sum from 1 to n is:
  //
  // n * ( n + 1 )
  // sum [1, n] = ---------------
  // 2
  // Then, we could have the solution - O(n) Time with O(1) Space
  //
  int sum1toN(int n) {
  return n * (n+1) / 2;
  }
  int numberOfArithmeticSlices(vector<int>& A) {
  int result = 0;
  int len = 0; // the current length of arithmetic
  for (int i=2; i<A.size(); i++) {
  if (A[i] - A[i-1] == A[i-1] - A[i-2]) {
  len++;
  }else{
  result += sum1toN(len);
  len=0;
  }
  }
  return len==0 ? result : result + sum1toN(len);
  }
 };"
15,15,"class Solution {
 private: 
  void removeBackspaces(string &s) {
  int i = 0;
  for(int i=0; i<s.size(); i++) {
  if (s[i] == '#') {
  int backSteps = i>0 ? 2 : 1;
  s.erase(i-backSteps + 1, backSteps);
  i -= backSteps;
  } 
  }
  }
 public:
  bool backspaceCompare(string S, string T) {
  removeBackspaces(S);
  removeBackspaces(T);
  return S == T;
  }
 };"
16,16,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  bool isBalanced(TreeNode *root) {
  int height=0;
  return isBalancedUtil(root, height);
  }
  bool isBalancedUtil(TreeNode* root, int& height){
  if(root==NULL){
  height=0;
  return true;
  }
  int lh=0, rh=0;
  bool isLeft = isBalancedUtil(root->left, lh);
  bool isRight = isBalancedUtil(root->right, rh);
  height = (lh > rh ? lh : rh) + 1;
  return (abs(lh-rh)<=1 && isLeft && isRight);
  }
 };
 //Notes: 
 // I think the above solution should be more efficent than the below, 
 // but for leetcode, the below solution needs 60ms, the above needs 88ms
 class Solution {
 public:
  bool isBalanced(TreeNode *root) {
  if (root==NULL) return true;
  int left = treeDepth(root->left); 
  int right = treeDepth(root->right);
  if (left-right>1 || left-right < -1) {
  return false;
  }
  return isBalanced(root->left) && isBalanced(root->right);
  }
  int treeDepth(TreeNode *root) {
  if (root==NULL){
  return 0;
  }
  int left=1, right=1;
  left += treeDepth(root->left);
  right += treeDepth(root->right);
  return left>right?left:right;
  }
 };"
17,17,"#include <stdlib.h>
 #include <ctype.h>
 #include <iostream>
 #include <string>
 #include <stack>
 #include <vector>
 using namespace std;
 /*
  * Sorry, I cannot help using Design Pattern ;-)
  * (https://en.wikipedia.org/wiki/Interpreter_pattern)
  *
  * Two Stack is cheap, design pattern is powerful! ;-)
  * 
  * But WTF, Memory Limit Exceeded!! Shit!!
  */
 class Expression 
 {
  public:
  virtual int interpret() = 0;
  virtual ~Expression() {};
 };
 class Number: public Expression 
 {
  public:
  Number(string num) { this->number = atoi(num.c_str()); }
  ~Number() { }
  int interpret() { return number; }
  private:
  int number;
 };
 class Plus : public Expression 
 {
  public:
  Plus(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { } 
  ~Plus() { delete leftOperand; delete rightOperand; }
  int interpret() { return leftOperand->interpret() + rightOperand->interpret(); }
  private:
  Expression* leftOperand;
  Expression* rightOperand;
 };
 class Minus : public Expression 
 {
  public:
  Minus(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { } 
  ~Minus() { delete leftOperand; delete rightOperand; }
  int interpret() { return leftOperand->interpret() - rightOperand->interpret(); }
  private:
  Expression* leftOperand;
  Expression* rightOperand;
 };
 class Multiply : public Expression
 {
  public:
  Multiply(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { }
  ~Multiply() { delete leftOperand; delete rightOperand; }
  int interpret() { return leftOperand->interpret() * rightOperand->interpret(); }
  private:
  Expression* leftOperand;
  Expression* rightOperand;
 };
 class Divide : public Expression
 {
  public:
  Divide(Expression* left, Expression* right) :leftOperand(left), rightOperand(right) { }
  ~Divide() { delete leftOperand; delete rightOperand; }
  int interpret() { return leftOperand->interpret() / rightOperand->interpret(); }
  private:
  Expression* leftOperand;
  Expression* rightOperand;
 };
 bool isOperator(const string &c) {
  return (c == ""+"" || c == ""-"" || c == ""*"" || c == ""/"" );
 }
 bool isOperator(const char &c) {
  return (c == '+' || c == '-' || c == '*' || c == '/'); 
 }
 class Evaluator : public Expression 
 {
  private:
  Expression* syntaxTree;
  public: 
  Evaluator(vector<string>& s) 
  {
  vector<Expression*> stack;
  for (unsigned int i=0; i < s.size(); i++) {
  if (isOperator(s[i])) {
  Expression* left = stack.back(); stack.pop_back();
  Expression* right = stack.back(); stack.pop_back();
  switch(s[i][0]) { 
  case '+' : 
  stack.push_back(new Plus(right, left)); break;
  case '-' :
  stack.push_back(new Minus(right, left)); break;
  case '*' :
  stack.push_back(new Multiply(right, left)); break;
  case '/' :
  stack.push_back(new Divide(right, left)); break;
  }
  }else{ 
  stack.push_back(new Number(s[i]));
  }
  }
  syntaxTree = stack.back();
  }
  ~Evaluator() {
  delete syntaxTree; 
  }
  int interpret() {
  return syntaxTree->interpret();
  }
 };
 vector<string> Parse(string& s){
  vector<string> exp;
  for(int i=0; i<s.size(); ){
  char c = s[i];
  string token;
  if (c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')' ) {
  exp.push_back(token+c);
  i++;
  continue;
  }
  if ( isdigit(c) ) {
  while( isdigit(s[i]) ) {
  token.push_back(s[i++]);
  }
  exp.push_back(token);
  continue;
  }
  i++;
  }
  return exp;
 }
 int Priority(const string &c) {
  if (c == ""*"" || c == ""/"") {
  return 2;
  } else if (c== ""+"" || c == ""-"") {
  return 1;
  } else {
  return 0;
  }
 }
 vector<string> Infix2RPN(vector<string>& infix) {
  vector<string> rpn;
  stack<string> s;
  for(int i = 0; i < infix.size(); i++) {
  if(isdigit(infix[i][0])) { //number
  rpn.push_back(infix[i]);
  } else if (infix[i] == ""("") {
  s.push(infix[i]);
  } else if (infix[i] == "")"") {
  while(!s.empty() && s.top() != ""("") {
  rpn.push_back(s.top());
  s.pop();
  }
  s.pop();
  }else if(isOperator(infix[i]) ){
  while(!s.empty() && Priority(s.top()) >= Priority(infix[i])) {
  rpn.push_back(s.top());
  s.pop();
  }
  s.push(infix[i]);
  }
  }
  while(!s.empty()) {
  rpn.push_back(s.top());
  s.pop();
  }
  return rpn;
 }
 //Design Pattern for RPN - Memory Limit Exceeded!!
 int calculate_RPN_design_pattern(string& s) {
  vector<string> exp = Parse(s);
  //for (int i=0; i<exp.size(); i++){
  // cout << exp[i] << "" "";
  //}
  //cout << endl;
  exp = Infix2RPN(exp);
  for (int i=0; i<exp.size(); i++){
  cout << exp[i] << "" "";
  }
  cout << endl;
  Evaluator sentence(exp);
  return sentence.interpret();
 }
 /*
  * RPN - Reverse Polish Notation
  * see: https://en.wikipedia.org/wiki/Reverse_Polish_notation
  */
 //RPN evluation - Memory Limit Exceeded!!
 int calculate_RPN_evluation(string& s) {
  vector<string> exp = Parse(s);
  exp = Infix2RPN(exp);
  stack<int> ss;
  for(int i=0; i<exp.size(); i++) {
  if (isdigit(exp[i][0])) { 
  ss.push(atoi(exp[i].c_str()));
  }
  if (exp[i]==""+"" || exp[i]==""-"") {
  int rhs = ss.top(); ss.pop();
  int lhs = ss.top(); ss.pop();
  if (exp[i]==""-"") rhs = -rhs;
  ss.push(lhs + rhs);
  }
  }
  return ss.top();
 }
 //Two stack solution - quick & dirty solution
 inline void calculate_two_stacks(stack<int>& num_stack, stack<char>& op_stack) {
  int lhs = num_stack.top(); num_stack.pop();
  int rhs = num_stack.top(); num_stack.pop();
  char op = op_stack.top(); op_stack.pop();
  if (op=='-') rhs = -rhs;
  num_stack.push(lhs + rhs);
 }
 int calculate_two_stacks(string& s) {
  stack<int> num_stack; //put the number
  stack<char> op_stack; //put the operations
  for(int i = s.size() - 1; i >= 0; i--){
  if(s[i] == ')' || s[i] == '+' || s[i] == '-') {
  op_stack.push(s[i]);
  } else if(isdigit(s[i])){
  string num;
  num += s[i];
  while(isdigit(s[i-1])){
  num.insert(num.begin(), s[i-1]);
  i--;
  }
  num_stack.push(atoi(num.c_str())); 
  } else if(s[i] == '('){
  while(op_stack.top() != ')') {
  calculate_two_stacks(num_stack, op_stack);
  }
  op_stack.pop();
  }
  }
  while(!op_stack.empty()){ 
  calculate_two_stacks(num_stack, op_stack);
  }
  return num_stack.top();
 }
 int calculate(string s) {
  return calculate_two_stacks(s);
  return calculate_RPN_evluation(s);
  return calculate_RPN_design_pattern(s);
 }
 int main(int argc, char** argv) {
  string s = "" 15-(1+3)+(2+1) "";
  if (argc >1){
  s = argv[1];
  } 
  cout << s << "" = "" << calculate(s) << endl;
  cout << ""---------------"" << endl;
  s = ""(2+4)-(6+(1+5))"";
  cout << s << "" = "" << calculate(s) << endl;
 }"
18,18,"#include <iostream>
 #include <sstream>
 #include <string>
 #include <stack>
 using namespace std;
 /* 
  * Acuatlly, everything I've already implemented in ""Basic Calculator""(RPN way and Design pattern way).
  * So, here, I just use the quick-dirty way - just like the ""two stacks solution"" in ""Basic Calulator"".
  */
 //Quick & Dirty Solution
 bool isOperator(const char ch) {
  return (ch=='+' || ch=='-' || ch=='*' || ch=='/');
 }
 int Priority(const char c) {
  if (c == '*' || c == '/') {
  return 2;
  } else if (c== '+' || c == '-') {
  return 1;
  } else {
  return 0;
  }
 }
 long long calculate_exp(long long x, long long y, char op) {
  switch(op) {
  case '+': return x + y;
  case '-': return x - y;
  case '*': return x * y;
  case '/': return x / y;
  }
  return -1;
 }
 //Two Stacks solution
 int calculate_two_stacks(string& s) {
  s += ""+0"";
  stack<long long> num_stack; //put the number
  stack<char> op_stack; //put the operations
  #define CALCULATE_IT { \
  long long y = num_stack.top(); num_stack.pop(); \
  long long x = num_stack.top(); num_stack.pop(); \
  char op = op_stack.top(); op_stack.pop(); \
  num_stack.push(calculate_exp(x, y, op));\
  }
  for(int i = 0; i < s.size(); i++){
  char ch = s[i];
  if (isspace(ch)) continue;
  if (isdigit(ch)) {
  string num;
  num += s[i];
  while(isdigit(s[i+1])){
  num += s[i+1];
  i++;
  }
  num_stack.push(stoll(num));
  continue;
  }
  if (isOperator(ch)) {
  while (!op_stack.empty() && Priority(op_stack.top()) >= Priority(ch) ) {
  CALCULATE_IT;
  }
  op_stack.push(ch);
  }
  }
  while(!op_stack.empty()){
  CALCULATE_IT;
  }
  return num_stack.top();
 }
 int calculate(string s) {
  return calculate_two_stacks(s);
 }
 int main(int argc, char**argv) 
 {
  string exp = "" 3+5 / 2 "";
  if (argc>1) {
  exp = argv[1];
  }
  cout << ""\"""" << exp << ""\"" = "" << calculate(exp) << endl;
 }"
19,19,"class Solution {
 public:
  //
  // This solution is O(1) space dynamic programming 
  //
  // We can make sure the max profit at least be ZERO. So,
  // 1) we have two pointers (begin & end ) 
  // 2) if prices[end] - prices[begin] > 0, then move the ""end"" pointer to next
  // 3) if prices[end] - prices[begin] <= 0, then move the ""begin"" pointer to current posstion.
  // 4) tracking the max profit
  //
  // Notes:
  // Some people think find the highest-price & lowest-price, this is wrong. 
  // Because the highest-price must be after lowest-price
  //
  int maxProfit(vector<int> &prices) {
  int max=0, begin=0, end=0, delta=0;
  for (int i=0; i<prices.size(); i++) {
  end = i;
  delta = prices[end] - prices[begin];
  if (delta <= 0){
  begin = i;
  }
  if ( delta > max ){
  max = delta;
  }
  }
  return max;
  }
 };
 class Solution {
 public:
  int maxProfit(vector<int>& prices) {
  int buy = INT_MAX;
  int profit = 0;
  for (auto p : prices) {
    // Keep tracking the previous lowest price
  buy = min (buy, p);
  // Keep tacking the current max profit
  profit = max(profit, p - buy);
  }
  return profit;
  }
 };"
20,20,"class Solution {
 public:
  int maxProfit(vector<int>& prices) {
  return maxProfit02(prices);
  return maxProfit01(prices);
  }
  // Solution 1 
  // find all of ranges: which start a valley with the nearest peak after
  // add their delta together 
  //
  int maxProfit01(vector<int> &prices) {
  int max = 0;
  int low = -1;
 int len = prices.size();
  for (int i=0; i < len - 1; i++){
  //meet the valley, then goes up
  if (prices[i] < prices[i+1] && low < 0 ) {
  low = i;
  }
  //meet the peak, then goes down
  if (prices[i] > prices[i+1] && low >= 0) {
  max += ( prices[i] - prices[low] ) ;
  low = -1; // reset the `low`
  }
  }
  // edge case
  if ( low >= 0 ) {
  max += ( prices[prices.size()-1] - prices[low] );
  }
  return max;
  }
  // Solution 2 
  // if we find we can earn money, we just sell
  int maxProfit02(vector<int>& prices) {
  int profit = 0 ;
  for(int i=1; i< prices.size(); i++) {
  profit += max(0, prices[i] - prices[i-1]);
  }
  return profit;
  }
 };"
21,21,"class Solution {
 public:
  // Dynamic Programming
  //
  // Considering prices[n], and we have a position ""i"", we could have
  // 1) the maxProfit1 for prices[0..i] 
  // 2) the maxProfit2 for proices[i..n]
  //
  // So, 
  // for 1) we can go through the prices[n] forwardly.
  // forward[i] = max( forward[i-1], price[i] - lowestPrice[0..i] ) 
  // for 2) we can go through the prices[n] backwoardly.
  // backward[i] = max( backward[i+1], highestPrice[i..n] - price[i]) 
  //
  int maxProfit(vector<int> &prices) {
  if (prices.size()<=1) return 0;
  int n = prices.size();
  vector<int> forward(n);
  forward[0] = 0;
  int lowestBuyInPrice = prices[0];
  for(int i=1; i<n; i++){
  forward[i] = max(forward[i-1], prices[i] - lowestBuyInPrice);
  lowestBuyInPrice = min(lowestBuyInPrice, prices[i]);
  }
  vector<int> backward(n);
  backward[n-1] = 0;
  int highestSellOutPrice = prices[n-1];
  for(int i=n-2; i>=0; i--){
  backward[i] = max(backward[i+1], highestSellOutPrice - prices[i]);
  highestSellOutPrice = max(highestSellOutPrice, prices[i]);
  }
  int max_profit = 0;
  for(int i=0; i<n; i++){
  max_profit = max(max_profit, forward[i]+backward[i]);
  }
  return max_profit;
  }
 };"
22,22,"class Solution {
  public:
  /*
  * profits[trans, day]
  * - `trans` represents the number of transactions we've done so far. ( 0 <= trans <= k )
  * - `day` represents the number of days so far. ( 0 <= day <= prices.size() )
  *
  * So, we have the initialization as below:
  *
  * profits[0, day] = 0; // 0 <= day <= prices.size()
  * profits[trans, 0] = 0; // 0 <= trans <= k
  *
  * And the iteration logic as below:
  *
  * profits[trans, day] = max (
  * profits[trans, day-1], // same times transactions, but one days before.
  * profits[trans-1, i-1] + (prices[day] - prices[i]) // for all of (0 <= i < day )
  * // this means find max profit from
  * // previous any of days
  * )
  *
  */
  int maxProfit(int k, vector<int> &prices) {
  int ndays = prices.size();
  // error case
  if (ndays<=1) return 0;
  // Edge case
  // ---------
  // if the number of transactions is too many, it means we can make
  // as many transactions as we can, that brings us the problem back to
  // Best-Time-To-Buy-And-Sell-Stock-II which can be simply solve in O(n)
  // by using a greedy approach.
  if(k > ndays/2){
  int sum = 0;
  for (int i=1; i<ndays; i++) {
  sum += max(prices[i] - prices[i-1], 0);
  }
  return sum;
  }
  return maxProfit_DP03(k, prices);//8ms
  return maxProfit_DP02(k, prices);//8ms
  return maxProfit_DP01(k, prices);//492ms
  }
  //DP solution - O(kn^2) complexity
  int maxProfit_DP01 (int k, vector<int> &prices) {
  int ndays = prices.size();
  vector< vector<int> > profits(k+1, vector<int>( ndays+1, 0));
  for(int trans=1; trans<=k; trans++) {
  for (int day=1; day<=ndays; day++) {
  int m=0;
  for (int i=1; i<=day; i++) {
  m = max(m, profits[trans-1][i-1]+ prices[day-1] - prices[i-1]);
  }
  profits[trans][day] = max( profits[trans][day-1], m);
  }
  }
  return profits[k][ndays];
  }
  //DP solution - O(kn) complexity
  //Actually, we could save the loop in above- for(int i=1; i<=day; i++)
  //Becasue there are so many dupliations
  int maxProfit_DP02 (int k, vector<int> &prices) {
  int ndays = prices.size();
  vector< vector<int> > profits(k+1, vector<int>( ndays+1, 0));
  vector<int> m(ndays+1, 0); // tracking the max profits of previous days
  for(int trans=1; trans<=k; trans++) {
  m[0] = profits[trans-1][0] - prices[0];
  for (int day=1; day<=ndays; day++) {
  profits[trans][day] = max( profits[trans][day-1], m[day-1]+prices[day-1]);
  if (day < ndays) {
  m[day] = max(m[day-1], profits[trans-1][day] - prices[day]);
  }
  }
  }
  return profits[k][ndays];
  }
  // save the memory, remove the m[ ] array
  int maxProfit_DP03 (int k, vector<int> &prices) {
  int ndays = prices.size();
  vector< vector<int> > profits(k+1, vector<int>( ndays+1, 0));
  for(int trans=1; trans<=k; trans++) {
  int m = profits[trans-1][0] - prices[0];
  for (int day=1; day <= ndays; day++) {
  profits[trans][day] = max(profits[trans][day-1], m + prices[day-1]);
  if ( day < ndays ) {
  m = max(m, profits[trans-1][day] - prices[day]);
  }
  }
  }
  return profits[k][ndays];
  }
 };"
23,23,"class Solution {
 public:
  //
  //Define 
  //
  // - buy[i] as the max profit when you buy the stock at day i. 
  // - sell[i] as the max profit when you sell the stock at day i. 
  //
  // Therefore set buy[0] = -prices[0], because spend the money, the profit is -prices[0].
  // Also set sell[0] = 0, that you do nothing in the first day.
  //
  // So,
  // buy[i] = max(buy[i-1], // do nothing - keep holding
  // sell[i-2] - prices[i] ) // sell previous day, buy today
  // // i-1 is cooldown day
  // sell[i] = max(sell[i-1], // do nothing 
  // buy[i-1] + prices[i] ) // buy previous day, sell today.
  // 
  int maxProfit(vector<int>& prices) {
  int len = prices.size();
  if ( len < 2 ) return 0;
  vector<int> buy(len, 0);
  vector<int> sell(len, 0);
  //day 0
  buy[0] = -prices[0];
  sell[0] = 0;
  //day 1
  buy[1] = max(buy[0], 0 - prices[1]);
  sell[1] = max(sell[0], buy[0] + prices[1]);
  for (int i=2; i<len; i++) {
  buy[i] = max( buy[i - 1], sell[i - 2] - prices[i]); 
  sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]);
  }
  return sell[len-1];
  }
 };"
24,24,"class Solution {
 private:
  int max(int x, int y) {
  return x > y ? x: y;
  }
  int max(int x, int y, int z) {
  return max(x, max(y,z));
  }
 public:
  int maxProfit(vector<int>& prices, int fee) {
  return maxProfit_dp03(prices, fee); // 100ms
  return maxProfit_dp02(prices, fee); // 100ms
  return maxProfit_dp01(prices, fee); // 2700ms
  }
  // find the [buy-low, sell-high] prices pairs,
  // and remove the unnecessary prices.
  void genPricesPairs(vector<int> &prices, vector< pair<int, int> > &prices_pairs, int fee){
  int low = -1;
  for (int i=0; i<prices.size()-1; i++){
  //meet the valley, then goes up
  if (prices[i] < prices[i+1] && low < 0 ) {
  low = i;
  }
  //meet the peak, then goes down
  if (prices[i] > prices[i+1] && low >= 0) {
  prices_pairs.push_back( make_pair( prices[low], prices[i]) );
  low = -1; // reset the `low` & `high`
  }
  }
  // edge case
  if ( low >= 0 ) {
  prices_pairs.push_back( make_pair( prices[low], prices[prices.size()-1] ) );
  }
  }
  int maxProfit_dp01(vector<int> &prices, int &fee) {
  vector< pair<int, int> > prices_pairs;
  genPricesPairs(prices, prices_pairs, fee);
  vector<int> dp(prices_pairs.size()+1, 0);
  for (int i=0; i<prices_pairs.size(); i++) {
  for ( int j=0; j<=i; j++ ) {
  int profit = prices_pairs[i].second - prices_pairs[j].first - fee;
  // if the profit is negative, skip the transaction
  if ( profit < 0 ) profit = 0;
  dp[i+1] = max ( dp[i+1], dp[j] + profit);
  }
  }
  return dp[dp.size()-1];
  }
  int maxProfit_dp02(vector<int> &prices, int &fee) {
  vector< pair<int, int> > prices_pairs;
  genPricesPairs(prices, prices_pairs, fee);
  if ( prices_pairs.size() < 1 ) return 0;
  // first - represent the max profit if we buy.
  // second - represent the max profit if we sell.
  vector< pair<int,int> > dp(prices_pairs.size() , make_pair(0,0) );
  //buy profit - if we buy it in day 0, then we got negtive profit.
  dp[0].first = - prices_pairs[0].first;
  //sell profit - if we sell it in day 0, then we have the profits
  // if the profit is negtive, then won't sell it.
  dp[0].second = max(0, prices_pairs[0].second - prices_pairs[0].first - fee);
  for (int i=1; i<prices_pairs.size(); i++) {
  // BUY - we could have three options
  // 1) hold the stock do nothing. profit = previous day's buy profit
  // 2) sell & buy. profit = previous sell profit - spent money to buy.
  // 3) fresh buy, give up the pervious buy, just buy it today.
  // find the max profit of these 3 options.
  dp[i].first = max (dp[i-1].first, // option 1) do nothing
  dp[i-1].second - prices_pairs[i].first, // option 2) sell & buy
  - prices_pairs[i].first ); // option 3) fresh buy
  // SELL - we could have three options
  // 1) hold the stock do nothing. profit = previous day's sell profit
  // 2) sell it. profit = previous day's buy + today's sell.
  // 3) sell previous and sell today. profit = previous's sell + today's sell
  // Find the max profit of these 3 options
  dp[i].second = max(dp[i-1].second,
  dp[i-1].first + prices_pairs[i].second - fee,
  dp[i-1].second + prices_pairs[i].second - prices_pairs[i].first - fee );
  }
  return max( dp[dp.size()-1].second, 0 );
  }
  //
  // Actually, by given any day, we can have two status:
  // 1) BUY status - we can have two options at Day X.
  // i) buy stock - need previous sell status.(you cannot buy if you haven't sold)
  // ii) do nothing - need previous buy status.
  //
  // 2) SELL status - we can have two options at Day X.
  // i) sell stock - need previous buy status.(you cannot sell if you haven't bought)
  // ii) do nothing - keep the previous sell status.
  //
  // For example:
  //
  // if we have [1,3,2,8,4,9], fee = 2
  // then we could have the following BUY & SELL status
  //
  // Day One
  // 1 - BUY: the profit is -1 ,becuase we spent 1 money
  // SELL: you cannot sell, the profit is 0.
  // Day Two
  // 3 - BUY : pre-SELL - 3 = -3, but do nothing has max profit pre-BUY: -1
  // SELL: pre-BUY + 3 -2 = -1+3-2 = 0 , the max profit: 0
  // Day Three
  // 2 - BUY : pre-SELL - 2 = 0 - 2 = -2, do nothing has max profit: -1
  // SELL: pre-BUY + 2 -2 = -1 + 2 -2 = -1, do nothing has max profit: 0
  // Day Four
  // 8 - BUY : pre-SELL - 8 = 0 - 8 = -8, so, just hold, the max buy profit: -1
  // SELL: pre-BUY + 8 - 2 = -1+8-2 =5, the max profit is 5
  // Day Five
  // 4 - BUY : pre-SELL - 4 = 5-4 = 1, do nothing profit is -1, so should buy it.
  // so, the max buy profit is 1.
  // SELL: pre-BUY + 4 -2 = -1 + 4 -2= 1, it's has lower profit than previous,
  // so, we won't sell, the max sell profit is 5.
  // Day Six
  // 9 - BUY : pre-SELL - 9 = 5-9= -4, so won't buy, the max buy profit is 1.
  // SELL: pre-BUY + 9 -2 = 1 + 9 -2 = 8, it's has higher profit. so we sell
  //
  // Let's use an table
  //
  // prices = 1, 3, 2, 8, 4, 9
  // max buy profit = -1, -1, -1, -1, 1, 5
  // max sell profit = 0, 0, 0, 5, 5, 8
  //
  // We can see we keep tracking the max buy and sell profit for everyday.
  //
  // buy[i] = max( buy[i-1], // do nothing
  // sell[i-1] - prices[i] ); // sell in previous day can buy today
  //
  // sell[i] = max( sell[i-1], // do nothing
  // buy[i-1] + prices[i] - fee ); // sell today
  //
  int maxProfit_dp03(vector<int> &prices, int &fee) {
  int buy=-prices[0], sell=0;
  int pre_buy=0, pre_sell=0;
  for(auto price: prices) {
  pre_buy = buy;
  buy = max (sell - price, pre_buy);
  pre_sell = sell;
  sell = max( pre_buy + price - fee, pre_sell);
  }
  return sell;
  }
 };"
25,25,"class BSTIterator {
  private:
  vector<int> v; 
  int pos;
  public:
  //Travse the Tree in-order and covert it to an array
  BSTIterator(TreeNode *root) {
  pos = 0;
  vector<TreeNode*> stack;
  while(stack.size()>0 || root !=NULL) {
  if (root){
  stack.push_back(root);
  root = root->left;
  }else{
  root = stack.back();
  stack.pop_back();
  v.push_back(root->val);
  root = root->right;
  }
  }
  }
  /** @return whether we have a next smallest number */
  bool hasNext() {
  return pos < v.size();
  }
  /** @return the next smallest number */
  int next() {
  return v[pos++];
  }
 };"
26,26,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  vector<int> inorderTraversal(TreeNode *root) {
  vector<TreeNode*> stack;
  vector<int> v;
  while(stack.size()>0 || root!=NULL){
  if (root!=NULL){
  stack.push_back(root);
  root = root->left;
  }else{
  if (stack.size()>0) {
  root = stack.back();
  stack.pop_back();
  v.push_back(root->val);
  root = root->right;
  }
  }
  }
  return v;
  }
 };"
27,27,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <queue>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 vector<vector<int> > levelOrder1(TreeNode *root);
 vector<vector<int> > levelOrder2(TreeNode *root);
 vector<vector<int> > levelOrder3(TreeNode *root);
 vector<vector<int> > levelOrder(TreeNode *root) {
  if (random()%2){
  return levelOrder1(root);
  }
  if (random()%2){
  return levelOrder3(root);
  }
  return levelOrder2(root);
 }
 vector<vector<int> > levelOrder1(TreeNode *root) {
  queue<TreeNode*> q;
  vector< vector<int> > vv;
  vector<int> v;
  if (root){
  v.push_back(root->val);
  vv.push_back(v);
  }
  q.push(root);
  int i=0;
  vector<TreeNode*> vt; 
  while(q.size()>0){
  TreeNode *p = q.front();
  q.pop();
  vt.push_back(p); 
  if ( p==NULL ) {
  continue;
  }
  q.push(p->left);
  q.push(p->right);
  }
  int step = 2;
  int j; 
  for (int i=1; i<vt.size(); i=j ){
  v.clear();
  int cnt=0;
  for (j=i; j<i+step && j<vt.size(); j++){
  if (vt[j]) {
  v.push_back(vt[j]->val);
  cnt += 2; 
  }
  } 
  step = cnt;
  if (v.size()>0) {
  vv.push_back(v);
  }
  }
  return vv;
 }
 vector<vector<int> > levelOrder2(TreeNode *root) {
  vector< vector<int> > vv;
  vector<int> v;
  if (root){
  v.push_back(root->val);
  vv.push_back(v);
  }
  vector< vector<int> > vv_left, vv_right;
  if(root && root->left) {
  vv_left = levelOrder2(root->left);
  }
  if(root && root->right) {
  vv_right = levelOrder2(root->right);
  }
  //merge
  for(int i=0; i<vv_left.size() || i < vv_right.size(); i++){
  if (i<vv_left.size() && i<vv_right.size()){
  vv_left[i].insert(vv_left[i].end(), vv_right[i].begin(), vv_right[i].end());
  vv.push_back(vv_left[i]);
  }else if (i<vv_left.size()) {
  vv.push_back(vv_left[i]);
  }else {
  vv.push_back(vv_right[i]);
  }
  }
  return vv;
 }
 vector<vector<int> > levelOrder3(TreeNode *root) {
  vector< vector<int> > vv;
  if(root == NULL) return vv;
  int level = 0; // current level.
  TreeNode *last = root; // last node of currrent level.
  queue<TreeNode*> q;
  q.push(root);
  vv.push_back(vector<int>());
  while(!q.empty()) {
  TreeNode *p = q.front();
  q.pop();
  vv[level].push_back(p->val);
  if(p->left ) q.push(p->left);
  if(p->right) q.push(p->right);
  if(p == last) {
  level++;
  last = q.back();
  vv.push_back(vector<int>()); // new buffer for next row.
  }
  }
  vv.pop_back();
  return vv;
 }
 void printTree(TreeNode *root)
 {
  if (root == NULL){
  printf(""# "");
  return;
  }
  printf(""%d "", root->val );
  printTree(root->left);
  printTree(root->right);
 }
 void printTree_level_order(TreeNode *root)
 {
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0){
  TreeNode* n = q.front();
  q.pop();
  if (n==NULL){
  cout << ""# "";
  continue;
  }
  cout << n->val << "" "";
  q.push(n->left);
  q.push(n->right);
  } 
  cout << endl;
 }
 TreeNode* createTree(int a[], int n)
 {
  if (n<=0) return NULL;
  TreeNode **tree = new TreeNode*[n];
  for(int i=0; i<n; i++) {
  if (a[i]==0 ){
  tree[i] = NULL;
  continue;
  }
  tree[i] = new TreeNode(a[i]);
  } 
  int pos=1;
  for(int i=0; i<n && pos<n; i++) { 
  if (tree[i]){
  tree[i]->left = tree[pos++];
  if (pos<n){
  tree[i]->right = tree[pos++];
  }
  }
  }
  return tree[0];
 }
 int printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  cout << ""["";
  for(int j=0; j<vv[i].size(); j++) {
  cout << "" "" << vv[i][j];
  }
  cout << ""]"" << endl;;
  }
 }
 int main()
 {
  TreeNode *p;
  vector< vector<int> > vv;
  int a[] = {1,2,3,4,5,0,0};
  p = createTree(a, sizeof(a)/sizeof(int));
  printTree_level_order(p);
  vv = levelOrder(p);
  printMatrix(vv);
  cout << endl;
  int b[] = {1,0,2};
  p = createTree(b, sizeof(b)/sizeof(int));
  printTree_level_order(p);
  vv = levelOrder(p);
  printMatrix(vv);
  cout << endl;
  int c[] = {1,2,0,3,0,4,0,5};
  p = createTree(c, sizeof(c)/sizeof(int));
  printTree_level_order(p);
  vv = levelOrder(p);
  printMatrix(vv);
  cout << endl;
  int d[] = {1,2,3,4,0,0,5};
  p = createTree(d, sizeof(d)/sizeof(int));
  printTree_level_order(p);
  vv = levelOrder(p);
  printMatrix(vv);
  cout << endl;
  return 0;
 }"
28,28,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  vector<vector<int> > levelOrderBottom(TreeNode *root) {
  queue<TreeNode*> q;
  vector< vector<int> > vv;
  vector<int> v;
  if (root){
  v.push_back(root->val);
  vv.push_back(v);
  }
  q.push(root);
  int i=0;
  vector<TreeNode*> vt;
  while(q.size()>0){
  TreeNode *p = q.front();
  q.pop();
  vt.push_back(p);
  if ( p==NULL ) {
  continue;
  }
  q.push(p->left);
  q.push(p->right);
  }
  int step = 2;
  int j;
  for (int i=1; i<vt.size(); i=j ){
  v.clear();
  int cnt=0;
  for (j=i; j<i+step && j<vt.size(); j++){
  if (vt[j]) {
  v.push_back(vt[j]->val);
  cnt += 2;
  }
  }
  step = cnt;
  if (v.size()>0) {
  vv.push_back(v);
  }
  }
  //reverse the order
  reverse(vv.begin(), vv.end());
  return vv;
  }
 };"
29,29,"#include <iostream>
 #include <algorithm>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 //The solution is quite simple can be explained by itself
 int maxPathSum(TreeNode *root, int& maxSum ) {
  if (NULL == root) return 0;
  //get the maxPathSum for both left and right branch
  int left = maxPathSum(root->left, maxSum);
  int right = maxPathSum(root->right, maxSum);
  // The max sum could be one of the following situations:
  // 1) root + left
  // 2) root + right
  // 3) root
  // 4) root + left + right 
  //
  // And the whole function need to return the the max of 1) 2) 3) 
  int val = root->val;
  int maxBranch = left > right ? max(left + val, val) : max(right + val, val);
  int m = max(left + right + val, maxBranch);
  maxSum = max(maxSum, m);
  return maxBranch;
 }
 int maxPathSum(TreeNode *root) {
  #define INT_MIN (-2147483647 - 1)
  int maxSum = INT_MIN;
  maxPathSum(root, maxSum);
  return maxSum;
 }
 int main()
 {
  TreeNode root(1);
  TreeNode left(2);
  TreeNode right(3);
  root.left = &left;
  root.right = &right;
  cout << maxPathSum(&root) << endl; 
  return 0;
 }"
30,30,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  vector<string> TreePaths;
  void DFS(TreeNode* node, string answer)
  {
  answer += ""->"" + to_string(node->val);
  if(node->left == NULL && node->right == NULL)
  TreePaths.push_back(answer);
  else
  {
  if(node->left != NULL)
  DFS(node->left, answer);
  if(node->right != NULL)
  DFS(node->right, answer);
  }
  }
  vector<string> binaryTreePaths(TreeNode* root) {
  if(root != NULL)
  {
  DFS(root, """");
  for(int i = 0; i < TreePaths.size(); i++)
  TreePaths[i].erase(TreePaths[i].begin(), TreePaths[i].begin() + 2);
  }
  return TreePaths;
  }
 };
 // Another more clear DFS implementation
 class Solution {
 public:
  void binaryTreePathsHelper(TreeNode* root, vector<int> solution, vector<string>& result ) {
  if (!root) return;
  solution.push_back(root->val);
  //meet the leaf node, shape a path into the result
  if (root->left==NULL && root->right==NULL){
  if(solution.size()>0){
  stringstream ss;
  for(int i=0; i<solution.size(); i++){
  ss << solution[i] << (i<solution.size()-1 ? ""->"":"""");
  }
  result.push_back(ss.str());
  }
  return;
  }
  binaryTreePathsHelper(root->left, solution, result);
  binaryTreePathsHelper(root->right, solution, result);
  }
  vector<string> binaryTreePaths(TreeNode* root) {
  vector<string> result;
  vector<int> solution;
  binaryTreePathsHelper(root, solution, result);
  return result;
  }
 };"
31,31,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 vector<int> postorderTraversal1(TreeNode *root);
 vector<int> postorderTraversal2(TreeNode *root);
 // We have two methods here.
 // 1) the first one acutally is pre-order but reversed the access order.
 // 2) the second one is the traditional one 
 vector<int> postorderTraversal(TreeNode *root) {
  if (random()%2){
  cout << ""---method one---"" << endl;
  return postorderTraversal1(root);
  }
  cout << ""---method two---"" << endl;
  return postorderTraversal2(root);
 }
 vector<int> postorderTraversal1(TreeNode *root) {
  vector<int> v;
  vector<TreeNode*> stack;
  if (root) {
  stack.push_back(root);
  }
  while (stack.size()>0){
  TreeNode *n = stack.back();
  stack.pop_back();
  v.push_back(n->val);
  if (n->left){
  stack.push_back(n->left);
  } 
  if (n->right) {
  stack.push_back(n->right);
  }
  }
  std::reverse(v.begin(), v.end()); // the trick
  return v;
 }
 // traditional and standard way.
 // using the stack to simulate the recursive function stack.
 vector<int> postorderTraversal2(TreeNode *root) {
  vector<int> v;
  vector<TreeNode*> stack;
  TreeNode *node = root;
  TreeNode *lastVisitNode = NULL;
  while(stack.size()>0 || node!=NULL){
  if (node != NULL){
  // keep going the left
  stack.push_back(node);
  node = node->left;
  }else{
  TreeNode *n = stack.back();
  // left way is finsised, keep going to the right way
  if (n->right != NULL && lastVisitNode != n->right){
  node = n->right;
  }else{
  // both left and right has been accessed.
  stack.pop_back();
  v.push_back(n->val);
  lastVisitNode = n;
  }
  }
  }
  return v;
 }
 TreeNode* createTree(int a[], int n)
 {
  if (n<=0) return NULL;
  TreeNode **tree = new TreeNode*[n];
  for(int i=0; i<n; i++) {
  if (a[i]==0 ){
  tree[i] = NULL;
  continue;
  }
  tree[i] = new TreeNode(a[i]);
  }
  int pos=1;
  for(int i=0; i<n && pos<n; i++) {
  if (tree[i]){
  tree[i]->left = tree[pos++];
  if (pos<n){
  tree[i]->right = tree[pos++];
  }
  }
  }
  return tree[0];
 }
 void printTree_post_order(TreeNode *root)
 {
  if (root == NULL){
  //cout << ""# "";
  return ;
  }
  printTree_post_order(root->left);
  printTree_post_order(root->right);
  cout << root->val << "" "";
 }
 void printArray(vector<int> v)
 {
  for(int i=0; i<v.size(); i++){
  cout << v[i] << "" "";
  }
  cout << endl;
 }
 int main()
 {
  srand(time(0));
  int a[] = {1,2,3,4,5,0,6,0,0,7,8,9,0};
  TreeNode* p = createTree(a, sizeof(a)/sizeof(int));
  printTree_post_order(p);
  cout << endl;
  vector<int> v = postorderTraversal(p);
  printArray(v);
  cout << endl;
  return 0;
 }"
32,32,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 vector<int> preorderTraversal1(TreeNode *root);
 vector<int> preorderTraversal2(TreeNode *root);
 vector<int> preorderTraversal(TreeNode *root) {
  if (random()%2){
  cout << ""---method one---"" << endl;
  return preorderTraversal1(root);
  }
  cout << ""---method two---"" << endl;
  return preorderTraversal2(root);
 }
 vector<int> preorderTraversal1(TreeNode *root) {
  vector<int> v;
  vector<TreeNode*> stack;
  if (root) {
  stack.push_back(root);
  }
  while (stack.size()>0){
  TreeNode* n = stack.back();
  v.push_back(n->val);
  stack.pop_back();
  if (n->right){
  stack.push_back(n->right);
  }
  if (n->left){
  stack.push_back(n->left);
  }
  }
  return v;
 }
 vector<int> preorderTraversal2(TreeNode *root) {
  vector<int> v;
  vector<TreeNode*> stack;
  stack.push_back((TreeNode*)NULL);
  TreeNode *top = root;
  while(top!=NULL){
  v.push_back(top->val);
  if (top->right !=NULL){
  stack.push_back(top->right);
  }
  if (top->left != NULL){
  stack.push_back(top->left);
  }
  top = stack.back();
  stack.pop_back();
  }
  return v;
 }
 TreeNode* createTree(int a[], int n)
 {
  if (n<=0) return NULL;
  TreeNode **tree = new TreeNode*[n];
  for(int i=0; i<n; i++) {
  if (a[i]==0 ){
  tree[i] = NULL;
  continue;
  }
  tree[i] = new TreeNode(a[i]);
  }
  int pos=1;
  for(int i=0; i<n && pos<n; i++) {
  if (tree[i]){
  tree[i]->left = tree[pos++];
  if (pos<n){
  tree[i]->right = tree[pos++];
  }
  }
  }
  return tree[0];
 }
 void printTree_pre_order(TreeNode *root)
 {
  if (root == NULL){
  //cout << ""# "";
  return ;
  }
  cout << root->val << "" "";
  printTree_pre_order(root->left);
  printTree_pre_order(root->right);
 }
 void printArray(vector<int> v)
 {
  for(int i=0; i<v.size(); i++){
  cout << v[i] << "" "";
  }
  cout << endl;
 }
 int main()
 {
  srand(time(0));
  int a[] = {1,2,3,4,5,0,6,0,0,7,8,9,0};
  TreeNode* p = createTree(a, sizeof(a)/sizeof(int));
  printTree_pre_order(p);
  cout << endl;
  vector<int> v = preorderTraversal(p);
  printArray(v);
  cout << endl;
  return 0;
 }"
33,33,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  void rightSideViewHelper(TreeNode* root, int level, vector<int>& result) {
  if (root == NULL) return;
  if ( result.size() < level ) result.push_back(root->val);
  rightSideViewHelper(root->right, level+1, result);
  rightSideViewHelper(root->left, level+1, result);
  }
  void rightSideViewHelper(TreeNode* root, vector<int>& result) {
  if (root==NULL) return;
  vector<TreeNode*> stack;
  vector<int> level;
  stack.push_back(root);
  level.push_back(1);
  while (stack.size()>0) {
  TreeNode* r = stack.back(); stack.pop_back();
  int l = level.back(); level.pop_back();
  if ( result.size() < l ) {
  result.push_back(r->val);
  }
  if (r->left) {
  stack.push_back(r->left);
  level.push_back(l+1);
  }
  if (r->right) {
  stack.push_back(r->right);
  level.push_back(l+1);
  }
  }
  }
  vector<int> rightSideView(TreeNode *root) {
  vector<int> result;
  if (rand()%2){
  rightSideViewHelper(root, 1, result);
  }else{
  rightSideViewHelper(root, result);
  }
  return result;
  }
 };"
34,34,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  TreeNode *upsideDownBinaryTree(TreeNode *root) {
  //using a dummy node to help to store the new tree 
  TreeNode dummy(0);
  TreeNode *head = &dummy, *left=NULL, *right=NULL;
  while ( root!=NULL ) {
  //find the right & left
  left = root->right;
  right = root;
  //move root the next
  root = root->left;
  //replace the right with current root
  right->left = head->left;
  right->right = head->right;
  //move the dummy to the root
  dummy.right = right;
  dummy.left = left;
  //reset the head to the root
  head = &dummy;
  }
  return head->right;
  }
 };"
35,35,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <queue>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 vector<TreeNode*> TreeToArray_level_order(TreeNode* root);
 vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
  if (random()%2){
  return zigzagLevelOrder1(root);
  }
  return zigzagLevelOrder2(root);
 }
 vector<vector<int> > zigzagLevelOrder1(TreeNode *root) {
  vector<vector<int> > result;
  vector<TreeNode*> tree = TreeToArray_level_order(root);
  int curLevelCnt = 1;
  int nextLevelCnt = 1;
  int level=0;
  for (int i=0; i<tree.size(); i+=curLevelCnt ){
  int cnt=0;
  level++;
  vector<int> v;
  if (level%2==0){
  for(int j=i+nextLevelCnt-1; j>=i; j--){
  if (tree[j]){
  cnt += 2;
  v.push_back(tree[j]->val);
  }
  }
  }else{
  for(int j=i; j<i+nextLevelCnt; j++){
  if (tree[j]){
  cnt += 2;
  v.push_back(tree[j]->val);
  }
  }
  }
  curLevelCnt = nextLevelCnt;
  nextLevelCnt = cnt;
  if (v.size()>0){
  result.push_back(v);
  }
  }
  return result;
 }
 vector<TreeNode*> TreeToArray_level_order(TreeNode* root){
  vector <TreeNode*> result;
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0) {
  TreeNode* n = q.front();
  q.pop();
  result.push_back(n);
  if (n==NULL){
  //cout << ""# "";
  continue;
  }
  //cout << n->val << "" "";
  q.push(n->left);
  q.push(n->right);
  }
  //cout << endl;
  return result;
 }
 vector<vector<int> > zigzagLevelOrder2(TreeNode *root) {
  vector<vector<int> > vv;
  if(root == NULL) return vv;
  int level = 0;
  TreeNode *last = root;
  queue<TreeNode*> q;
  q.push(root);
  vv.push_back(vector<int>());
  while(!q.empty()) {
  TreeNode *p = q.front();
  q.pop();
  vv[level].insert(level%2 ? vv[level].begin() : vv[level].end(), p->val);
  if(p->left) q.push(p->left);
  if(p->right) q.push(p->right);
  if(p == last) {
  level++;
  last = q.back();
  vv.push_back(vector<int>());
  }
  }
  vv.pop_back();
  return vv;
 }
 void printTree_level_order(TreeNode *root)
 {
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0){
  TreeNode* n = q.front();
  q.pop();
  if (n==NULL){
  cout << ""# "";
  continue;
  }
  cout << n->val << "" "";
  q.push(n->left);
  q.push(n->right);
  }
  cout << endl;
 }
 TreeNode* createTree(int a[], int n)
 {
  if (n<=0) return NULL;
  TreeNode **tree = new TreeNode*[n];
  for(int i=0; i<n; i++) {
  if (a[i]==0 ){
  tree[i] = NULL;
  continue;
  }
  tree[i] = new TreeNode(a[i]);
  }
  int pos=1;
  for(int i=0; i<n && pos<n; i++) {
  if (tree[i]){
  tree[i]->left = tree[pos++];
  if (pos<n){
  tree[i]->right = tree[pos++];
  }
  }
  }
  return tree[0];
 }
 int printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  cout << ""["";
  for(int j=0; j<vv[i].size(); j++) {
  cout << "" "" << vv[i][j];
  }
  cout << "" ]"" << endl;;
  }
 }
 int main(int argc, char** argv)
 {
  TreeNode *p;
  vector< vector<int> > vv;
  int a[] = {3,9,20,0,0,15,7};
  p = createTree(a, sizeof(a)/sizeof(int));
  printTree_level_order(p);
  vv = zigzagLevelOrder(p);
  printMatrix(vv);
  cout << endl;
  return 0;
 }"
36,36,"class Solution {
 private:
  void combination(int nLED, int nLight, int max, bool zero,
  int start, int k, int solution, 
  vector<vector<string>>& result) {
  if (solution > max){
  return;
  }
  if (k == 0) {
  char tmp[5] = """";
  if (zero) {
  sprintf(tmp, ""%02d"", solution);
  }else{
  sprintf(tmp, ""%d"", solution);
  }
  result[nLight].push_back(tmp);
  return;
  }
  for (int i=start; i<=nLED-k; i++) {
  solution += pow(2, i);
  combination(nLED, nLight, max, zero, i+1, k-1, solution, result);
  solution -= pow(2, i);
  }
  }
  void generate_combination(int nLED, int max, bool zero, vector<vector<string>>& result) {
  for (int i=0; i<nLED; i++) {
  combination(nLED, i, max, zero, 0, i, 0, result);
  }
  }
  void print(vector<vector<string>>& vv) {
  for(auto v : vv) {
  cout << ""[ "";
  for (auto i : v) {
  cout << i << "" "";
  }
  cout << ""]"" << endl;
  }
  }
 private:
  vector<vector<string>> hour;
  vector<vector<string>> mins;
 public:
  Solution():hour(4, vector<string>()), mins(6, vector<string>()){
  generate_combination(4, 11, false, hour);
  //print(hour);
  //[ 0 ]
  //[ 1 2 4 8 ]
  //[ 3 5 9 6 10 ]
  //[ 7 11 ]
  generate_combination(6, 59, true, mins);
  //print(mins);
  //[ 00 ]
  //[ 01 02 04 08 16 32 ]
  //[ 03 05 09 17 33 06 10 18 34 12 20 36 24 40 48 ]
  //[ 07 11 19 35 13 21 37 25 41 49 14 22 38 26 42 50 28 44 52 56 ]
  //[ 15 23 39 27 43 51 29 45 53 57 30 46 54 58 ]
  //[ 31 47 55 59 ] 
  }
  vector<string> readBinaryWatch(int num) {
  vector<string> result;
  for (int i = 0; i <= 3 && i <= num; i++) {
  if (num - i > 5) {
  continue;
  }
  for (auto h : hour[i]) {
  for (auto m : mins[num - i]) {
  result.push_back( h + "":"" + m );
  }
  }
  }
  return result;
  }
 };"
37,37,"#include <stdlib.h>
 #include <iostream>
 using namespace std;
 /*
  Idea: 
  1) we know when a number add one, some of the right bit changes from 0 to 1 or from 1 to 0
  2) if a bit is 0, then AND will cause this bit to 0 eventually.
  So, we can just simply check how many left bits are same for m and n. 
  for example: 
  5 is 101
  6 is 110
  when 5 adds 1, then the right two bits are changed. the result is 100
  6 is 110
  7 is 111
  when 6 adds 1, then the right one bit is changed. the result is 110.
  9 is 1001
  10 is 1010
  11 is 1011
  12 is 1100
  Comparing from 9 to 12, we can see the first left bit is same, that's result.
 */
 int rangeBitwiseAnd(int m, int n) {
  int mask = 0xffffffff;
  /* find out the same bits in left side*/
  while (mask != 0) {
  if ((m & mask) == (n & mask)) {
  break;
  }
  mask <<= 1;
  }
  return m & mask;
 }
 int main(int argc, char**argv) {
  int m=5, n=7;
  if (argc>2){
  m = atoi(argv[1]);
  n = atoi(argv[2]);
  }
  cout << ""range( "" << m << "", "" << n << "" ) = "" << rangeBitwiseAnd(m, n) << endl;
  return 0;
 }"
38,38,"class Solution {
 public:
  int brokenCalc(int X, int Y) {
  if (X >= Y) return X-Y ;
  if ( Y%2 ==0 ) return brokenCalc(X, Y/2) + 1;
  return brokenCalc(X, Y+1) + 1;
  }
 };"
39,39,"class Solution {
 public:
  bool buddyStrings(string A, string B) {
  if (A.size() != B.size()) return false;
  if (A.size()<2) return false;
  bool bRepeat = false;
  bool map[26] = {false};
  int idx[2], diffCnt=0;
  for (int i=0; i<A.size(); i++){
  if (map[A[i]-'a']) { bRepeat = true;}
  map[A[i]-'a']=true;
  if ( A[i] != B[i] ) {
  if (diffCnt>=2) return false;
  idx[diffCnt++] = i;
  }
  }
  //if A == B and there has repeated chars , then return true
  if (diffCnt==0 && bRepeat) return true;
  return (A[idx[0]] == B[idx[1]] && A[idx[1]] == B[idx[0]]);
  }
 };"
40,40,"/*
  At first, let's build the perfect pyramid at the corner.
  we can find the following sequence:
  height cubes
  1 1
  2 1 + 2 = 3
  3 1 + 2 + 3 = 6
  4 1 + 2 + 3 + 4 = 10
  5 1 + 2 + 3 + 4 + 5 = 15
  total(height) = total(height - 1) + sum( from 1 to height )
  sum ( from 1 to height) = (height * (height+1)) / 2
  = height^2/2 + height/2
  So,
  total(height) = (1+2+...+height)/2 + ( 1^2 + 2^2 +...+ height^2 ) / 2
  we know, Î£n^2 = [n(n+1)(2n+1)]/6 (ref: https://brilliant.org/wiki/sum-of-n-n2-or-n3/)
  So, 
  total(height) = (height * (height+1)) / 4 + (height(height+1)(2height+1))/12
  = height * (height + 1) * (height + 2) / 6
  for the rest cubes, we can place them like this
  (10) 
  (6) (9) 
  (3) (5) (8) 
  (1) (2) (4) (7) 
  sum ( for 1 to n ) = n(n+1)/2
 */
 class Solution {
 private:
  int total(long h){
  return h * (h+1) * (h+2) / 6;
  }
 public:
  int minimumBoxes(int n) {
  //find the maxiumn height which total(height) <= n
  //binary search
  int left = 1, right = pow(6l*n, 1.0/3) ;
  while(left <= right){
  int mid = left + (right - left) / 2;
  int t = total(mid);
  if ( t == n ) return mid*(mid+1l)/2;
  if ( t < n) left = mid + 1;
  else right = mid - 1;
  }
  int height = right;
  int remind = n - total(height);
  int bottom = height * (height+1l)/2 ;
  //cout << ""n="" << n << "", height="" << height << 
  // "", bottom = "" << bottom << "", remind="" << remind << endl;
  //find teh maxium h which sum(1..h) <= remind
  //binary search
  left = 1; right = sqrt(2*remind);
  while ( left <= right) {
  int mid = left + (right - left)/2;
  int h = mid*(mid+1)/2;
  if ( h == remind) return bottom + mid;
  if ( h < remind) left = mid + 1;
  else right = mid -1;
  }
  //cout << ""left="" << left << "", right="" << right << endl;
  return bottom + left;
  }
 };"
41,41,"/* Solution
  * --------
  *
  * We know, 
  * - if a bulb can be switched to ON eventually, it must be switched by ODD times
  * - Otherwise, if a bulb has been switched by EVEN times, it will be OFF eventually.
  * So, 
  * - If bulb `i` ends up ON if and only if `i` has an ODD numbers of divisors.
  * And we know, 
  * - the divisors come in pairs. for example: 
  * 12 - [1,12] [2,6] [3,4] [6,2] [12,1] (the 12th bulb would be switched by 1,2,3,4,6,12)
  * - the pairs means almost all of the numbers are switched by EVEN times.
  *
  * But we have a special case - square numbers
  * - A square number must have a divisors pair with same number. such as 4 - [2,2], 9 - [3,3]
  * - So, a square number has a ODD numbers of divisors.
  *
  * At last, we figure out the solution is: 
  * 
  * Count the number of the squre numbers!! 
  */
 class Solution {
 public:
  int bulbSwitch(int n) {
  int cnt = 0;
  for (int i=1; i*i<=n; i++) { 
  cnt++;
  }
  return cnt;
  }
 };
  /* 
  * Solution 1 - O(1)
  * =========
  *
  * We notice that for every light bulb on position i there will be one toggle for every
  * one of its divisors, given that you toggle all of the multiples of one number. The 
  * total number of toggles is irrelevant, because there are only 2 possible positions(on, 
  * off). We quickly find that 2 toggles cancel each other so given that the start position
  * is always off a light bulb will be in if it has been toggled an odd number of times.
  * The only integers with an odd number of divisors are perfect squares(because the square
  * root only appears once, not like the other divisors that form pairs). The problem comes
  * down to finding the number of perfect squares <= n. That number is the integer part of
  * the square root of n.
  * 
  */
 class Solution {
 public:
  int bulbSwitch(int n) {
  return (int)sqrt(n);
  }
 };"
42,42,"/*
 We have 4 operations:
  1) Flip all the lights.
  2) Flip lights with even numbers.
  3) Flip lights with odd numbers.
  4) Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...
 if we do 1) + 2), it's same as 3)
 if we do 1) + 3), it's same as 2)
 if we do 2) + 3), it's same as 1)
 if we do 1) + 2) + 3), it's same as do nothing
 So, we can manaully calculate how many different state we could have:
  m = 1, then 1), 2), 3), 4) 
  m = 2, then 1)+2), 1)+3), 1)+4), 2)+3), 2)+4), 3)+4) and 1)+1) => inital state
  m = 3, then 1), 2), 3), 4), 1)+4), 2+4), 3)+4), and 1)+2)+3) => inital state
 notice: 
  if m == 1, we could only have 4 states at most.
  if m == 2, we could only have 7 states at most. (no the 4) state) 
  if m > 2, we could only have 8 states at most. (has the 4) state)
 But for some edge cases, we need to take care specially. For example:
  - m = 0 or n = 0, only 1 state.
  - n = 1, then 2 states.
  - n = 2, then it could have 3(when m=1), or 4 states (whem m>1)
  - n > 2 && m = 1, then it only could have 4 states.
 */
 class Solution {
 public:
  int flipLights(int n, int m) {
  if (m == 0 || n == 0) return 1;
  if (n == 1) return 2;
  if (n == 2) return m == 1? 3:4;
  if (m == 1) return 4;
  return m==2 ? 7 :8;
  }
 };"
43,43,"class Solution {
 public:
  int numTimesAllBlue(vector<int>& light) {
  int n = light.size();
  vector<bool> on(n, false);
  int left = 0; //tracking the most left place that all bubls are truned on.
  int result = 0;
  for(int i=0; i<light.size(); i++){
  on[light[i]-1] = true;
  while (left < n && on[left]) left++;
  //if the bulbs are on left is equal to current bulbs we trun on.
  //then they all are blue.
  if (left == i+1) result++; 
  }
  return result;
  }
 };"
44,44,"class Solution {
 public:
  int minFlips(string target) {
  //flip the target to initalization
  int flip = 0;
  for(auto state : target) {
  if (state == '0' && flip % 2 == 1 ) flip++;
  if (state == '1' && flip % 2 == 0 ) flip++;
  }
  return flip;
  }
 };"
45,45,"class Solution {
 public:
  string getHint(string secret, string guess) {
  return getHint02(secret, guess);
  return getHint01(secret, guess);
  }
  string getHint01(string secret, string guess) {
  int appears_in_secret[10] = {0}, appears_in_guess[10] = {0}, bulls[10] = {0};
  int total_bulls = 0, total_cows = 0;
  for(int i = 0; i < secret.size(); i++)
  appears_in_secret[secret[i] - '0']++;
  for(int i = 0; i < guess.size(); i++)
  {
  if(secret[i] == guess[i])
  bulls[secret[i] - '0']++;
  appears_in_guess[guess[i] - '0']++;
  }
  for(int i = 0; i <= 9; i++)
  {
  total_bulls += bulls[i];
  total_cows += min(appears_in_secret[i], appears_in_guess[i]) - bulls[i];
  }
  return to_string(total_bulls) + ""A"" + to_string(total_cows) + ""B"";
  }
  // Another implemntation - to save more space
  string getHint02(string secret, string guess) {
  const int digital_num = 10;
  int secret_stat[digital_num]={0};
  int bull = 0;
  for(int i=0; i<secret.size(); i++) {
  //both number & location are matched, count bull
  if ( secret[i] == guess[i] ) {
  bull++;
  continue;
  }
  //otherwise, count the unmatched digits.
  secret_stat[secret[i]-'0']++;
  }
  int cow = 0;
  for(int i=0; i<guess.size(); i++) {
  //deal with duplication - decrease the digits count if cow is found.
  if ( secret[i] != guess[i] && secret_stat[guess[i]-'0']-- > 0 ) {
  cow++;
  }
  }
  return to_string(bull) + ""A"" + to_string(cow) + ""B"";
  }
 };"
46,46,"class Solution {
 public:
  int maxCoins(vector<int>& nums) {
  //remove all of zero item
  nums.erase(remove_if(nums.begin(), nums.end(), [](int n){return n==0;}), nums.end());
  //add 1 for head and tail
  nums.insert(nums.begin(),1);
  nums.push_back(1);
  int n = nums.size();
  vector< vector<int> > matrix(n, vector<int>(n,0));
  return maxCoins_DP(nums, matrix);
  return maxCoins_DC(nums, matrix, 0, n-1);
  }
  //Divide and Conquer
  //
  // If we seprate the array to two part, left part and right part.
  //
  // Then, we will find in this problem the left and right become adjacent 
  // and have effects on the maxCoins in the future.
  //
  // So, if we think reversely, if the balloon i is the last balloon of all to burst, 
  // the left and right section now has well defined boundary and do not affect each other! 
  // Therefore we can do either recursive method with memoization
  //
  int maxCoins_DC(vector<int>& nums, vector<vector<int>>& matrix, int low, int high) {
  if (low + 1 == high) return 0;
  if (matrix[low][high] > 0) return matrix[low][high];
  int result = 0;
  for (int i = low + 1; i < high; ++i){
  result = max(result, nums[low] * nums[i] * nums[high] 
  + maxCoins_DC(nums, matrix, low, i) 
  + maxCoins_DC(nums, matrix, i, high));
  }
  matrix[low][high] = result;
  return result;
  }
  //Dynamic Programming
  // 
  // using the same idea of above 
  //
  int maxCoins_DP(vector<int>& nums, vector<vector<int>>& dp) {
  int n = nums.size();
  for (int k = 2; k < n; ++k) {
  for (int low = 0; low < n - k; low++){
  int high = low + k;
  for (int i = low + 1; i < high; ++i)
  dp[low][high] = max( dp[low][high],
  nums[low] * nums[i] * nums[high] + dp[low][i] + dp[i][high]);
  }
  }
  return dp[0][n - 1];
  }
 private:
  void printVector(vector<int>& nums) {
  cout << ""nums: "";
  for (auto n: nums) {
  cout << n << ' ';
  }
  cout << '\n';
  }
 };"
47,47,"class Solution {
 public:
  int totalMoney(int n) {
  int weeks = n / 7;
  int days = n % 7;
  int m = 1 + 2 + 3 + 4 + 5 + 6 + 7;
  // we know
  // week1 = 0*7 + m
  // week2 = 1*7 + m 
  // week3 = 2*7 + m 
  // weekn = (n-1)*7 + m
  // So, 
  // week1 + week2 + week3 + ....+ weekn 
  // = n*m + 7*(0+1+2+..n-1)
  // = n*m + 7*(n-1)*n/2
  int money = weeks*m + 7 * (weeks-1) * weeks / 2;
  // for the rest days
  // every day needs to add previous `weeks * 1`, it is days* weeks
  // then add from 1 to days
  money += (days*weeks + days*(days+1)/2);
  return money;
  }
 };"
48,48,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 void print(vector<int> &v);
 /*
  * The soluiton is O(2n) run-time complexity
  *
  * For example:
  *
  * ratings[] = { 5, 6, 7, 4, 1, 2, 3, 2, 1, 7 } 
  *
  * 1) Go through the ratings from left to right.
  *
  * Find the each increasing sub-array, giving the minimal candy 
  *
  * ratings[] = { 5, 6, 7, 4, 1, 2, 3, 2, 1, 7 } 
  * ------> -> ------> -> --->
  * candy[] = { 1, 2, 3, 1, 1, 2, 3, 1, 1, 2 }
  *
  * 2) Go through the raings from right to left.
  *
  * ratings[] = { 5, 6, 7, 4, 1, 2, 3, 2, 1, 7 } 
  * <- <- <------ <- <------ <-
  * prev_candy[] = { 1, 2, 3, 1, 1, 2, 3, 1, 1, 2 }
  * +1 +1
  * candy[] = { 1, 2, 3, 2, 1, 2, 3, 2, 1, 2 }
  *
  * 3) total candy is 19
  *
  */
 int candy(vector<int> &ratings) {
  vector<int> candyCnt(ratings.size()) ;
  //allocate candies, considering the minimal rating on the left
  candyCnt[0] = 1;
  for(int i = 1; i < ratings.size(); i++){
  candyCnt[i] = ratings[i] > ratings[i-1] ? candyCnt[i-1]+1 : 1;
  }
  print(candyCnt); 
  //modify the allocation, considering the minimal rating on the right
  int totalCandy = candyCnt[ratings.size()-1];
  for(int i = ratings.size()-2; i >= 0; i--){
  candyCnt[i] = (ratings[i] > ratings[i+1] && candyCnt[i+1]+1 > candyCnt[i]) ? candyCnt[i+1]+1 : candyCnt[i];
  //count total candies by the way
  totalCandy += candyCnt[i];
  }
  print(candyCnt);
  return totalCandy;
 }
 void generateRatings(vector<int> &ratings, int n) {
  srand(time(0));
  for (int i=0; i<n; i++) {
  ratings.push_back(rand()%10);
  }
 }
 void print(vector<int> &v) {
  for(int i=0; i<v.size(); i++){
  cout << v[i] << "" "";
  }
  cout << endl;
 }
 int main(int argc, char**argv)
 {
  int n = 10;
  if (argc>1){
  n = atoi(argv[1]);
  } 
  vector<int> ratings;
  generateRatings(ratings, n);
  print(ratings);
  cout << candy(ratings) << endl;
  cout << ""--------------------"" << endl;
  int r[] = { 5, 6, 7, 4, 1, 2, 3, 2, 1, 7 };
  vector<int> ra(r, r+sizeof(r)/sizeof(r[0]));
  print(ra);
  cout << candy(ra) << endl;
  return 0;
 }"
49,49,"class Solution {
 public:
  bool check(vector<int>& nums) {
  int len = nums.size();
  //deal with the rotated case - the first element is greater than last one
  bool rotate = (nums[0] >= nums[len-1]);
  for (int i = 0; i < len-1; i++) {
  if ( nums[i] <= nums[i+1] ) continue;
  if (rotate) {
  rotate = false;
  continue;
  }
  return false;
  }
  return true;
  }
 };"
50,50,"class Solution {
 public:
  bool checkOnesSegment(string s) {
  int i=0;
  while(i<s.size() && s[i]=='1') i++; 
  while(i<s.size() && s[i]=='0') i++;
  if(i<s.size() && s[i]=='1') return false;
  return true;
  }
 };"
51,51,"class Solution {
 public:
  bool checkPowersOfThree(int n) {
  return checkPowersOfThree_Base3(n);
  return checkPowersOfThree_DFS(n, 1);
  }
  bool checkPowersOfThree_DFS(int n, int p) { 
  if (n == p ) return true;
  if (n < p ) return false;
  return (checkPowersOfThree_DFS(n-p, p*3) || checkPowersOfThree_DFS(n, p*3));
  }
  /*
  * convert base-10 number to base-3 number
  * for example: 
  * 12 -> 110 = 1*3^2 + 1*3^1 + 0*3^0
  * 16 -> 121 = 1*3^2 + 2*3^1 + 1*3^0
  * 21 -> 210 = 2*3^2 + 1*3^1 + 0*3^0
  * 
  * 91 -> 1011 = 1*3^4 + 0*3^2 + 1*3^1 + 1*3^0
  * 
  * so, we can see, if a base3 number only has 1 or 0, then it's valid.
  * if `2` appeas, then it's invalid.
  */
  bool checkPowersOfThree_Base3(int n) { 
  for (; n>0; n/=3) {
  if (n%3 == 2) return false;
  }
  return true;
  }
 };"
52,52,"class Solution {
 public:
  bool areAlmostEqual(string s1, string s2) {
  int p[2]={0};
  int diff=0;
  for(int i=0; i<s1.size(); i++){
  if (s1[i] ==s2[i]) continue;
  if (diff < 2) p[diff] = i;
  diff++;
  }
  return (diff==0) || ( (diff == 2) && s1[p[0]] == s2[p[1]] && s1[p[1]] == s2[p[0]]);
  }
 };"
53,53,"class Solution {
 public:
  bool checkIfPangram(string sentence) {
  bool stat[26] = {false};
  for(auto& c: sentence) {
  stat[c - 'a'] = true;
  }
  for(auto& s : stat) {
  if (!s) return false;
  }
  return true;
  }
 };"
54,54,"class Solution {
 public:
  int strToInt(string& str) {
  int n = 0;
  for(auto& c :str) {
  n = n*10 + c - 'a';
  }
  return n;
  }
  bool isSumEqual(string firstWord, string secondWord, string targetWord) {
  return strToInt(firstWord) + strToInt(secondWord) == strToInt(targetWord);
  }
 };"
55,55,"class Solution {
 public:
  int climbStairs(int n) {
  if (n<=3) return n;
  int a[2]={2,3};
  for(int i=4; i<=n; i++){
  int t = a[0] + a[1];
  a[0] = a[1];
  a[1] = t;
  }
  return a[1];
  }
  //Time too long
  int climbStairs2(int n) {
  if (n<=3) return n;
  return climbStairs(n-1) + climbStairs(n-2);
  }
 };"
56,56,"/**
  * Definition for undirected graph.
  * struct UndirectedGraphNode {
  * int label;
  * vector<UndirectedGraphNode *> neighbors;
  * UndirectedGraphNode(int x) : label(x) {};
  * };
  */
 class Solution {
 public:
  UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
  if (node == NULL) return NULL;
  //create a map, key is source node, value is clone node.
  map<UndirectedGraphNode*, UndirectedGraphNode*> cloneMap;
  //using queue for breadth first search
  queue<UndirectedGraphNode*> q;
  q.push(node);
  //clone the root
  UndirectedGraphNode* cloneNode = new UndirectedGraphNode(node->label);
  cloneMap[node] = cloneNode;
  //breadth first search
  while(!q.empty()){
  UndirectedGraphNode* n = q.front();
  q.pop();
  //for each neighbors
  for(int i=0; i<n->neighbors.size(); i++){
  UndirectedGraphNode* neighbor= n->neighbors[i];
  //not existed in cloneMap
  if (cloneMap.find(neighbor)==cloneMap.end()){
  //clone a node
  UndirectedGraphNode* newNode = new UndirectedGraphNode(neighbor->label);
  cloneMap[n]->neighbors.push_back(newNode);
  cloneMap[neighbor] = newNode;
  //put the neighbors into the queue
  q.push(neighbor);
  }else{
  cloneMap[n]->neighbors.push_back(cloneMap[neighbor]);
  }
  }
  }
  return cloneNode;
  }
 };"
57,57,"class Solution {
 private:
  int abs_min (int x, int y, int z) {
  return abs_min(x, abs_min(y, z));
  }
  // compare the absolute value and return the min one
  // if their absolute value are equal, return the positive one.
  int abs_min(int x, int y) {
  int ax = abs(x);
  int ay = abs(y);
  if (ax == ay) return max(x, y);
  return ax < ay ? x : y;
  }
 public:
  int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {
  int min_gap = INT_MAX;
  for (auto& base : baseCosts) {
  int gap = closetToppingCost(toppingCosts, target - base, 0);
  min_gap = abs_min(min_gap, gap);
  }
  return target - min_gap;
  }
  int closetToppingCost(vector<int>& costs, int target, int idx ){
  if (idx >= costs.size()) return target;
  // three options: not slect, select once & select twice
  int select_none = closetToppingCost(costs, target, idx+1);
  int select_once = closetToppingCost(costs, target - costs[idx], idx+1);
  int select_twice = closetToppingCost(costs, target - 2*costs[idx], idx+1);
  return abs_min(select_none, select_once, select_twice);
  }
 };"
58,58,"class Solution {
 private:
  void print(vector<vector<int>>& vv) {
  cout << ""["";
  int i = 0;
  for(; i<vv.size()-1; i++) {
  cout << ""["" << vv[i][0] << "","" << vv[i][1] << ""],"";
  }
  cout << ""["" << vv[i][0] << "","" << vv[i][1] << ""]]"" << endl;
  }
 public:
  vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {
  for(int i=0; i<queries.size(); i++) { 
  queries[i].push_back(i);
  }
  // sorted the rooms by size by descending order, because query the minimal size.
  auto sort_by_size_desc = [&](vector<int>& lhs, vector<int>&rhs) {
  if (lhs[1] != rhs[1] ) return lhs[1] > rhs[1];
  return lhs[0] < rhs[0];
  };
  sort(rooms.begin(), rooms.end(), sort_by_size_desc);
  sort(queries.begin(), queries.end(), sort_by_size_desc);
  //print(rooms);
  //print(queries);
  vector<int> result(queries.size(), -1);
  set<int> ids;
  int i = 0;
  for( auto& q: queries) {
  int preferId = q[0];
  int minSize = q[1];
  int idx = q[2];
  for (;i < rooms.size() && rooms[i][1] >= minSize; i++) {
  ids.insert(rooms[i][0]);
  }
  if (ids.size() <= 0 ) continue;
  auto it = ids.lower_bound(preferId); 
  int id1 = (it == ids.begin() ? -1 : *(prev(it)));
  int id2 = (it == ids.end() ? -1 : *it);
  if (id1 == -1 || id2 == -1) {
  result[idx] = max(id1, id2);
  }else{
  result[idx] = abs(preferId - id1) <= abs(preferId - id2) ? id1 : id2;
  }
  }
  return result;
  }
 };"
59,59,"class Solution {
 private: 
  int abs(int n){
  return n>0 ? n : -n;
  }
  void printSet(set<int>& s){
  cout << ""["";
  for(auto& n : s) {
  cout << n << "", "";
  }
  cout << ""]"" << endl;
  }
  int findClosetDiff(set<int>& sums, int goal) {
  auto it = sums.lower_bound(goal);
  // find the first item >= goal
  int high = (it == sums.end()) ? *(sums.rbegin()) : *it;
  // find the first item < goal
  int low = (it != sums.begin()) ? *(--it) : *it; 
  return min(abs(low - goal), abs(high - goal));
  }
  // walk through all of element, and each element could have two chioces:
  // add itself into sum or not. So, the time complexity is O(2^n)
  void getAllSums(int index, int end, vector<int>& nums, int sum, set<int>& sums) {
  if (index > end ) { // the latest one
  sums.insert(sum);
  return;
  }
  getAllSums(index+1, end, nums, sum+nums[index], sums); // add it into sum
  getAllSums(index+1, end, nums, sum, sums); // skip this item
  }
  void getAllSums(int start, int end, vector<int>& nums, set<int>& sums) {
  //sums.clear(); 
  sums.insert(0);
  for (int i=start; i<=end; i++) {
  vector<int> s(sums.begin(), sums.end());
  for (auto n : s) {
  sums.insert(n + nums[i]);
  }
  }
  }
 public:
  int minAbsDifference(vector<int>& nums, int goal) {
  set<int> sums_left, sums_right;
  //seprate the arrage to two parts
  int mid = nums.size() / 2;
  // ---The recusive way cause the TLE problem---
  //getAllSums(0, mid, nums, 0, sums_left);
  //getAllSums(mid+1, nums.size()-1, nums, 0, sums_right);
  getAllSums(0, mid, nums, sums_left);
  getAllSums(mid+1, nums.size()-1, nums, sums_right);
  int minDiff = INT_MAX;
  for (auto& sum : sums_left) {
  // Two Sum problem:
  // - sum_left + sum_right = goal
  // - sum_right = goal = sum_left
  minDiff = min(minDiff, findClosetDiff(sums_right, goal - sum));
  }
  return minDiff;
  }
 };"
60,60,"/* Recursive solution - TIME LIMIT ERROR */
 class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) { 
  int result = INT_MAX;
  if ( amount == 0 ) return 0;
  if ( amount < 0 ) return -1;
  for (int i=0; i<coins.size(); i++) {
  if ( amount - coins[i] < 0 ) continue;
  int r = coinChange(coins, amount - coins[i]);
  if ( r == -1 ) continue;
  if (result > r ) result = r + 1;
  }
  return result == INT_MAX ? -1 : result;
  }
 }
  /* 
  * Solution 1 - O(N * amount)
  * =========
  *
  * This problem can be solved using dynamic programming, thus building the optimal
  * solution from previous smaller ones. For every coin of value t and every sum of money
  * i the sum can be traced back to a previous sum i - t that was already computed and uses
  * the smallest number of coins possible. This way we can construct every sum i as the
  * minimum of all these previous sums for every coin value. To be sure we'll find a minimum
  * we can populate the solution vector with an amount bigger than the maximum possible, 
  * which is amount + 1(when the sum is made up of only coins of value 1). The only exception
  * is sol[0] which is 0 as we need 0 coins to have a sum of 0. In the end we need to look
  * if the program found a solution in sol[amount] or it remained the same, in which case we
  * can return -1.
  * 
  */
 class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
  int sol[amount + 1];
  sol[0] = 0;
  for(int i = 1; i <= amount; i++)
  sol[i] = amount + 1;
  for(int i = 0; i < coins.size(); i++)
  {
  for(int j = coins[i]; j <= amount; j++)
  sol[j] = min(sol[j], sol[j - coins[i]] + 1);
  }
  if(sol[amount] != amount + 1)
  return sol[amount];
  else
  return -1;
  }
 };
 //Another DP implmentation, same idea above 
 class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
  const int MAX = amount +1;
  vector<int> dp(amount+1, MAX);
  dp[0]=0;
  for(int i=1; i<=amount; i++) {
  for (int j=0; j<coins.size(); j++){
  if (i >= coins[j]) {
  dp[i] = min( dp[i], dp[i-coins[j]] + 1 );
  }
  }
  }
  return dp[amount]==MAX ? -1 : dp[amount];
  }
 };"
61,61,"class Solution {
 public:
  int change(int amount, vector<int>& coins) {
  return change_dp(amount, coins);
  return change_recursive(amount, coins); // Time Limit Error
  }
  int change_recursive(int amount, vector<int>& coins) {
  int result = 0;
  change_recursive_helper(amount, coins, 0, result);
  return result;
  }
  // the `idx` is used for remove the duplicated solutions.
  void change_recursive_helper(int amount, vector<int>& coins, int idx, int& result) {
  if (amount == 0) { 
  result++; 
  return;
  }
  for ( int i = idx; i < coins.size(); i++ ) {
  if (amount < coins[i]) continue;
  change_recursive_helper(amount - coins[i], coins, i, result);
  }
  return;
  }
  int change_dp(int amount, vector<int>& coins) {
  vector<int> dp(amount+1, 0);
  dp[0] = 1;
  for (int i=0; i<coins.size(); i++) {
  for(int n=1; n<=amount; n++) {
  if (n >= coins[i]) {
  dp[n] += dp[n-coins[i]];
  }
  }
  }
  return dp[amount];
  }
 };"
62,62,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void getCombination(int n, int k, vector<int>& solution, vector< vector<int> >& result );
 vector<vector<int> > combine1(int n, int k); 
 vector<vector<int> > combine2(int n, int k);
 vector<vector<int> > combine(int n, int k) {
  if (random()%2){
  cout << ""recusive method!"" << endl;
  return combine1(n, k);
  }
  cout << ""non-recusive method!"" << endl;
  return combine2(n, k);
 }
 vector<vector<int> > combine1(int n, int k) {
  vector<vector<int> > result;
  vector<int> solution;
  getCombination(n, k, solution, result);
  return result;
 }
 void getCombination(int n, int k, vector<int>& solution, vector< vector<int> >& result ){
  if (k==0){
  //sort to meet LeetCode requirement
  vector<int> v = solution;
  sort(v.begin(), v.end());
  result.push_back(v);
  return;
  }
  for(int i=n; i>0; i--){
  solution.push_back(i);
  getCombination(i-1, k-1, solution, result);
  solution.pop_back();
  }
 }
 vector<vector<int> > combine2(int n, int k) {
  vector<vector<int> > result;
  vector<int> d;
  for (int i=0; i<n; i++){
  d.push_back( (i<k) ? 1 : 0 );
  }
  //1) from the left, find the [1,0] pattern, change it to [0,1]
  //2) move all of the 1 before the pattern to the most left side
  //3) check all of 1 move to the right
  while(1){
  vector<int> v;
  for(int x=0; x<n; x++){
  if (d[x]) v.push_back(x+1);
  }
  result.push_back(v);
  //step 1), find [1,0] pattern
  int i;
  bool found = false;
  int ones =0;
  for(i=0; i<n-1; i++){
  if (d[i]==1 && d[i+1]==0){
  d[i]=0; d[i+1]=1;
  found = true;
  //step 2) move all of right 1 to the most left side
  for (int j=0; j<i; j++){
  d[j]=( ones > 0 ) ? 1 : 0;
  ones--;
  }
  break; 
  } 
  if (d[i]==1) ones++;
  }
  if (!found){
  break;
  }
  }
  return result;
 }
 void printResult(vector<vector<int> >& result)
 {
  for(int i=0; i<result.size(); i++){
  cout << ""{"";
  for(int j=0; j<result[i].size(); j++){
  cout << "" "" << result[i][j];
  }
  cout << "" }"" <<endl;
  }
 }
 int main(int argc, char** argv)
 {
  srand(time(NULL));
  int n = 4, k =2;
  if (argc>2){
  n = atoi(argv[1]);
  k = atoi(argv[2]);
  }
  vector<vector<int> > r = combine(n, k);
  printResult(r);
 }"
63,63,"#include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void combinationSumHelper(vector<int> &candidates, int start, int target, vector<int> &solution, vector< vector<int> > &result) {
  if (target<0){
  return;
  }
  if (target==0){
  result.push_back(solution);
  return;
  }
  for(int i=start; i<candidates.size(); i++){
  //skip duplicates
  if (i>start && candidates[i] == candidates[i-1]) {
  continue;
  }
  solution.push_back(candidates[i]);
  combinationSumHelper(candidates, i, target - candidates[i], solution, result);
  solution.pop_back();
  }
 }
 vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
  vector< vector<int> > result;
  if (candidates.size()<=0){
  return result;
  }
  sort(candidates.begin(), candidates.end());
  vector<int> solution;
  combinationSumHelper(candidates, 0, target, solution, result);
  return result;
 }
 void printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  cout << ""["";
  for(int j=0; j<vv[i].size(); j++) {
  cout << "" "" << vv[i][j];
  }
  cout << ""]"" << endl;;
  }
 }
 void printArray(vector<int> &v)
 {
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << ""}"" << endl;
 }
 int main(int argc, char** argv)
 {
  int a[] = {4,2,3,3,5,7};
  vector<int> v(a, a+sizeof(a)/sizeof(int));
  int target = 7;
  cout << ""array = "";
  printArray(v);
  cout << ""target = "" << target << endl;
  vector< vector<int> > vv = combinationSum(v, target);
  printMatrix(vv);
  return 0;
 }"
64,64,"#include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void combinationSumHelper(vector<int> &candidates, int start, int target, vector<int> &solution, vector< vector<int> > &result) {
  if (target<0){
  return;
  }
  if (target==0){
  result.push_back(solution);
  return;
  }
  for(int i=start; i<candidates.size(); i++){
  //skip duplicates
  int n = candidates[i];
  if (i>start && candidates[i] == candidates[i-1]) {
  continue;
  }
  solution.push_back(n);
  combinationSumHelper(candidates, i+1, target - n, solution, result);
  solution.pop_back();
  }
 }
 vector<vector<int> > combinationSum2(vector<int> &candidates, int target) {
  vector< vector<int> > result;
  if (candidates.size()<=0){
  return result;
  }
  sort(candidates.begin(), candidates.end());
  vector<int> solution;
  combinationSumHelper(candidates, 0, target, solution, result);
  return result;
 }
 void printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  cout << ""["";
  for(int j=0; j<vv[i].size(); j++) {
  cout << "" "" << vv[i][j];
  }
  cout << ""]"" << endl;;
  }
 }
 void printArray(vector<int> &v)
 {
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << ""}"" << endl;
 }
 void test(int a[], int len, int target)
 {
  vector<int> v(a, a+len);
  cout << ""array = "";
  printArray(v);
  cout << ""target = "" << target << endl;
  vector< vector<int> > vv = combinationSum2(v, target);
  printMatrix(vv);
 }
 int main(int argc, char** argv)
 {
  #define TEST(a, t) test(a, sizeof(a)/sizeof(int), target)
  int a[] = {4,2,3,3,5,7};
  int target = 7;
  TEST(a, target);
  int b[] = {10,1,2,7,6,1,5};
  target = 8;
  TEST(b, target);
  int c[] = {2,2,2};
  target = 2;
  TEST(c, target);
  return 0;
 }"
65,65,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 void combinationSumHelper(vector<int>& candidates, int start, int num, int target, 
  vector<int>& solution, vector< vector<int> >& results) {
  if (target < 0|| solution.size() > num){
  return;
  }
  if (target == 0 && solution.size()==num){
  results.push_back(solution);
  return;
  }
  for (int i=start; i<candidates.size(); i++){
  solution.push_back(candidates[i]);
  combinationSumHelper(candidates, i+1, num, target-candidates[i], solution, results);
  solution.pop_back();
  }
 }
 vector< vector<int> > combinationSum3(int k, int n) {
  vector<int> v;
  for (int i=1; i<=9; i++){
  v.push_back(i);
  }
  vector< vector<int> > result;
  vector<int> solution;
  combinationSumHelper(v, 0, k, n, solution, result); 
  return result;
 }
 void PrintResults(int k, int n, vector< vector<int> >& results) {
  cout << ""k="" << k << "", n="" << n << ""\t"";
  for (int i=0; i<results.size(); i++){
  cout << ""["";
  for (int j=0; j<results[i].size(); j++){
  cout << results[i][j] << (j!=results[i].size()-1 ? "","":""]"") ;
  }
  cout << ( i!=results.size()-1 ? "", "" : """" );
  } 
  cout << endl;
 }
 int main(int argc, char** argv) 
 {
  int k = 3, n =9;
  if (argc > 2){
  k = atoi(argv[1]);
  n = atoi(argv[2]);
  } 
  vector< vector<int> > results;
  results = combinationSum3(k, n);
  PrintResults(k,n, results);
  return 0;
 }"
66,66,"/* Solution
  * --------
  * 1) Dynamic Programming - O(N * target)
  *
  * We notice that any sum S can be written as S_prev + nums[i], where S_prev is a sum of
  * elements from nums and nums[i] is one element of the array. S_prev is always smaller 
  * than S so we can create the array sol, where sol[i] is the number of ways one can 
  * arrange the elements of the array to obtain sum i, and populate it from 1 to target,
  * as the solution for i is made up of previously computed ones for numbers smaller than
  * i. The final answer is sol[target], which is returned at the end.
  *
  * Follow up:
  * 
  * If the array contains negative numbers as well as positive ones we can run into a cycle
  * where some subset of the elements have sum 0 so they can always be added to an existing
  * sum, leading to an infinite number of solutions. The limitation that we need is a rule
  * to be followed by the input data, that which doesn't allow this type of subsets to exist.
  */
 class Solution {
 public:
  int combinationSum4(vector<int>& nums, int target) {
  int sol[target + 1];
  sol[0] = 1;//starting point, only 1 way to obtain 0, that is to have 0 elements
  for(int i = 1; i <= target; i++)
  {
  sol[i] = 0;
  for(int j = 0; j < nums.size(); j++)
  {
  if(i >= nums[j])//if there is a previously calculated sum to add nums[j] to
  sol[i] += sol[i - nums[j]];
  }
  }
  return sol[target];
  }
 };"
67,67,"class Solution {
 public:
  vector<int> numSmallerByFrequency(vector<string>& queries, vector<string>& words) {
  cout << queries.size() << "" : "" << words.size() << endl;
  vector<int> freq;
  for (auto w : words) {
  freq.push_back(f(w));
  }
  sort(freq.begin(), freq.end());
  vector<int> result;
  for (auto q : queries) {
  result.push_back(binary_search(freq, f(q)));
  }
  return result;
  }
  int f(string& s) {
  char ch = 'z' + 1; //stroe the smallest char
  int cnt = 0; //stroe the frequency of the smallest char
  for (auto c : s) {
  if (c < ch) { //find the smaller char, reset the count
  cnt = 1;
  ch = c;
  } if (c == ch) {
  cnt++;
  }
  }
  return cnt;
  }
  int binary_search(vector<int> &v, int target) {
  int low=0, high=v.size()-1, mid;
  while (low < high) {
  mid = low + (high - low) / 2;
  if ( v[mid] > target) {
  high = mid -1;
  } else if (v[mid] <= target) {
  low = mid + 1;
  }
  }
  low = v[low] > target ? low : low + 1;
  return v.size() - low;
  }
 };"
68,68,"class Solution {
  public:
  vector<int> &split(const string &s, char delim, vector<int> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
  elems.push_back(atoi(item.c_str()));
  }
  return elems;
  }
  vector<int> split(const string &s, char delim) {
  vector<int> elems;
  split(s, delim, elems);
  return elems;
  }
  void rightTrimZero(vector<int> &v){
  while (v.back() == 0){
  v.pop_back();
  }
  }
  int compareVersion(string version1, string version2) {
  //split the version by delimer '.'
  vector<int> ver1 = split(version1, '.');
  vector<int> ver2 = split(version2, '.');
  //remove the right Zeros
  rightTrimZero(ver1);
  rightTrimZero(ver2);
  //compare two versions 
  for (int i=0; i<ver1.size() && i < ver2.size(); i++) {
  if (ver1[i] < ver2[i]){
  return -1;
  }else if(ver1[i] > ver2[i]){
  return 1;
  }
  }
  //if the above for-loop is not returned, which means they are equal so far
  //then check the length.
  if (ver1.size() > ver2.size()) {
  return 1;
  }else if (ver1.size() < ver2.size()) {
  return -1;
  }
  return 0;
  }
 };"
69,69,"#include <stdio.h>
 #include <vector>
 #include <queue>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 TreeNode *buildTree(vector<int> &inorder, int in_offset, vector<int> &postorder, int post_offset, int n );
 TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
  return buildTree(inorder, 0, postorder, 0, postorder.size());
 }
 // n - how many number, offset - start from where?
 TreeNode *buildTree(vector<int> &inorder, int in_offset, vector<int> &postorder, int post_offset, int n ) {
  if ( n<=0 || postorder.size()<=0 || inorder.size()<=0 ) return NULL;
  TreeNode *root = new TreeNode(postorder[post_offset+n-1]);
  if ( n==1 ){
  return root;
  }
  //searching in inorder -- can be optimized by using <map>
  int i;
  for(i=in_offset; i<in_offset+n; i++){
  if (inorder[i] == postorder[post_offset+n-1]){
  break;
  }
  }
  //error: not found
  if (i == inorder.size()) return NULL;
  int left_n = i - in_offset;
  int right_n = in_offset + n - i - 1;
  root->left = buildTree(inorder, in_offset, postorder, post_offset, left_n );
  root->right = buildTree(inorder, i+1, postorder, post_offset+left_n, right_n);
  return root;
 }
 //cause the problem: memory limited error
 TreeNode *buildTree2(vector<int> &inorder, vector<int> &postorder) {
  if (postorder.size()<=0 || inorder.size()<=0 ) return NULL;
  int post_n = postorder.size();
  TreeNode *root = new TreeNode(postorder[post_n-1]);
  if ( inorder.size()==1 && postorder.size()==1 ){
  return root;
  }
  //searching in inorder -- can be optimized by using <map>
  int i;
  for(i=0; i<inorder.size(); i++){
  if (inorder[i] == postorder[post_n-1]){
  break;
  }
  }
  //error: not found
  if (i == inorder.size()) return NULL;
  vector<int> in(inorder.begin(), inorder.begin()+i);
  vector<int> post(postorder.begin(), postorder.begin()+i);
  if (in.size()>0) {
  root->left = buildTree(in, post);
  }
  in.clear();
  in.assign(inorder.begin()+i+1, inorder.end());
  post.clear();
  post.assign(postorder.begin()+i, postorder.end()-1);
  if (in.size()>0) {
  root->right = buildTree(in, post);
  }
  return root;
 }
 void printTree_pre_order(TreeNode *root)
 {
  if (root == NULL){
  printf(""# "");
  return;
  }
  printf(""%c "", root->val );
  printTree_pre_order(root->left);
  printTree_pre_order(root->right);
 }
 void printTree_in_order(TreeNode *root)
 {
  if (root == NULL){
  printf(""# "");
  return;
  }
  printTree_in_order(root->left);
  printf(""%c "", root->val );
  printTree_in_order(root->right);
 }
 void printTree_level_order(TreeNode *root)
 {
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0){
  TreeNode* n = q.front();
  q.pop();
  if (n==NULL){
  printf(""# "");
  continue;
  }
  printf(""%c "", n->val);
  q.push(n->left);
  q.push(n->right);
  }
  printf(""\n"");
 }
 int main()
 {
  int in_order[]={'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};
  int post_order[]={'A', 'C', 'E', 'D', 'B', 'H', 'I', 'G', 'F'};
  vector<int> inorder( in_order, in_order + 9 );
  vector<int> postorder( post_order, post_order + 9 );
  TreeNode* tree = buildTree(inorder, postorder);
  printTree_level_order(tree);
  printTree_pre_order(tree);
  printf(""\n"");
  printTree_in_order(tree);
  printf(""\n"");
  return 0;
 }"
70,70,"#include <stdio.h>
 #include <vector>
 #include <queue>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 TreeNode *buildTree(vector<int>& preorder, int& preidx, vector<int>& inorder);
 TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
  int preidx=0;
  return buildTree(preorder, preidx, inorder);
 }
 TreeNode *buildTree(vector<int>& preorder, int& preidx, vector<int>& inorder) {
  if (preorder.size()<=0 || inorder.size()<=0 ) return NULL;
  TreeNode *root = new TreeNode(preorder[preidx]);
  if (inorder.size()==1){
  return root;
  }
  int i;
  for(i=0; i<inorder.size(); i++){
  if (inorder[i] == preorder[preidx]){
  break;
  }
  }
  //error: not found
  if (i == inorder.size()) return NULL;
  if (preidx+1 >= preorder.size()){
  return root;
  }
  vector<int> v(inorder.begin(), inorder.begin()+i);
  if (v.size()>0) {
  preidx++;
  root->left = buildTree(preorder, preidx, v);
  }
  v.clear();
  v.assign(inorder.begin()+i+1, inorder.end());
  if (v.size()>0) {
  preidx++;
  root->right = buildTree(preorder, preidx, v);
  }
  return root;
 }
 void printTree_pre_order(TreeNode *root)
 {
  if (root == NULL){
  printf(""# "");
  return;
  }
  printf(""%c "", root->val );
  printTree_pre_order(root->left);
  printTree_pre_order(root->right);
 }
 void printTree_in_order(TreeNode *root)
 {
  if (root == NULL){
  printf(""# "");
  return;
  }
  printTree_in_order(root->left);
  printf(""%c "", root->val );
  printTree_in_order(root->right);
 }
 void printTree_level_order(TreeNode *root)
 {
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0){
  TreeNode* n = q.front();
  q.pop();
  if (n==NULL){
  printf(""# "");
  continue;
  }
  printf(""%c "", n->val);
  q.push(n->left);
  q.push(n->right);
  }
  printf(""\n"");
 }
 int main()
 {
  int pre_order[]={'F', 'B', 'A', 'D', 'C', 'E', 'G', 'I', 'H'};
  int in_order[]={'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'};
  vector<int> preorder( pre_order, pre_order + 9 );
  vector<int> inorder( in_order, in_order + 9 );
  TreeNode* tree = buildTree(preorder, inorder);
  printTree_level_order(tree);
  printTree_pre_order(tree);
  printf(""\n"");
  printTree_in_order(tree);
  printf(""\n"");
  return 0;
 }"
71,71,"class Solution {
 private:
  void print(vector<int>& v) {
  cout << ""["" ;
  for(int i=0; i<v.size()-1; i++){
  cout << v[i] << "","";
  }
  cout << v[v.size()-1] << ""]"" << endl;
  }
 public:
  vector<int> constructDistancedSequence(int n) {
  vector<int> result(2*n-1, 0);
  vector<bool> available(n+1, true); // an array remember which num hasn't been chosen.
  available[0] = false;
  dfs(available, result, 0, n);
  return result;
  }
  bool dfs(vector<bool>& available, vector<int>& result, int pos, int cnt){
  //the `cnt` means how many number has been processed.
  if (cnt == 0) return true;
  //start from the bigger number.
  int n = 0;
  for(int i = available.size()-1; i > 0; i--){
  // if the number has already been chosen, skip to next one.
  if (!available[i]) continue;
  //if the number cannot be put into the array, skip to next one
  if ( i > 1 && pos + i >= result.size()) continue;
  if ( i > 1 && (result[pos] != 0 || result[pos+i] != 0)) continue;
  // choose the current number `i`
  available[i] = false;
  result[pos] = i;
  if (i > 1) result[pos+i] = i;
  int next_pos = pos;
  while( next_pos < result.size() && result[next_pos]!=0) next_pos++;
  //print(result);
  if (dfs(available, result, next_pos, cnt-1)) return true; 
  // if failed to find the answer. roll back.
  available[i] = true;
  result[pos] = 0;
  if (i > 1) result[pos+i] = 0;
  }
  return false;
  }
 };"
72,72,"class Solution {
 public:
  int maxArea(vector<int> &height) {
  int maxArea = 0;
  // two pointers scan from two sides to middle
  int left = 0; 
  int right = height.size()-1;
  int area; 
  while ( left < right ){
  // calculate the area
  area = (right - left) * ( height[left] < height[right] ? height[left] : height[right]);
  // tracking the maxium area
  maxArea = area > maxArea ? area : maxArea;
  // because the area is decided by the shorter edge
  // so we increase the area is to increase the shorter edge
  //
  // height[left] < height[right] ? left++ : right-- ;
  //
  // However, the above code could cause the unnecessary `area` cacluation
  // We can do some improvement as below:
  if (height[left] < height[right]) {
  do {
  left++;
  } while (left < right && height[left-1] >= height[left]);
  } else {
  do {
  right--;
  } while (right > left && height[right+1] >= height[right]);
  }
  }
  return maxArea;
  }
 };"
73,73,"class Solution {
 public:
  bool containsDuplicate(vector<int>& nums) {
  unordered_map<int, bool> m;
  for (auto item : nums) {
  if (m.find(item) != m.end()) return true;
  m[item]=true;
  }
  return false;
  }
 };"
74,74,"class Solution {
 public:
  bool containsNearbyDuplicate(vector<int>& nums, int k) {
  unordered_map<int, int> m;
  for (int i=0; i<nums.size(); i++) {
  int n = nums[i];
  if (m.find(n) != m.end() && i - m[n] <= k) {
  return true;
  }
  m[n] = i;
  }
  return false;
  }
 };"
75,75,"class Solution {
 public:
  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
  if(nums.size() < 2 || k == 0) return false;
  int low = 0;
  //maintain a sliding window 
  set<long long> window;
  for (int i=0; i<nums.size(); i++){
  //make sure window size <= k
  if (i - low > k) {
  window.erase(nums[low]);
  low++;
  }
  // lower_bound() is the key, 
  // it returns an iterator pointing to the first element >= val 
  auto it = window.lower_bound((long long)nums[i] - (long long)t );
  if (it != window.end() && abs((long long)nums[i] - *it) <= (long long)t) {
  return true;
  }
  window.insert(nums[i]);
  }
  return false;
  }
 };"
76,76,"class Solution {
 public:
  string toHex(int num) {
  if (num == 0) return ""0"";
  unsigned int x = num;
  string result;
  for(;x > 0; x/=16) {
  int n = x % 16;
  char c;
  if (n < 10) c = n + '0';
  else c = 'a' + n - 10 ;
  result = c + result;
  }
  return result;
  }
 };"
77,77,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  TreeNode *sortedArrayToBST(vector<int> &num) {
  if(num.size()==0){
  return NULL;
  }
  if(num.size()==1){
  return new TreeNode(num[0]);
  }
  int mid = num.size()/2;
  TreeNode *node = new TreeNode(num[mid]);
  vector<int>::const_iterator first;
  vector<int>::const_iterator last;
  first = num.begin();
  last = num.begin()+mid;
  vector<int> v(first, last);
  node->left = sortedArrayToBST(v);
  if (mid==num.size()-1){
  node->right = NULL;
  }else{
  first = num.begin()+mid+1;
  last = num.end();
  vector<int> v(first, last);
  node->right = sortedArrayToBST(v);
  }
  return node;
  }
 };"
78,78,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <queue>
 using namespace std;
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 TreeNode* sortedListToBST(int low, int high, ListNode*& head);
 TreeNode *sortedListToBST(ListNode *head) {
  int len = 0;
  for(ListNode* p=head; p!=NULL; p=p->next){
  len++;
  }
  return sortedListToBST(0, len-1, head);
 }
 TreeNode* sortedListToBST(int low, int high, ListNode*& head) {
  if (low>high || head==NULL) return NULL;
  int mid = low + (high - low)/2;
  TreeNode* leftNode = sortedListToBST(low, mid-1, head);
  TreeNode* node = new TreeNode(head->val);
  node->left = leftNode;
  head = head->next;
  TreeNode* rightNode = sortedListToBST(mid+1, high, head);
  node->right = rightNode;
  return node;
 }
 void printTree_level_order(TreeNode *root)
 {
  queue<TreeNode*> q;
  q.push(root);
  while (q.size()>0){
  TreeNode* n = q.front();
  q.pop();
  if (n==NULL){
  cout << ""# "";
  continue;
  }
  cout << n->val << "" "";
  q.push(n->left);
  q.push(n->right);
  }
  cout << endl;
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d -> "", h->val);
  h = h->next;
  }
  printf(""NULL\n"");
 }
 int main(int argc, char** argv)
 {
  int n = 8;
  if (argc>1){
  n = atoi(argv[1]);
  }
  int *a = new int[n];
  for(int i=0; i<n; i++){
  a[i]=i+1;
  }
  ListNode* head = createList(a, n);
  printList(head);
  TreeNode* root = sortedListToBST(head); 
  printTree_level_order(root);
  delete[] a; 
  return 0;
 }"
79,79,"/**
  * Definition for singly-linked list with a random pointer.
  * struct RandomListNode {
  * int label;
  * RandomListNode *next, *random;
  * RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
  * };
  */
 /* 
  *
  * The idea as below:
  *
  * Consider we have a linked list as below:
  *
  * node1->random = node2;
  * node2->random = node1;
  * node3->random = node1;
  * 
  * +-------------+ 
  * | v 
  * +-------+ +-------+ +-------+ 
  * | node1 |----> node2 |----> node3 |--->NULL
  * +-------+ +-------+ +-------+ 
  * ^ ^ | | 
  * | +-----------+ | 
  * +--------------------------+ 
  * 
  *
  * To copy the list, 
  * 
  * 1) We insert a new node for each node's next position
  *
  * 
  * +-------------------------+ 
  * | v 
  * +--+----+ +-----+ +-------+ +-----+ +-------+ +-----+ 
  * | node1 |---> | NEW |----> node2 |---> | NEW |----> node3 |---> | NEW | ---> NULL
  * +-------+ +-----+ +---+---+ +-----+ +--+----+ +-----+ 
  * ^ ^ | | 
  * | +-----------------------+ | 
  * +--------------------------------------------------+ 
  *
  * 2) Then, we can construt the new node's random pointer:
  *
  * (node1->next) -> random = (node1->random) -> next;
  *
  * 3) After we take out all of the ""NEW"" node to finish the copy.
  * 
  */
 class Solution {
 public:
  RandomListNode *copyRandomList(RandomListNode *head) {
  RandomListNode *p = NULL, *h=NULL, *t=NULL;
  if (head == NULL){
  return NULL;
  }
  //creat a new node for each node and insert its next
  p = head;
  while ( p != NULL){
  RandomListNode *node = new RandomListNode(p->label);
  node->next = p->next;
  p->next = node;
  p = node->next;
  }
  //copy random pointer for each new node
  p = head;
  while (p != NULL){
  if (p->random != NULL){
  p->next->random = p->random->next;
  }
  p = p->next->next;
  }
  //break to two list
  p = head;
  h = t = head->next;
  while ( p != NULL ){
  p->next = p->next->next;
  if (t->next!=NULL){
  t->next = t->next->next;
  }
  p = p->next;
  t = t->next;
  }
  return h;
  }
 };
 /*
  * Considering we have a link as below:
  *
  *
  * +-------------+
  * | v
  * +-------+ +-------+ +-------+
  * | node1 |----> node2 |----> node3 |--->NULL
  * +-------+ +-------+ +-------+
  * ^ ^ | |
  * | +-----------+ |
  * +--------------------------+
  * 
  * 1) Using a map to store each node's random pointer's position
  *
  * map[node1->random] = 1;
  * map[node2->random] = 0;
  * map[node3->random] = 0;
  *
  * 2) Clone the linked list (only consider the next pointer)
  *
  * new1 --> new2 --> new3 --> NULL 
  *
  * 3) Using an array to strore the order of the cloned linked-list
  *
  * v[0] = &new1
  * v[1] = &new2
  * v[2] = &new3
  * 
  * 4) Then we can clone the random pointers.
  *
  * new->random = v [ map[node->random] ]
  *
  */ 
 class MySolution {
 public:
  RandomListNode *copyRandomList(RandomListNode *head) {
  RandomListNode *p = NULL, *h=NULL, *t=NULL;
  //using a map to store the random pointer's postion.
  map<RandomListNode*, int> m;
  //construct the map
  int pos =0;
  for ( p = head; p != NULL; p = p->next, pos++){
  m[p] = pos;
  }
  //clone the linked list (only consider the next pointer)
  //and using a vector to store each node's postion.
  vector<RandomListNode*> v;
  for (p = head; p != NULL; p = p->next){
  RandomListNode *node = new RandomListNode(p->label);
  v.push_back(node);
  if (h==NULL){
  h = t = node;
  }else{
  t->next = node;
  t = node;
  }
  }
  //p => source link head 
  //t => new link head
  //move the p and t synchronously, and 
  // t->random = vector[ map[p->random] ];
  for (t=h, p = head; t!=NULL && p!= NULL; p=p->next, t=t->next){
  if (p->random!=NULL) {
  pos = m[p->random];
  t->random = v[pos];
  }
  }
  return h;
  }
 };"
80,80,"#include <stdlib.h>
 #include <iostream>
 #include <sstream>
 #include <string>
 #include <vector>
 using namespace std;
 string vecToStr(vector<int> v) {
  stringstream ss;
  for (int i=0; i<v.size(); i++) {
  ss << v[i]; 
  }
  return ss.str();
 }
 vector<int> getNext(vector<int>& v) {
  int cnt=0;
  int val=0;
  vector<int> ret;
  for(int i=0; i<v.size(); i++){
  if (i==0){
  val = v[i];
  cnt = 1;
  continue;
  }
  if (v[i] == val){
  cnt++;
  }else{
  ret.push_back(cnt); 
  ret.push_back(val); 
  val = v[i];
  cnt = 1;
  }
  }
  if (cnt>0 && val>0){
  ret.push_back(cnt); 
  ret.push_back(val); 
  }
  return ret;
 }
 string countAndSay(int n) {
  if (n<=0) return """";
  if (n==1) return ""1"";
  string s;
  vector<int> v;
  v.push_back(1);
  for(int i=2; i<=n; i++){
  v = getNext(v);
  //s = s + "", "" +vecToStr(v);
  }
  s = vecToStr(v);
  return s;
 }
 int main(int argc, char** argv)
 {
  int n = 4;
  if (argc>1){
  n = atoi(argv[1]);
  }
  cout << countAndSay(n) << endl;
  return 0;
 }"
81,81,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  //return -1 if it is not.
  int isCompleteTree(TreeNode* root) {
  if (!root) return 0;
  int cnt = 1;
  TreeNode *left = root, *right = root;
  for(; left && right; left=left->left, right=right->right) {
  cnt *= 2;
  }
  if (left!=NULL || right!=NULL) {
  return -1;
  }
  return cnt-1;
  }
  int countNodes(TreeNode* root) {
  int cnt = isCompleteTree(root);
  if (cnt != -1) return cnt;
  int leftCnt = countNodes(root->left);
  int rightCnt = countNodes(root->right);
  return leftCnt + rightCnt + 1;
  }
 };"
82,82,"class Solution {
 public:
  int countPairs(vector<int>& deliciousness) {
  const int MAX_EXP = 22;
  int pow2[MAX_EXP];
  for (int i=0; i<MAX_EXP; i++){
  pow2[i] = 1 << i;
  //cout << pow2[i] << "", "";
  }
  unordered_map<int, int> stat;
  int big = 0;
  for(auto& d: deliciousness){
  stat[d]++;
  }
  long m = 0;
  for(auto& d: deliciousness){
  for(int i=MAX_EXP-1; i>=0 && pow2[i] >= d; i--){
  int x = pow2[i] - d;
  if ( stat.find(x) != stat.end() ){
  m += (x==d) ? stat[x]-1 : stat[x];
  }
  }
  }
  // remove the duplication - m/2, 
  // because both [1,3] and [3,1] are counted.
  return (m/2) % 1000000007;
  }
 };"
83,83,"class Solution {
 public:
  /* 
  * Initialization
  * 
  * bits_cnt[0] => 0000 => 0
  * bits_cnt[1] => 0001 => 1
  * 
  * if the number has 2 bits (2, 3), then we can split the binary to two parts, 
  * 2 = 10 + 0 and 3= 10 + 1, then we can reuse the bits_cnt[0] and bits_cnt[1] 
  *
  * bits_cnt[2] => 0010 => 0010 + 0 => 1 + bits_cnt[0];
  * bits_cnt[3] => 0011 => 0010 + 1 => 1 + bits_cnt[1];
  *
  * if the number has 3 bits (4,5,6,7), then we can split the binary to two parts, 
  * 4 = 100 + 0, 5 = 100 + 01, 6= 100 + 10, 7 = 100 +11
  * then we can reuse the bits_cnt[0] and bits_cnt[1] 
  * 
  * bits_cnt[4] => 0110 => 0100 + 00 => 1 + bits_cnt[0];
  * bits_cnt[5] => 0101 => 0100 + 01 => 1 + bits_cnt[1];
  * bits_cnt[6] => 0110 => 0100 + 10 => 1 + bits_cnt[2];
  * bits_cnt[7] => 0111 => 0100 + 11 => 1 + bits_cnt[3];
  *
  * so, we can have the solution:
  *
  * bits_cnt[x] = bits_cnt[x & (x-1) ] + 1;
  *
  */
  vector<int> countBits(int num) {
  vector<int> bits_cnt(num+1, 0); 
  for (int i=1; i<=num; i++) {
  bits_cnt[i] = bits_cnt[i & (i-1)] + 1;
  }
  return bits_cnt;
  }
 };"
84,84,"class Solution {
 public:
  int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {
  int idx;
  switch(ruleKey[0]) {
  case 't': idx = 0; break;
  case 'c': idx = 1; break;
  case 'n': idx = 2; break;
  default: return 0;
  }
  int cnt = 0;
  for (auto& item : items) {
  if (item[idx] == ruleValue) cnt++;
  }
  return cnt;
  }
 };"
85,85,"class Solution {
 private:
  int rev(int n) {
  int x = 0;
  while(n > 0) {
  x = x*10 + (n % 10);
  n /= 10;
  }
  return x;
  }
 public:
  int countNicePairs(vector<int>& nums) {
  return countNicePairs02(nums);
  return countNicePairs01(nums);
  }
  int countNicePairs01(vector<int>& nums) {
  // suppose n' = rev(n) 
  // define: a + b' == b + a'
  // then: a - a' == b - b'
  unordered_map<int, int> stat;
  for(auto& n : nums) {
  stat[n-rev(n)]++;
  }
  //if there are n elements has same value, 
  // then there are n*(n-1)/2 unique pairs.
  int result = 0;
  for(auto& [n, cnt] : stat) {
  result = (result + cnt * (cnt -1l) / 2) % 1000000007;
  }
  return result;
  }
  int countNicePairs02(vector<int>& nums) {
  // suppose n' = rev(n) 
  // define: a + b' == b + a'
  // then: a - a' == b - b'
  int result = 0;
  unordered_map<int, int> stat;
  for(auto& n : nums) {
  int delta = n-rev(n);
  stat[delta]++;
  result = (result + (stat[delta] - 1l)) % 1000000007 ;
  }
  return result ;
  }
 };"
86,86,"class Solution {
 public:
  int countHomogenous(string s) {
  long long result = 0;
  char current = '\0';
  long long len = 0;
  for(int i = 0; i < s.size() ; i++) {
  if (current != s[i] ){
  //sum from 1 to len
  result += len * (len+1)/2;
  current = s[i];
  len = 1;
  }else{
  len++;
  }
  }
  //the rest string
  result += len * (len+1)/2;
  return result % 1000000007;
  }
 };"
87,87,"// Considering three digits
 // - the first place could be [1-9] which has 9 choices.
 // - the second place could be [0-9] with excluding the first digit, which is 10-1=9 choices.
 // - the third place could be [0-9] with excluding the 1st and 2nd digits, which is 10-2=8 choices.
 // So, three digits has 9*9*8 unique digits.
 //
 // After adds the 1 digit unique number,and 2 digits unique number, we can have the result:
 //
 // 9*9*8 + 9*9 + 10 = 648 + 81 + 10 = 739
 //
 // n = 0, a[0] = 1;
 // n = 1, a[1] = 9 + a[0];
 // n = 2, a[2] = 9*9 + a[1];
 // n = 3, a[3] = 9*9*8 + a[2];
 // n = 4, a[4] = 9*9*8*7 + a[3];
 // ....
 class Solution {
 public:
  int countNumbersWithUniqueDigits(int n) {
  int result = 1;
  for (int i=0; i<n; i++) {
  result += ( 9 * nine_factor(i) );
  }
  return result;
  }
  int nine_factor(int n) {
  int result = 1;
  for (int i=0; i<n; i++) {
  result *= (9-i);
  }
  return result;
  }
 };
 //actually, the function nine_factor() could be optimized!
 class Solution {
 public:
  int countNumbersWithUniqueDigits(int n) {
  int result = 1;
  int nine_factor = 1;
  for (int i=0; i<n; i++) {
  result += ( 9 * nine_factor );
  nine_factor *= (9-i);
  }
  return result;
  }
 };"
88,88,"class Solution {
 public:
  int countOdds1(int low, int high) {
  //remove the edge cases, make it as same pattern - both low and high are odd number.
  if (high % 2 == 0) high--;
  if (low % 2 == 0 ) low++;
  return (high-low)/2+1;
  }
  int countOdds2(int low, int high) {
  return (high+1)/2 - low/2;
  }
  int countOdds(int low, int high) {
  return countOdds2(low, high);
  return countOdds1(low, high);
  }
 };"
89,89,"/*
  * At first of all, we can do preprocess to calculate the prefix sums 
  * 
  * S[i] = S(0, i), then S(i, j) = S[j] - S[i]. 
  * 
  * Note: S(i, j) as the sum of range [i, j) where j exclusive and j > i. 
  *
  * With these prefix sums, it is trivial to see that with O(n^2) time we can find all S(i, j) 
  * in the range [lower, upper]
  *
  * int countRangeSum(vector<int>& nums, int lower, int upper) {
  * int n = nums.size();
  * long[] sums = new long[n + 1];
  * for (int i = 0; i < n; ++i) {
  * sums[i + 1] = sums[i] + nums[i];
  * }
  * int ans = 0;
  * for (int i = 0; i < n; ++i) {
  * for (int j = i + 1; j <= n; ++j) {
  * if (sums[j] - sums[i] >= lower && sums[j] - sums[i] <= upper) {
  * ans++;
  * }
  * }
  * }
  * delete []sums;
  * return ans;
  * }
  * 
  * The above solution would get time limit error.
  *
  * Recall `count smaller number after self` where we encountered the problem
  *
  * count[i] = count of nums[j] - nums[i] < 0 with j > i
  *
  * Here, after we did the preprocess, we need to solve the problem
  *
  * count[i] = count of a <= S[j] - S[i] <= b with j > i 
  *
  * In other words, if we maintain the prefix sums sorted, and then are able to find out 
  * - how many of the sums are less than 'lower', say num1, 
  * - how many of the sums are less than 'upper + 1', say num2, 
  * Then 'num2 - num1' is the number of sums that lie within the range of [lower, upper].
  *
  */
 class Node{
  public:
  long long val;
  int cnt; //amount of the nodes
  Node *left, *right;
  Node(long long v):val(v), cnt(1), left(NULL), right(NULL) {}
 };
 // a tree stores all of prefix sums
 class Tree{
  public:
  Tree():root(NULL){ }
  ~Tree() { freeTree(root); }
  void Insert(long long val) {
  Insert(root, val);
  }
  int LessThan(long long sum, int val) {
  return LessThan(root, sum, val, 0);
  }
  private:
  Node* root;
  //general binary search tree insert algorithm
  void Insert(Node* &root, long long val) {
  if (!root) {
  root = new Node(val);
  return;
  }
  root->cnt++;
  if (val < root->val ) {
  Insert(root->left, val);
  }else if (val > root->val) {
  Insert(root->right, val);
  }
  }
  //return how many of the sums less than `val`
  // - `sum` is the new sums which hasn't been inserted
  // - `val` is the `lower` or `upper+1`
  int LessThan(Node* root, long long sum, int val, int res) {
  if (!root) return res;
  if ( sum - root->val < val) {
  //if (sum[j, i] < val), which means all of the right branch must be less than `val` 
  //so we add the amounts of sums in right branch, and keep going the left branch.
  res += (root->cnt - (root->left ? root->left->cnt : 0) );
  return LessThan(root->left, sum, val, res);
  }else if ( sum - root->val > val) {
  //if (sum[j, i] > val), which means all of left brach must be greater than `val`
  //so we just keep going the right branch.
  return LessThan(root->right, sum, val, res);
  }else {
  //if (sum[j,i] == val), which means we find the correct place, 
  //so we just return the the amounts of right branch.]
  return res + (root->right ? root->right->cnt : 0);
  }
  }
  void freeTree(Node* root){
  if (!root) return;
  if (root->left) freeTree(root->left);
  if (root->right) freeTree(root->right);
  delete root;
  }
 };
 class Solution {
 public:
  int countRangeSum(vector<int>& nums, int lower, int upper) {
  Tree tree;
  tree.Insert(0);
  long long sum = 0;
  int res = 0;
  for (int n : nums) {
  sum += n;
  int lcnt = tree.LessThan(sum, lower);
  int hcnt = tree.LessThan(sum, upper + 1);
  res += (hcnt - lcnt);
  tree.Insert(sum);
  }
  return res;
  }
 };"
90,90,"// The following idea is based on a `Binary Index Tree` or 'Fenwick Tree'
 // There are two articles explaining this technique quite well:
 // 1) http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/
 // 2) http://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a
 #define zeros(i) (i ^ (i - 1)) & i
 class Solution {
 public:
  vector <int> sorted, sol, fenwick;
  int n;
  int search(int t)
  {
  int step = 0;
  for(; (1 << step) <= n; step++);
  int i = 0;
  for(int k = step; k >= 0; k--)
  if(i + (1 << k) < n && sorted[i + (1 << k)] <= t)
  i += (1 << k);
  return i;
  }
  int compute(int t)
  {
  int s = 0;
  for(int i = t; i > 0; i -= zeros(i))
  s += fenwick[i];
  return s;
  }
  void add(int t)
  {
  for(int i = t; i <= n; i += zeros(i))
  fenwick[i]++;
  }
  vector<int> countSmaller(vector<int>& nums) {
  if(nums.size())
  {
  sorted = nums;
  n = nums.size();
  sort(sorted.begin(), sorted.end());
  vector <int> f(sorted.size());
  fenwick = f;
  for(int i = nums.size() - 1; i >= 0; i--)
  {
  int pos = search(nums[i]) + 1;
  sol.push_back(compute(pos - 1));
  add(pos);
  }
  reverse(sol.begin(), sol.end());
  }
  return sol;
  }
 };
 /*************************************************************************************** 
  * Another solution - Binary Search Tree
  ***************************************************************************************/
 class BinarySearchTreeNode
 {
  public:
  int val; 
  int less; // count of members less than val
  int count; // count of members equal val
  BinarySearchTreeNode *left, *right;
  BinarySearchTreeNode(int value) : val(value), less(0),count(1),left(NULL), right(NULL) {}
 };
 class BinarySearchTree
 {
  private:
  BinarySearchTreeNode* root;
  public:
  BinarySearchTree(const int value):root(new BinarySearchTreeNode(value)){ }
  ~BinarySearchTree() {
  freeTree(root);
  }
  void insert(const int value, int &numLessThan) {
  insert(root, value, numLessThan);
  }
  private:
  void freeTree(BinarySearchTreeNode* root){
  if (root == NULL) return;
  if (root->left) freeTree(root->left);
  if (root->right) freeTree(root->right);
  delete root;
  }
  void insert(BinarySearchTreeNode* root, const int value, int &numLessThan) {
  if(value < root->val) { // left
  root->less++;
  if(root->left == NULL) {
  root->left = new BinarySearchTreeNode(value);
  }else{
  this->insert(root->left, value, numLessThan);
  }
  } else if(value > root->val) { // right
  numLessThan += root->less + root->count;
  if(!root->right) {
  root->right = new BinarySearchTreeNode(value);
  }else{
  this->insert(root->right, value, numLessThan);
  }
  } else {
  numLessThan += root->less;
  root->count++;
  return;
  }
  }
 };
 class Solution {
  public:
  vector<int> countSmaller(vector<int>& nums) {
  vector<int> counts(nums.size());
  if(nums.size() == 0) return counts;
  BinarySearchTree tree(nums[nums.size()-1]);
  for(int i = nums.size() - 2; i >= 0; i--) {
  int numLessThan = 0;
  tree.insert( nums[i], numLessThan);
  counts[i] = numLessThan;
  }
  return counts; 
  }
 };"
91,91,"/*
  The constraint `a < b` could mislead us,
  - it doesn't mean we need check the pair,
  - it only means we don't include the duplicated pair.
  For Example: [1, 2] and [2, 1] are duplicated.
  So, we can ignore the `a < b` if we make sure there hasn't duplicated pair.
  We assume all of the nodes are independent, and there is no any pair has connection.
  So, we can count the number of edge for every node.
  For Example: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]],
  We can have - the `degree` means number of edges.
  degree[1] = 3
  degree[2] = 4
  degree[3] = 2
  degree[4] = 1
  Then, we could sort all of node by their edges.
  degree: 1 , 2 , 3 , 4
  node: [4], [3], [1], [2]
  Now, if the `query = 2`, we can have two pointer, one is from left, another one from right.
  degree: 1 , 2 , 3 , 4
  node: [4], [3], [1], [2]
  ^ ^
  left right
  So, (degree[left] + degree[right] > q), it means we can have the following pairs:
  degree: 1+4 2+4 3+4
  node: [4,2] [3,2] [1,2]
  ( NB: don't worry about [4,2] & [3,2] are not satsfied `a>b`, they could be [2,4] & [2,3] )
  Then, we can have the following soure code:
  if (degree[left] + degree[right] > query) {
  count_of_pairs = right - left;
  right--;
  }else {
  left++;
  }
  Now, we can deal with pair which are connected, because they have shared edges.
  So, we need go through all of the pairs they are connect.
  And we need check two condition:
  - `degree[a] + degree[b] > query` ==> this pair had been counted before!
  - `degree[a] + degree[b] - shared_edges(a,b) < query` ==> this pair should be counted!
 */
 class Solution {
 public:
  vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {
  vector<int> degree(n+1);
  unordered_map<int, unordered_map<int, int>> shared;
  for (auto& e : edges) {
  int x = e[0], y = e[1];
  degree[x]++;
  degree[y]++;
  shared[min(x,y)][max(x,y)]++;
  }
  vector<int> sorted = degree;
  sort(sorted.begin(), sorted.end());
  vector<int> result;
  for (auto& q : queries) {
  int cnt = 0;
  int left = 1, right = n;
  //Assuming all of the nodes are independent.
  while( left < right ) {
  if (q < sorted[left] + sorted[right] ) {
  cnt += (right - left);
  right--;
  }else {
  left++;
  }
  }
  //check all of pair they are connected.
  for (int i = 1; i <= n; i++){
  for (auto [j, shared_edges] : shared[i]) {
  int all_edges = degree[i] + degree[j];
  // `q < all_edges` ==> this pair had been counted before!
  // `q >= all_edges - shared_edges` ==> this pair should be counted!
  if ( q < all_edges && q >= all_edges - shared_edges ) {
  cnt--;
  }
  }
  }
  result.push_back(cnt);
  }
  return result;
  }
 };"
92,92,"/*
 The problem can be solved using Trie. 
 The idea is to iterate over the given array and for each array element, 
 count the number of elements present in the Trie whose bitwise XOR with 
 the current element is less than K and insert the binary representation 
 of the current element into the Trie. Finally, print the count of pairs 
 having bitwise XOR less than K. Follow the steps below to solve the problem:
  - Create a Trie store the binary representation of each element of the given array.
  - Traverse the given array, and count the number of elements present in the Trie 
  whose bitwise XOR with the current element is less than K and insert the binary 
  representation of the current element.
 Let's assume, we have an array [A, B, C, D, E], all of number are 5 bits.
 Find a pair is (X, E) such that X ^ E < K. (Note: X could be A,B,C,D)
 Now, let's say the binary of K = 11010. E = 01010.
 from the left to right, 
 1) Step One - the 1st bit
  K = 1 1 0 1 0
  E = 0 1 0 1 0
  ^
  X = 0 x x x x -> all of number with `0` as the 1st bit need to be counted.
 Notes: for the 1st bit of X, it could be `0` or `1`.
  - `0`: after XOR E, the 1st bit is `0`, so, it must be smaller than `K`
  - `1`: after XOR E, the 1st bit is `1`, so, we have to check the rest bits -> Step Two
 2) Step Two - the 2nd bit 
  K = 1 1 0 1 0
  E = 0 1 0 1 0
  ^
  X = 1 1 x x x -> all of number with `1` as the 2nd bit need to be counted.
 3) Step Three - the 3rd bit
  K = 1 1 0 1 0
  E = 0 1 0 1 0
  ^
  X = 1 0 0 x x -> must be 0, and go to evaluate next bit
 4) Step Four - the 4th bit
  K = 1 1 0 1 0
  E = 0 1 0 1 0
  ^
  X = 1 1 0 1 x -> all of number with `1` as the 4th bit need to be counted.
 5) Step Five - the 5th bit
  K = 1 1 0 1 0
  E = 0 1 0 1 0
  ^
  X = 1 1 0 1 0 -> must be 0, and go to evaluate next bit
 So, all of number will be sum of (step one, two, four)
 */ 
 const int LEVEL = 16; // 1 <= nums[i] <= 20000
 struct TrieNode { 
  TrieNode *child[2]; // Stores binary represention of numbers 
  int cnt; // Stores count of elements present in a node
  TrieNode() { 
  child[0] = child[1] = NULL; 
  cnt = 0; 
  } 
 }; 
 // Function to insert a number into Trie 
 void insertTrie(TrieNode *root, int n) { 
  // Traverse binary representation of X 
  for (int i = LEVEL; i >= 0; i--) { 
  // Stores ith bit of N 
  bool x = (n) & (1 << i); 
  // Check if an element already present in Trie having ith bit x
  if(!root->child[x]) { 
  // Create a new node of Trie. 
  root->child[x] = new TrieNode(); 
  } 
  // Update count of elements whose ith bit is x 
  root->child[x]->cnt += 1; 
  //Go to next level
  root = root->child[x]; 
  } 
 } 
 class Solution {
 private:
  // Count elements in Trie whose XOR with N less than K 
  int countSmallerPairs(TrieNode * root, int N, int K) { 
  // Stores count of elements whose XOR with N less than K 
  int cntPairs = 0; 
  // Traverse binary representation of N and K in Trie 
  for (int i = LEVEL; i >= 0 && root; i--) { 
  bool x = N & (1 << i); // Stores ith bit of N 
  bool y = K & (1 << i); // Stores ith bit of K 
  // If the ith bit of K is 0 
  if (y == 0 ) { 
  // find the number which bit is same as N
  // so that they can be xored to ZERO
  root = root->child[x]; 
  continue;
  } 
  // If the ith bit of K is 1 
  // If an element already present in Trie having ith bit (x)
  if(root->child[x]) {
  // find the number which bit is same as N
  // so that they can be xored to ZERO. so it would be smaller than K
  cntPairs += root->child[x]->cnt; 
  }
  //go to another way for next bit count
  root = root->child[1 - x]; 
  } 
  return cntPairs; 
  } 
 public:
  int countPairs(vector<int>& nums, int low, int high) {
  TrieNode* root = new TrieNode();
  int cnt = 0;
  for (auto& num : nums) {
  cnt += countSmallerPairs(root, num, high + 1) - countSmallerPairs(root, num, low);
  insertTrie(root, num);
  }
  return cnt;
  }
 };"
93,93,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 int countPrimes(int n) {
  vector<bool> isPrimer(n, true);
  for(int i=2; i*i<n; i++){
  if (isPrimer[i]){
  for(int j=i*i; j<n; j+=i){
  isPrimer[j] = false;
  }
  }
  }
  int cnt = 0;
  for(int i=2; i<n; i++){
  if (isPrimer[i]) { 
  //cout << i << "", "";
  cnt++;
  }
  }
  return cnt;
 }
 int main(int argc, char**argv) 
 {
  int n = 100;
  if (argc>1){
  n = atoi(argv[1]);
  }
  cout << endl << n << "" : "" << countPrimes(n) << endl;
  return 0;
 }"
94,94,"class Solution {
 public:
  bool hasCycle(int n, vector<int>& explored, vector<int>& path, map<int, vector<int>>& graph) {
  for(int i=0; i<graph[n].size(); i++){
  //detect the cycle
  if ( path[graph[n][i]] ) return true;
  //set the marker
  path[graph[n][i]] = true;
  if (hasCycle(graph[n][i], explored, path, graph)) {
  return true;
  }
  //backtrace reset
  path[graph[n][i]] = false;
  }
  //no cycle found, mark this node can finished!
  explored[n] = true;
  return false;
  }
  bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
  //using map to stroe the graph, it's easy to search the edge for each node
  //the bool in pair means it is explored or not
  map<int, vector<int>> graph;
  for(int i=0; i<prerequisites.size(); i++){
  graph[prerequisites[i].first].push_back( prerequisites[i].second );
  }
  //explored[] is used to record the node already checked!
  vector<int> explored(numCourses, false);
  //path[] is used to check the cycle during DFS
  vector<int> path(numCourses, false);
  for(int i=0; i<numCourses; i++){
  if (explored[i]) continue;
  if (hasCycle(i, explored, path, graph)) return false;
  }
  return true;
  }
 };"
95,95,"class Solution {
 public:
  // if has cycle, return false, else return true
  bool topologicalSort( int n, vector<int>& explored, vector<int>& path, 
  unordered_map<int, vector<int>>& graph, 
  vector<int>& result) 
  {
  for(int i=0; i<graph[n].size(); i++) {
  int prereq = graph[n][i];
  if ( path[prereq] ) {
  result.clear();
  return false;
  }
  path[prereq] = true;
  if (!topologicalSort(prereq, explored, path, graph, result)){
  result.clear();
  return false;
  }
  path[prereq] = false;
  }
  if (!explored[n]) {
  result.push_back(n);
  }
  explored[n] = true;
  return true;
  }
  vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
  vector<int> result;
  vector<int> enterance (numCourses, true);
  //using map to stroe the graph, it's easy to search the edge for each node
  //the bool in pair means it is explored or not
  unordered_map<int, vector<int>> graph;
  for(int i=0; i<prerequisites.size(); i++){
  graph[prerequisites[i].first].push_back( prerequisites[i].second );
  enterance[prerequisites[i].second] = false;
  }
  //explored[] is used to record the node already checked!
  vector<int> explored(numCourses, false);
  //path[] is used to check the cycle during DFS
  vector<int> path(numCourses, false);
  for(int i=0; i<numCourses; i++){
  if (!enterance[i] || explored[i]) continue;
  if (!topologicalSort(i, explored, path, graph, result)) return result;
  }
  //if there has one course hasn't been explored, means there is a cycle
  for (int i=0; i<numCourses; i++){
  if (!explored[i]) return vector<int>();
  }
  return result;
  }
 };"
96,96,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  bool isCousins(TreeNode* root, int x, int y) {
  int dx=0, dy=0;
  TreeNode *px=root, *py=root;
  dx = DepthAndParent(root, px, 0, x);
  dy = DepthAndParent(root, py, 0, y);
  if (dx && dy){
  return (dx == dy && px != py);
  }
  return false;
  }
  int DepthAndParent(TreeNode* root, TreeNode*& parent, int depth, int x) {
  if (!root) return 0;
  if ( root->val == x) return depth;
  int d=0;
  parent = root;
  if ( ( d = DepthAndParent(root->left, parent, depth+1, x)) > 0 ) return d;
  parent = root;
  if ( ( d = DepthAndParent(root->right, parent, depth+1, x)) > 0 ) return d;
  return 0;
  }
 };"
97,97,"/*
  * Solution
  * --------
  * 
  * 1) We split the `K` to two parts : `i` & `k-i` 0<= i <= k
  * 
  * 2) Find the max number for both arrays with giving the length `i` and `k-i`
  * - sub1 = FindMaxNumber(num1, len=i);
  * - sub2 = FindMaxNumber(num2, len=k-i);
  * Here, we need use stack-way to solve find the max number.
  * 
  * 3) Merge two arrays 
  * - solution = Merge(sub1, sub2);
  * Here, we need be careful if a two number are same which one we need to take. For examples: 
  * [6,7]
  * [6,0,4]
  * 5
  * 
  * [2,5,6,4,4,0]
  * [7,3,8,0,6,5,7,6,2]
  * 15
  * 
  * 4) compare with the last solution
  * - result = max(result, solution); 
  * 
  * 
  */
 class Solution {
 public:
  vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {
  vector<int> result;
  int len1 = nums1.size();
  int len2 = nums2.size();
  for (int i=0; i<=k; i++){
  if (len1 < i || len2 < k-i) continue;
  vector<int> sub1 = findMaxSubArray(nums1, i);
  vector<int> sub2 = findMaxSubArray(nums2, k-i);
  vector<int> merge = mergeTwoArrays(sub1, sub2);
  if (compareTwoArray(merge, 0, result, 0)) {
  result = merge;
  }
  }
  return result;
  }
  bool compareTwoArray(vector<int>& nums1, int start1, vector<int>& nums2, int start2) {
  int n1 = nums1.size();
  int n2 = nums2.size();
  for(; start1<n1 && start2<n2; start1++, start2++){
  if (nums1[start1] > nums2[start2]) return true;
  if (nums1[start1] < nums2[start2]) return false;
  }
  //if num1 still have numbers, return true, else return false
  return start1 < nums1.size();
  }
  vector<int> mergeTwoArrays(vector<int>& nums1, vector<int>& nums2) {
  vector<int> result;
  int len1 = nums1.size();
  int len2 = nums2.size();
  int pos1=0, pos2=0;
  while ( pos1 < len1 && pos2 < len2 ){
  // Be careful if two numbers are equal. consider the following case
  // case 1: [6,7], [6,0,4] - we have same item - 6
  // case 2: [4,0,2], [2,0,3,1] - we have same item - 0
  // which one we need to merge?
  // We need compare the rest of array.
  if (nums1[pos1] == nums2[pos2]){
  result.push_back( compareTwoArray(nums1, pos1+1, nums2, pos2+1) ? 
  nums1[pos1++] : nums2[pos2++]);
  }else {
  result.push_back(nums1[pos1] > nums2[pos2] ? 
  nums1[pos1++] : nums2[pos2++]);
  }
  }
  if (pos1 < len1){
  result.insert(result.end(), nums1.begin()+pos1, nums1.end());
  }
  if (pos2 < len2) {
  result.insert(result.end(), nums2.begin()+pos2, nums2.end());
  }
  return result;
  }
  // using a stack method to find the max sub-array
  // k <= nums.size()
  vector<int> findMaxSubArray(vector<int>& nums, int k) {
  int len = nums.size();
  if ( k >= len ) return nums;
  vector<int> result(k, 0);
  int idx = 0; // the postion for result array
  for (int i=0; i<len; i++){
  // if we met a number > the last element of result[], 
  // and we still have enough numbers,
  // then pop up the item
  while (idx>0 && k - idx < len - i && result[idx-1] < nums[i]) {
  idx--;
  }
  //push the number into the result[]
  if (idx < k) {
  result[idx++] = nums[i];
  }
  }
  return result;
  }
 };"
98,98,"class Solution {
 public:
  string decodeString(string s) {
  if (!isValid(s)) return """";
  stack<string> _stack;
  stack<int> _nstack;
  string result;
  string tmp;
  int n=0;
  for (int i=0; i<s.size(); i++) {
  if ( isNum(s[i]) ) {
  n = 0;
  for(; isNum(s[i]); i++ ) {
  n = n*10 + s[i] - '0'; 
  }
  }
  if (s[i] == '[') {
  tmp="""";
  _stack.push(tmp);
  _nstack.push(n);
  } else if (s[i] == ']') {
  n = _nstack.top(); 
  tmp="""";
  for (; n>0; n--) {
  tmp += _stack.top();
  }
  _stack.pop();
  _nstack.pop();
  if ( ! _stack.empty() ) {
  _stack.top() += tmp;
  }else {
  result += tmp;
  }
  } else {
  if ( ! _stack.empty() ) {
  _stack.top() += s[i];
  } else {
  result += s[i];
  }
  }
  }
  return result;
  }
 private:
  //only check the following rules:
  // 1) the number must be followed by '['
  // 2) the '[' and ']' must be matched.
  bool isValid(string& s) {
  stack<char> _stack;
  for (int i=0; i<s.size(); i++) {
  if ( isNum(s[i]) ) {
  for(; isNum(s[i]); i++);
  if (s[i] != '[') {
  return false;
  } 
  _stack.push('[');
  continue;
  } else if (s[i] == ']' ) {
  if ( _stack.top() != '[' ) return false;
  _stack.pop();
  }
  }
  return (_stack.size() == 0);
  }
  bool isNum(char ch) {
  return (ch>='0' && ch<='9');
  }
 };"
99,99,"#include <iostream>
 #include <string>
 #include <string.h>
 using namespace std;
 //Count[i] = Count[i-1] if S[i-1] is a valid char (not '0')
 // = Count[i-1]+ Count[i-2] if S[i-1] and S[i-2] together is still a valid char (10 to 26).
 int check(char ch){
  //check 0 or not
  return (!isdigit(ch) || ch=='0') ? 0 : 1;
 }
 int check(char ch1, char ch2){
  //check it's between 10 and 26
  return (ch1=='1' || (ch1=='2' && ch2<='6')) ? 1: 0;
 }
 int numDecodings(string s) {
  if (s.size()<=0) return 0;
  if (s.size()==1) return check(s[0]);
  int* dp = new int[s.size()];
  memset(dp, 0, s.size()*sizeof(int));
  dp[0] = check(s[0]);
  dp[1] = check(s[0]) * check(s[1]) + check(s[0], s[1]) ;
  for (int i=2; i<s.size(); i++) {
  if (!isdigit(s[i])) break; 
  if (check(s[i])) {
  dp[i] = dp[i-1];
  }
  if (check(s[i-1], s[i])) {
  dp[i] += dp[i-2];
  }
  }
  int result = dp[s.size()-1];
  delete[] dp;
  return result;
 }
 int main(int argc, char**argv)
 {
  string s = ""123"";
  if (argc>1){
  s = argv[1];
  }
  cout << ""\"""" << s << ""\"" : "" << numDecodings(s) << endl; 
  return 0;
 }"
100,100,"/*
  XOR Basic Rules
  ---------------
  At first, we need understand the following XOR rules
  x^x = 0
  0^x = x
  with the rule 1 and 2 , we can have: x^x^y = y . the element ocurrs twice would be removed.
  if x^y = z , then x = y^z and y = x^z
  XOR from 1 to n
  ---------------
  Secondly, suppose the f(n) is XOR from 1 to n , f(n) = 1^2^3^4^5 .... ^n .
  if the n is odd number, then we can observse the following things:
  f(1) = 1
  f(3) = 1^2^3 = 0
  f(5) = 1^2^3^4^5 = 1
  f(7) = 1^2^3^4^5^6^7 = 0
  f(9) = 1^2^3^4^5^6^7^8^9 = 1
  ... ...
  so, f(n) = [ (n-1)/2 + 1 ] % 2 - (n is odd number)
  Solution
  --------
  We know,
  encode = { (p1^p2), (p2^p3), (p3^p4), ... } - p is the permutation array
  so, if xor the odd index of encoded[] array,
  encoded[1] = p2 ^ p3;
  encoded[3] = p4 ^ p5;
  encoded[5] = p6 ^ p7;
  ......
  we can get: f(m) = p2 ^ p3 ^ p4 ...pn, without the p1
  with the XOR rule 3, we know
  p1 = f(n) ^ f(m)
  with the XOR rule 4, we know encoded[0] = p1^p2 then
  p2 = p1 ^ enclode[0]
  So,
  p[i+1] = p[i] ^ enclode[i]
 */
 class Solution {
 public:
  vector<int> decode(vector<int>& encoded) {
  // f(n) = 1^2^3^4^5 .... ^n ( n is odd number)
  // then, 
  // f(3) = 1
  // f(5) = 0
  // f(7) = 1
  // f(9) = 0
  // ... ...
  // f(n) = [ (n-1)/2 + 1 ] % 2
  int nxor = (encoded.size() / 2 + 1) % 2 ;
  // suppose the a[1], a[2], a[3] .... a[n] is the result array.
  // xor the odd index of encoded[] array,
  // encoded[1] = a[2] ^ a[3];
  // encoded[3] = a[4] ^ a[5];
  // encode [5] = a[6] ^ a[7];
  // ......
  // we can get: f(m) = a[2] ^ a[3] ^ a[4] ...a[n] 
  int mxor = encoded[1];
  for (int i=3; i< encoded.size(); i+=2) {
  mxor ^= encoded[i];
  }
  // a[1] = f(n) ^ f(m) 
  x = nxor ^ mxor;
  vector<int> result;
  result.push_back(x);
  // we know, encoded[i] = a[i] ^ a[i+1]
  // so, a[i+1] = a[i] ^ encoded[i]
  for (int i=0; i< encoded.size(); i++) {
  x = x ^ encoded[i];
  result.push_back(x);
  }
  return result;
  }
 };"
101,101,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  //becasue the deleted is not the tail.
  //So, we can move the content of next node to this one, and delete the next one 
  void deleteNode(ListNode* node) {
  node->val = node->next->val;
  node->next = node->next->next;
  }
 };"
102,102,"class AuthenticationManager {
 private: 
  int ttl;
  set<pair<int, string>> time_set;
  unordered_map<string, int> token_map;
 public:
  AuthenticationManager(int timeToLive):ttl(timeToLive) { }
  void generate(string tokenId, int currentTime) {
  token_map[tokenId] = currentTime;
  time_set.insert({currentTime, tokenId});
  }
  void renew(string tokenId, int currentTime) {
  //if the token is not found, or the token is expired
  if (token_map.find(tokenId) == token_map.end() ||
  token_map[tokenId] + ttl <= currentTime ) {
  return;
  }
  time_set.erase({token_map[tokenId], tokenId});
  time_set.insert({currentTime, tokenId});
  token_map[tokenId] = currentTime;
  }
  int countUnexpiredTokens(int currentTime) {
  return clean(currentTime - ttl);
  }
  int clean(int expired) {
  auto it = time_set.begin();
  while(!time_set.empty() && it->first <= expired) {
  token_map.erase(it->second);
  time_set.erase(it);
  it = time_set.begin();
  }
  return time_set.size();
  }
 };
 /**
  * Your AuthenticationManager object will be instantiated and called as such:
  * AuthenticationManager* obj = new AuthenticationManager(timeToLive);
  * obj->generate(tokenId,currentTime);
  * obj->renew(tokenId,currentTime);
  * int param_3 = obj->countUnexpiredTokens(currentTime);
  */"
103,103,"class Solution {
  bool is_lower(char ch) {
  return ch >='a' && ch <='z';
  }
  bool is_upper(char ch) {
  return ch >='A' && ch <='Z';
  }
  bool is_alpha(char ch) {
  return is_lower(ch) || is_upper(ch);
  }
 public:
  bool detectCapitalUse(string word) {
  bool all_upper = true, all_lower = true, first = is_upper(word[0]);
  for(int i=1; i<word.size(); i++) {
  if (is_lower(word[i])) all_upper = false;
  if (is_upper(word[i])) all_lower = false;
  }
  return all_lower || first && all_upper; 
  }
 };"
104,104,"class Solution {
 public:
  bool squareIsWhite(string coordinates) {
  return (coordinates[0] - 'a'+1) % 2 != (coordinates[1] - '0') % 2;
  }
 };"
105,105,"class Solution {
 private:
  int diameter;
  int maxDepth(TreeNode* root) {
  if(root==NULL) return 0;
  int left = maxDepth(root->left);
  int right = maxDepth(root->right);
  diameter = max(diameter, left + right);
  return 1 + max(left, right);
  }
 public:
  int diameterOfBinaryTree(TreeNode* root) {
  diameter = 0;
  maxDepth(root);
  return diameter;
  }
 };"
106,106,"#include <stdlib.h>
 #include <ctype.h>
 #include <iostream>
 #include <vector>
 #include <string>
 #include <map>
 using namespace std;
 bool isOperator(char ch){
  return (ch=='+' || ch=='-' || ch=='*');
 }
 //Divide & Conque - recursive way
 vector<int> diffWaysToCompute(string input) {
  //if the result has been cacluated, then just get it from the cache and return 
  static map< string, vector<int> > cache;
  if ( cache.find(input) != cache.end() ){
  return cache[input];
  }
  vector<int> result; 
  for (int i=0; i<input.size(); i++){
  char ch = input[i];
  if (isOperator(ch)){
  //split the input to two parts, left part and right part 
  //And recursively invoke this function.
  string left = input.substr(0, i);
  string right = input.substr(i+1);
  vector<int> lv = diffWaysToCompute(left);
  vector<int> rv = diffWaysToCompute(right);
  //merge two result to one
  for(int li=0; li<lv.size(); li++) {
  for(int ri=0; ri<rv.size(); ri++) {
  switch(ch){
  case '+' : result.push_back(lv[li] + rv[ri]); break;
  case '-' : result.push_back(lv[li] - rv[ri]); break;
  case '*' : result.push_back(lv[li] * rv[ri]); break;
  }
  }
  }
  }
  }
  //if we cannot find the ""operator"" in input, 
  //which means, it is a number, just put the number into the result. 
  if (result.size()==0) {
  result.push_back(atoi(input.c_str()));
  }
  //cache the result, key = input, value = result;
  cache[input] = result;
  return result;
 }
 void printVector(vector<int>& v) {
  cout << ""["";
  for(int i=0; i<v.size(); i++) {
  cout << v[i] << (i==v.size()-1 ? ""]"":"", "");
  }
  cout << endl;
 }
 int main(int argc, char**argv) 
 {
  string exp = ""2*3-4*5"";
  if ( argc > 1 ){
  exp = argv[1];
  }
  vector<int> v = diffWaysToCompute(exp);
  cout << exp << endl;
  printVector(v);
  return 0;
 }"
107,107,"#include <stdlib.h>
 #include <time.h>
 #include <string.h>
 #include <iostream>
 #include <string>
 #include <map>
 #include <vector>
 using namespace std;
 //=====================
 // Dynamic Programming
 //=====================
 //
 // The idea as below:
 //
 // Considering m[i][j] means the distance from T[i] to S[j], and add the empty """" case, then,
 //
 // A) Initialization for empty case: m[0][j] = 1;
 //
 // B) Calculation 
 //
 // a) Target-len > Source-len cannot found any substring
 // i > j : m[i][j] = 0; 
 //
 // b) if not equal, take the value of T[i] => S[j-1] (e.g. [""ra"" => ""rabb""] =[""ra"" => ""rab""] )
 // S[j] != T[i] : m[i][j] = m[i][j-1]
 //
 // c) if equal. (e.g. [""rab"" => ""rabb""] = [""rab"" =>""rab""] + [""ra"" => ""rab""] ) 
 // S[j] == T[i] : m[i][j] = m[i][j-1] + m[i-1][j-1]
 //
 // 1) Initialize a table as below 
 // """" r a b b b i t
 // """" 1 1 1 1 1 1 1 1
 // r 
 // b 
 // t 
 //
 // 2) Calculation
 // """" r a b b b i t
 // """" 1 1 1 1 1 1 1 1
 // r 0 1 1 1 1 1 1 1 
 // b 0 0 0 1 2 3 3 3
 // t 0 0 0 0 0 0 0 3
 //
 int numDistinct1(string S, string T) {
  vector< vector<int> > m(T.size()+1, vector<int>(S.size()+1));
  for (int i=0; i<m.size(); i++){
  for (int j=0; j<m[i].size(); j++){
  if (i==0){
  m[i][j] = 1;
  continue;
  }
  if ( i>j ) {
  m[i][j] = 0;
  continue;
  }
  if (S[j-1] == T[i-1]){
  m[i][j] = m[i][j-1] + m[i-1][j-1];
  } else {
  m[i][j] = m[i][j-1] ;
  }
  }
  }
  return m[T.size()][S.size()];
 }
 //=====================
 // Dynamic Programming
 //=====================
 //
 // The idea here is an optimization of above idea 
 // (It might be difficult to understand if you don't understand the above idea)
 //
 // For example:
 //
 // S = ""abbbc"" T=""abb""
 // posMap = { [a]={0}, [b]={2,1} } <- the map of T's every char.
 // numOfSubSeq = {1, 0, 0, 0 }
 //
 // S[0] is 'a', pos is 0, numOfSubSeq = {1, 0+1, 0, 0};
 //
 // S[1] is 'b', pos is 2, numOfSubSeq = {1, 1, 0, 0+0};
 // pos is 1, numOfSubSeq = {1, 1, 0+1, 0};
 //
 // S[2] is 'b', pos is 2, numOfSubSeq = {1, 1, 1, 0+1};
 // pos is 1, numOfSubSeq = {1, 1, 1+1, 1};
 //
 // S[3] is 'b', pos is 2, numOfSubSeq = {1, 1, 2, 2+1};
 // pos is 1, numOfSubSeq = {1, 1, 1+2, 3};
 //
 // S[4] is 'c', not found, numOfSubSeq = {1, 1, 3, 3};
 // 
 //
 int numDistinct2(string S, string T) {
  map< char, vector<int> > pos_map;
  int len = T.size();
  vector<int> numOfSubSeq(len+1);
  numOfSubSeq[0] = 1;
  for (int i=len-1; i>=0; i--){
  pos_map[T[i]].push_back(i);
  }
  for (int i=0; i<S.size(); i++){
  char ch = S[i];
  if ( pos_map.find(ch) != pos_map.end() ) {
  for (int j=0; j<pos_map[ch].size(); j++) {
  int pos = pos_map[ch][j];
  numOfSubSeq[pos+1] += numOfSubSeq[pos];
  } 
  }
  }
  return numOfSubSeq[len];
 }
 //random invoker
 int numDistinct(string S, string T) {
  srand(time(0));
  if (rand()%2){
  cout << ""-----Dynamic Programming Method One-----"" << endl;
  return numDistinct1(S,T);
  }
  cout << ""-----Dynamic Programming Method Two-----"" << endl;
  return numDistinct2(S,T);
 }
 int main(int argc, char** argv)
 {
  string s = ""rabbbit"";
  string t = ""rabbit"";
  if (argc>2){
  s = argv[1];
  t = argv[2];
  }
  cout << ""S=\"""" << s << ""\"" T=\"""" << t << ""\"""" << endl;
  cout << ""numDistinct = "" << numDistinct(s, t) << endl;
  return 0;
 }"
108,108,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  int distributeCoins(TreeNode* root) {
  int result = 0;
  dfs(root, result);
  return result;
  }
  //
  // if a node has 0 coin, which means one move from its parent.
  // 1 coin, which means zero move from its parent.
  // N coins, which means N-1 moves to its parent.
  //
  // So, we can simply know, the movement = coins -1.
  // - negative number means the the coins needs be moved in.
  // - positive number means the the coins nees be moved out.
  //
  // A node needs to consider the movement requests from both its left side and right side.
  // and need to calculate the coins after left and right movement.
  //
  // So, the node coins = my conins - the coins move out + the coins move in.
  //
  // Then we can have to code as below.
  //
  int dfs(TreeNode* root, int& result) {
  if (root == NULL) return 0;
  int left_move = dfs(root->left, result);
  int right_move = dfs(root->right, result);
  result += (abs(left_move) + abs(right_move));
  // the coin after movement: coins = root->val +left_move + right_move
  // the movement needs: movement = coins - 1
  return root->val + left_move + right_move - 1;
  }
 };"
109,109,"#include <stdio.h>
 #include <string.h>
 #include <iostream>
 using namespace std;
 #define INT_MAX 2147483647
 #define INT_MIN (-INT_MAX - 1)
 int divide(int dividend, int divisor) {
  int sign = (float)dividend / divisor > 0 ? 1 : -1;
  unsigned int dvd = dividend > 0 ? dividend : -dividend;
  unsigned int dvs = divisor > 0 ? divisor : -divisor;
  unsigned int bit_num[33];
  unsigned int i=0;
  long long d = dvs;
  bit_num[i] = d;
  while( d <= dvd ){
  bit_num[++i] = d = d << 1;
  }
  i--;
  unsigned int result = 0;
  while(dvd >= dvs){
  if (dvd >= bit_num[i]){
  dvd -= bit_num[i];
  result += (1<<i);
  }else{
  i--;
  }
  }
  //becasue need to return `int`, so we need to check it is overflowed or not.
  if ( result > INT_MAX && sign > 0 ) {
  return INT_MAX;
  }
  return (int)result * sign;
 }
 int main()
 {
  cout << ""0/2="" << divide(0, 2) << endl;
  cout << ""10/2="" << divide(10, 2) << endl;
  cout << ""10/3="" << divide(10, 3) << endl;
  cout << ""10/5="" << divide(10, 5) << endl;
  cout << ""10/7="" << divide(10, 7) << endl;
  cout << ""10/10="" << divide(10, 10) << endl;
  cout << ""10/11="" << divide(10, 11) << endl;
  cout << ""-1/1="" << divide(1, -1) << endl;
  cout << ""1/-1="" << divide(1, -1) << endl;
  cout << ""-1/-1="" << divide(-1, -1) << endl;
  cout << ""2147483647/1="" << divide(2147483647, 1) << endl;
  cout << ""-2147483647/1="" << divide(-2147483647, 1) << endl;
  cout << ""2147483647/-1="" << divide(2147483647, -1) << endl;
  cout << ""-2147483647/-1="" << divide(-2147483647, -1) << endl;
  cout << ""2147483647/2="" << divide(2147483647, 2) << endl;
  cout << ""2147483647/10="" << divide(2147483647, 10) << endl;
  cout << ""-2147483648/1="" << divide(-2147483648, 1) << endl;
  cout << ""-2147483648/-1="" << divide(-2147483648, -1) << endl;
 }"
110,110,"class Solution {
  public:
  int calculateMinimumHP(vector<vector<int> > &dungeon) {
  int row = dungeon.size();
  int col = row>0 ? dungeon[0].size() : 0;
  if (row<=0 || col <=0) return 0;
  //dp[r][c] = min( max( dp[r+1][c] - dungeon[r][c], 1), max( dp[r][c+1] - dungeon[r][c], 1) );
  int dp[row][col];
  memset(dp, 0, sizeof(dp));
  for(int r=row-1; r>=0; r--){
  for (int c=col-1; c>=0; c--){
  /*if (r == row - 1 && c == col - 1 ){
  dp[r][c] = max(1 - dungeon[r][c], 1);
  }else if ( r == row - 1 ) {
  dp[r][c] = max(dp[r][c+1] - dungeon[r][c], 1);
  }else if ( c == col - 1 ) {
  dp[r][c] = max(dp[r+1][c] - dungeon[r][c], 1);
  }else{
  dp[r][c] = min( max( dp[r+1][c] - dungeon[r][c], 1), max( dp[r][c+1] - dungeon[r][c], 1) );
  }*/
  if (r == row - 1 && c == col - 1 ){
  dp[r][c] = max(1 - dungeon[r][c], 1);
  }else{ 
  int h1 = ( c == col-1 ) ? INT_MAX : max(dp[r][c+1] - dungeon[r][c], 1);
  int h2 = ( r == row-1 ) ? INT_MAX : max(dp[r+1][c] - dungeon[r][c], 1);
  dp[r][c] = min( h1, h2 );
  }
  }
  }
  return dp[0][0];
  }
 };"
111,111,"#include <iostream>
 #include <string>
 #include <vector>
 #include <algorithm>
 using namespace std;
 /*
  * Dynamic Programming
  *
  * Definitaion
  *
  * m[i][j] is minimal distance from word1[0..i] to word2[0..j]
  *
  * So, 
  *
  * 1) if word1[i] == word2[j], then m[i][j] == m[i-1][j-1].
  *
  * 2) if word1[i] != word2[j], then we need to find which one below is minimal:
  *
  * min( m[i-1][j-1], m[i-1][j], m[i][j-1] )
  * 
  * and +1 - current char need be changed.
  *
  * Let's take a look m[1][2] : ""a"" => ""ab"" 
  *
  * +---+ +---+ 
  * ''=> a | 1 | | 2 | '' => ab 
  * +---+ +---+ 
  * 
  * +---+ +---+ 
  * a => a | 0 | | 1 | a => ab 
  * +---+ +---+ 
  * 
  * To know the minimal distance `a => ab`, we can get it from one of the following cases:
  *
  * 1) delete the last char in word1, minDistance( '' => ab ) + 1 
  * 2) delete the last char in word2, minDistance( a => a ) + 1 
  * 3) change the last char, minDistance( '' => a ) + 1 
  * 
  * 
  * For Example:
  *
  * word1=""abb"", word2=""abccb""
  *
  * 1) Initialize the DP matrix as below:
  *
  * """" a b c c b
  * """" 0 1 2 3 4 5
  * a 1
  * b 2
  * b 3
  *
  * 2) Dynamic Programming
  *
  * """" a b c c b
  * """" 0 1 2 3 4 5
  * a 1 0 1 2 3 4 
  * b 2 1 0 1 2 3
  * b 3 2 1 1 2 2
  *
  */
 int min(int x, int y, int z) {
  return std::min(x, std::min(y,z));
 }
 int minDistance(string word1, string word2) {
  int n1 = word1.size(); 
  int n2 = word2.size(); 
  if (n1==0) return n2;
  if (n2==0) return n1;
  vector< vector<int> > m(n1+1, vector<int>(n2+1));
  for(int i=0; i<m.size(); i++){
  m[i][0] = i;
  }
  for (int i=0; i<m[0].size(); i++) {
  m[0][i]=i;
  }
  //Dynamic Programming
  int row, col;
  for (row=1; row<m.size(); row++) {
  for(col=1; col<m[row].size(); col++){
  if (word1[row-1] == word2[col-1] ){
  m[row][col] = m[row-1][col-1];
  }else{
  int minValue = min(m[row-1][col-1], m[row-1][col], m[row][col-1]);
  m[row][col] = minValue + 1;
  }
  }
  }
  return m[row-1][col-1];
 }
 int main(int argc, char**argv)
 {
  string word1=""abb"", word2=""abccb"";
  if (argc>2){
  word1 = argv[1];
  word2 = argv[2];
  }
  int steps = minDistance(word1, word2);
  cout << word1 << "", "" << word2 << "" : "" << steps << endl;
  return 0;
 }"
112,112,"class Solution {
 public:
  int lastRemaining(int n) {
  int start = 1, step = 1;
  while (n > 1) {
  start += step + (n-2)/2 * 2*step;
  n /= 2;
  step *= -2;
  }
  return start;
  }
 };"
113,113,"class Solution { 
 private:
  void print(vector<int>& n) {
  cout <<""["";
  for(int i=0; i< n.size() - 1; i++) {
  cout << n[i] << "","";
  }
  cout << n[n.size()-1] << ""]"" <<endl;
  }
 private:
  int minOpsBySort(int gaps, vector<int>& small, vector<int>& big) {
  sort(small.begin(), small.end());
  sort(big.begin(), big.end());
  int op = 0;
  int left = 0, right = big.size() -1;
  while (gaps >0) {
  int small_gaps = left < small.size() ? 6 - small[left] : 0;
  int big_gaps = right >= 0 ? big[right] - 1 : 0;
  if (small_gaps > big_gaps) {
  gaps -= small_gaps;
  left++;
  }else{
  gaps -= big_gaps;
  right--;
  }
  op++;
  }
  return op;
  }
  int minOpsByCnt1(int gaps, vector<int>& small, vector<int>& big) {
  int small_cnt[6] = {0} , big_cnt[6] = {0};
  for (auto& n : small) small_cnt[n-1]++;
  for (auto& n : big) big_cnt[n-1]++;
  int op = 0;
  int left = 0, right = 5; 
  while( gaps > 0 ) {
  while (left < 6 && small_cnt[left] == 0 ) left++;
  while ( right >=0 && big_cnt[right] == 0 ) right--;
  int small_gaps = left < 6 ? 6 - (left + 1) : 0;
  int big_gaps = right >= 0 ? right : 0;
  if (small_gaps > big_gaps) {
  gaps -= small_gaps;
  small_cnt[left]--;
  }else{
  gaps -= big_gaps;
  big_cnt[right]--;
  }
  op++;
  }
  return op;
  }
  int minOpsByCnt2(int gaps, vector<int>& small, vector<int>& big) {
  int cnt[6] = {0};
  for (auto& n : small) cnt[6-n]++;
  for (auto& n : big) cnt[n-1]++;
  int ops = 0;
  for (int i=5 ; i >= 0 && gaps > 0; i--) {
  if (cnt[i] == 0) continue;
  if (cnt[i] * i > gaps) {
  ops += (gaps / i + (gaps % i ? 1:0) ) ;
  break;
  }
  gaps -= cnt[i] * i;
  ops += cnt[i];
  }
  return ops;
  }
 public:
  int minOperations(vector<int>& nums1, vector<int>& nums2) {
  int len1 = nums1.size(), len2 = nums2.size();
  if ( len1 > 6*len2 || len2 > 6*len1) return -1;
  int sum1 = 0 , sum2 = 0;
  for (auto& n : nums1) sum1 += n;
  for (auto& n : nums2) sum2 += n;
  if (sum1 > sum2) {
  swap(sum1, sum2);
  swap(nums1, nums2);
  }
  int gaps = sum2 - sum1;
  if (gaps == 0) return 0;
  return minOpsByCnt2(gaps, nums1, nums2); //104ms
  return minOpsByCnt1(gaps, nums1, nums2); //108ms
  return minOpsBySort(gaps, nums1, nums2); //140ms
  }
 };"
114,114,"class Solution {
 private:
  bool dfs( unordered_map<string, unordered_map<string, double>>& m, 
  unordered_map<string, bool>& visited, 
  string& start, string& end, double& res ) {
  if ( m.find(start) == m.end() || m.find(end) == m.end() ) return false;
  if ( start == end ) return true;
  for (auto it = m[start].begin(); it != m[start].end(); ++it) {
  auto key = it->first;
  auto value = it->second;
  // already visited, skip it.
  if (visited.find(key) != visited.end() ) {
  continue;
  }
  visited[key] = true;
  double old = res;
  res *= value;
  if (dfs(m, visited, key, end, res)) {
  return true;
  }
  //didn't find the result, reset the current result, and go to next one
  res = old;
  visited.erase(key);
  }
  return false;
  }
 public:
  vector<double> calcEquation(vector<pair<string, string>> equations, 
  vector<double>& values, 
  vector<pair<string, string>> queries) {
  unordered_map<string, unordered_map<string, double>> m;
  for(int i=0; i<equations.size(); i++) {
  auto first = equations[i].first;
  auto second = equations[i].second;
  m[first][second] = values[i];
  m[second][first] = 1.0 / values[i];
  }
  vector<double> result;
  for(auto q : queries) {
  string start = q.first;
  string end = q.second;
  unordered_map<string, bool> visited;
  visited[start] = true;
  double res = 1.0;
  if(dfs(m, visited, start, end, res)) {
  result.push_back(res);
  } else {
  result.push_back(-1.0);
  }
  }
  return result;
  }
 };"
115,115,"#include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <string>
 #include <vector>
 #include <iostream>
 using namespace std;
 class Solution {
 public:
  int evalRPN(vector<string> &tokens) {
  int i =0;
  bool err = false;
  vector<int> exp;
  for (int i=0; i<tokens.size() && !err; i++ ){
  if (isNum(tokens[i])) {
  exp.push_back(value);
  } else if( isOp(tokens[i])==true ) {
  if (exp.size() < 2) {
  return 0; //ERROR
  }
  int lhs, rhs;
  rhs = exp.back();
  exp.pop_back();
  lhs = exp.back();
  exp.pop_back();
  int evlValue;
  if (tokens[i]==""+""){
  evlValue = lhs + rhs; 
  }else if (tokens[i]==""-""){
  evlValue = lhs - rhs;
  }else if (tokens[i]==""*""){
  evlValue = lhs * rhs;
  }else if (tokens[i]==""/""){
  evlValue = lhs / rhs;
  }
  exp.push_back(evlValue);
  }else {
  return 0; //ERROR 
  }
  }
  if (exp.size()==1){
  return exp.back();
  }
  return 0; 
  }
 private:
  long value;
  bool isOp(string &op) {
  return (op==""+"" || op==""-"" || op==""*"" || op==""/"");
  }
  bool isNum(string &num) {
  char *end;
  value = strtol(num.c_str(), &end, 10); 
  if (end == num.c_str() || *end != '\0' || errno == ERANGE){
  return false;
  }
  return true;
  }
 };
 int main()
 {
  Solution s;
  char exps[5][3] = {""42"", ""9"", ""6"", ""-"", ""+""};
  vector<string> expression;
  cout << ""Expression: \n "";
  for (int i=0; i<5; i++){
  expression.push_back(exps[i]);
  cout << exps[i] << "" "";
  }
  cout << endl;
  cout << s.evalRPN(expression)<<endl;;
  char exps2[5][3] = {""2"", ""1"", ""+"", ""3"", ""*""};
  expression.clear();
  cout << ""Expression: \n "";
  for (int i=0; i<5; i++){
  expression.push_back(exps2[i]);
  cout << exps2[i] << "" "";
  }
  cout << endl;
  cout << s.evalRPN(expression)<<endl;
  return 0;
 }"
116,116,"class Solution {
 private:
  bool isBracket(char c) {
  return c=='(' || c == ')';
  }
 public:
  string evaluate(string s, vector<vector<string>>& knowledge) {
  unordered_map<string, string> dict;
  for(auto& k : knowledge) {
  dict[k[0]] = k[1];
  }
  string result;
  string key;
  bool meetLeftBracket = false;
  for(auto& c : s) {
  if (c == '(') {
  meetLeftBracket = true;
  } else if (c == ')') {
  meetLeftBracket = false;
  //cout << key << endl;
  if (dict.find(key) != dict.end()) {
  result += dict[key];
  }else {
  result += '?';
  }
  key = """";
  } else {
  if (meetLeftBracket) {
  key += c;
  }else{
  result +=c;
  }
  }
  }
  return result;
  }
 };"
117,117,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <string>
 using namespace std;
 string base26_int2str(long long n) {
  string ret;
  while(n>0){
  char ch = 'A' + (n-1)%26;
  ret.insert(ret.begin(), ch );
  n -= (n-1)%26;
  n /= 26;
  }
  return ret;
 }
 long long base26_str2int(string& s){
  long long ret=0;
  for (int i=0; i<s.size(); i++){
  int n = s[i] - 'A' + 1;
  ret = ret*26 + n;
  }
  return ret;
 }
 string titleToNumber(int n) {
  return base26_str2int(n);
 }
 int main(int argc, char**argv)
 {
  long long n = 27; 
  if (argc>1){
  n = atoll(argv[1]);
  }
  string ns = base26_int2str(n);
  n = base26_str2int(ns);
  cout << n << "" = "" << ns << endl;
  ns = ""ABCDEFG"";
  if (argc>2){
  ns = argv[2];
  }
  cout << ns << "" = "" << base26_str2int(ns) << endl;
 }"
118,118,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <string>
 using namespace std;
 string base26_int2str(long long n) {
  string ret;
  while(n>0){
  char ch = 'A' + (n-1)%26;
  ret.insert(ret.begin(), ch );
  n -= (n-1)%26;
  n /= 26;
  }
  return ret;
 }
 long long base26_str2int(string& s){
  long long ret=0;
  for (int i=0; i<s.size(); i++){
  int n = s[i] - 'A' + 1;
  ret = ret*26 + n;
  }
  return ret;
 }
 string convertToTitle(int n) {
  return base26_int2str(n);
 }
 int main(int argc, char**argv)
 {
  long long n = 27; 
  if (argc>1){
  n = atoll(argv[1]);
  }
  string ns = base26_int2str(n);
  n = base26_str2int(ns);
  cout << n << "" = "" << ns << endl;
  ns = ""ABCDEFG"";
  if (argc>2){
  ns = argv[2];
  }
  cout << ns << "" = "" << base26_str2int(ns) << endl;
 }"
119,119,"class Solution {
 public:
  vector<string> addOperators(string num, int target) {
  vector<string> result;
  if (num.size() == 0) return result;
  helper(num, target, result, """", 0, 0, 0, ' ');
  return result; 
  }
  //DFS algorithm
  void helper(const string &num, const int target, //`num` and `target` never change
  vector<string>& result, // the array store all of the answers
  string solution, //the current potential answer.
  int idx, // the current index of `num` array
  long long val, // the current value we calculated so far
  long long prev, // the lastest value we used for calculation, which used for operation prioirty adjustment
  char preop ) // the latest ""+"" or ""-"" operation, which used for operation prioirty adjustment 
  {
  if (target == val && idx == num.size()){
  result.push_back(solution);
  return;
  }
  if (idx == num.size()) return;
  string n;
  long long v=0;
  for(int i=idx; i<num.size(); i++) {
  //get rid of the number which start by ""0""
  //e.g. ""05"" is not the case.
  if (n==""0"") return;
  n = n + num[i];
  v = v*10 + num[i]-'0';
  if (solution.size()==0){ 
  // the first time for initialization
  helper(num, target, result, n, i+1, v, 0, ' ');
  }else{
  // '+' or '-' needn't to adjust the priority
  helper(num, target, result, solution + '+' + n, i+1, val+v, v, '+');
  helper(num, target, result, solution + '-' + n, i+1, val-v, v, '-');
  //if we meet multiply operation, we need adjust the calcualtion priority
  // e.g. if the previous value is calculated by 2+3=5, 
  // then if we need to multipy 4, it is not 5*4, it is 2+3*4=2+12=24
  // we need be careful about multiply again, such as: 2+3*4*5
  if (preop=='+') {
  helper(num, target, result, solution + '*' + n, i+1, (val-prev)+prev*v, prev*v, preop);
  }else if (preop=='-'){
  helper(num, target, result, solution + '*' + n, i+1, (val+prev)-prev*v, prev*v, preop);
  }else {
  helper(num, target, result, solution + '*' + n, i+1, val*v, v, '*');
  }
  }
  }
  }
 };"
120,120,"/*
  * The idea is: 
  * 
  * 1. The ZERO comes from 10. 
  * 2. The 10 comes from 2 x 5 
  * 3. And we need to account for all the products of 5 and 2. likes 4Ã—5 = 20 ...
  * 4. So, if we take all the numbers with 5 as a factor, we'll have way more than enough even numbers 
  * to pair with them to get factors of 10
  * 
  * **Example One**
  * 
  * How many multiples of 5 are between 1 and 23? 
  * There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2's from the even factors, 
  * this makes for four factors of 10, so: **23! has 4 zeros**.
  * 
  * 
  * **Example Two**
  * 
  * How many multiples of 5 are there in the numbers from 1 to 100? 
  * 
  * because 100 Ã· 5 = 20, so, there are twenty multiples of 5 between 1 and 100.
  * 
  * but wait, actually 25 is 5Ã—5, so each multiple of 25 has an extra factor of 5, 
  * ( e.g. 25 Ã— 4 = 100ï¼Œwhich introduces extra of zero )
  * 
  * So, we need know how many multiples of 25 are between 1 and 100? Since 100 Ã· 25 = 4, 
  * (there are four multiples of 25 between 1 and 100)
  * 
  * Finally, we get 20 + 4 = 24 trailing zeroes in 100!
  * 
  * 
  * The above example tell us, we need care about 5, 5Ã—5, 5Ã—5Ã—5, 5Ã—5Ã—5Ã—5 ....
  * 
  * **Example Three**
  * 
  * 
  * 5^1 : 4617 Ã· 5 = 923.4, so we get 923 factors of 5
  * 5^2 : 4617 Ã· 25 = 184.68, so we get 184 additional factors of 5
  * 5^3 : 4617 Ã· 125 = 36.936, so we get 36 additional factors of 5
  * 5^4 : 4617 Ã· 625 = 7.3872, so we get 7 additional factors of 5
  * 5^5 : 4617 Ã· 3125 = 1.47744, so we get 1 more factor of 5
  * 5^6 : 4617 Ã· 15625 = 0.295488, which is less than 1, so stop here.
  * 
  * Then 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes.
  * 
  */
 class Solution {
  public:
  int trailingZeroes(int n) {
  int result = 0;
  //To avoid the integer overflow ( e.g. 'n >=1808548329' )
  for(long long i=5; n/i>0 && i <= INT_MAX; i*=5){
  result += (n/i);
  }
  return result;
  }
  // Alternative implementation which naturally avoid integer overflow issue.
  int trailingZeroes(int n) {
  int sum=0;
  int tmp=0;
  while(n/5>0)
  {
  tmp=n/5;
  sum+=tmp;
  n=tmp;
  }
  return sum;
  }
 };"
121,121,"class Solution {
 public:
  int fib(int N) {
  if (N < 2 ) return N;
  int first = 0, second = 1;
  for ( N-=1; N > 0; N-- ) {
  second += first;
  first = second - first;
  }
  return second;
  }
 };"
122,122,"static bool cmp(const vector<int>& v1, const vector<int>& v2) {
  return v1[1] == v2[1] ? v1[0] > v2[0] : v1[1] > v2[1];
 }
 class Solution {
 public:
  vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
  vector<vector<int>> res;
  for(int i = 0; i < restaurants.size(); i++) {
  if (!restaurants[i][2] && veganFriendly) continue;
  if (restaurants[i][3] > maxPrice) continue;
  if (restaurants[i][4] > maxDistance) continue;
  res.push_back(restaurants[i]);
  }
  sort(res.begin(), res.end(), cmp);
  vector<int> ids;
  for(int i = 0; i < res.size(); i++) ids.push_back(res[i][0]);
  return ids; 
  }
 };"
123,123,"* Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
 * The order of output does not matter.
 * Example 1:
 * Input:
  s: ""cbaebabacd"" p: ""abc""
 * Output:
  [0, 6]
 * Explanation:
  The substring with start index = 0 is ""cba"", which is an anagram of ""abc"".
  The substring with start index = 6 is ""bac"", which is an anagram of ""abc"".
 *Example 2:
 * Input:
  s: ""abab"" p: ""ab""
 * Output:
  [0, 1, 2]
 * Explanation:
 * The substring with start index = 0 is ""ab"", which is an anagram of ""ab"".
 * The substring with start index = 1 is ""ba"", which is an anagram of ""ab"".
 * The substring with start index = 2 is ""ab"", which is an anagram of ""ab"".
  ******************************************************************************************************/
  class Solution {
 public:
  vector<int> findAnagrams(string s, string p) {
  vector<int>result;
  vector<int>v1(26);
  if(s.size()<p.size()){
  return result;
  }
  for(int i=0;i<p.size();i++){
  v1[p[i]-97]++;
  }
  for(int i=0;i<=(s.size()-p.size());i++){
  vector<int>v2(26);
  for(int index=i;index<(i+p.size());index++){
  v2[s[index]-97]++;
  }
  if(v1==v2){
  result.push_back(i);
  } 
  }
  return result;
  }
 };"
124,124,"class MKAverage {
 private:
  vector<int> ringBuf;
  int pos;
  multiset<int> left, mid, right;
  long sum;
  long maxmin;
  int m;
  int k;
 private:
  template <class T>
  void print(T& v) {
  for(auto it : v){
  cout << it << ""+"";
  }
  cout <<endl;
  }
  int takeMax(multiset<int>& s) {
  auto it = --s.end();
  int n = *it;
  s.erase(it);
  return n;
  }
  int takeMin(multiset<int>& s) {
  auto it = s.begin();
  int n = *it;
  s.erase(it);
  return n;
  }
 public:
  MKAverage(int _m, int _k): ring(_m, 0), m(_m), k(_k), sum(0), pos(0), maxmin(0) {
  }
  void ins(int n) {
  left.insert(n);
  maxmin += n;
  if (left.size() > k ) {
  int n = takeMax(left);
  right.insert(n);
  if (right.size() > k) {
  int n = takeMin(right);
  maxmin -= n;
  mid.insert(n);
  }
  }
  }
  void del(int n) {
  if (n <= *(left.rbegin())) {
  left.erase(left.find(n));
  int n1 = takeMin(mid);
  left.insert(n1);
  maxmin += (n1 - n);
  }else if (n >= *(right.begin())) {
  right.erase(right.find(n));
  int n1 = takeMax(mid);
  right.insert(n1);
  maxmin += (n1 - n);
  }else {
  mid.erase(mid.find(n));
  } 
  }
  void addElement(int num) {
  pos++; 
  if (pos > m) {
  int n = ringBuf[pos % m];
  sum -= n;
  del(n);
  //cout << ""DEL: n="" << n << "", sum="" << sum << "", maxmin="" << maxmin << endl;
  //print(left); print(mid);print(right);
  } 
  ringBuf[pos % m] = num ;
  sum += num;
  ins(num);
  //cout << ""INS: n="" << num << "", sum="" << sum << "", maxmin="" << maxmin << endl;
  //print(left); print(mid);print(right);
  }
  int calculateMKAverage() {
  if (pos < m) return -1;
  //cout << ""CAL: sum="" << sum << "", maxmin="" << maxmin << "", delta="" << sum - maxmin<< endl;
  return (sum - maxmin) / (m-2*k);
  }
 };
 /**
  * Your MKAverage object will be instantiated and called as such:
  * MKAverage* obj = new MKAverage(m, k);
  * obj->addElement(num);
  * int param_2 = obj->calculateMKAverage();
  */
 //TLE solution - using only one array and Binary Search.
 class MKAverage1 {
 private:
  vector<int> ring;
  int pos;
  vector<int> sort;
  long sum;
  long maxmin;
  int m;
  int k;
 private:
  template <class T>
  void print(T& v) {
  for(auto it : v){
  cout << it << ""+"";
  }
  cout <<endl;
  }
 public:
  MKAverage1(int _m, int _k): ring(_m,0), m(_m), k(_k), sum(0), pos(0), maxmin(0) {
  }
  void ins(int n) {
  int low = 0, high = sort.size()-1;
  int mid;
  if (high < 0 || n >= sort[high]) {
  sort.push_back(n); 
  return;
  }
  while(low <= high){
  mid = low + (high-low)/2;
  if (sort[mid] <= n ) low = mid + 1;
  else high = mid - 1;
  }
  auto it = sort.begin() + low;
  sort.insert(it, n);
  }
  void del(int n) {
  int len = sort.size();
  int low = 0, high = len -1;
  int mid;
  while(low <= high){
  mid = low + (high-low)/2;
  if (sort[mid] == n) break;
  if (sort[mid] < n ) low = mid + 1;
  else high = mid - 1;
  }
  if (low > high) return;
  auto it = sort.begin() + mid;
  sort.erase(it);
  }
  void addElement(int num) {
  pos++;
  if (pos > m) {
  int n = ring[pos % m];
  sum -= n;
  int len = sort.size();
  if (n <= sort[k-1] ) maxmin += (sort[k]-n);
  else if (n >= sort[len-k]) maxmin += (sort[len-k-1] - n);
  del(n);
  //cout << ""DEL: n="" << n << "", sum="" << sum << "", maxmin="" << maxmin << endl;
  //print(sort);
  } 
  ring[pos % m] = num;
  sum += num;
  if (sort.size() < 2*k ) {
  maxmin += num;
  } else {
  int len = sort.size();
  if (num <= sort[k-1]) maxmin += (num - sort[k-1]);
  else if (num >= sort[len-k]) maxmin += (num -sort[len-k]);
  }
  ins(num);
  //cout << ""INS: n="" << num << "", sum="" << sum << "", maxmin="" << maxmin << endl;
  //print(sort);
  }
  int calculateMKAverage() {
  if ( pos < m) return -1;
  //cout << ""CAL: sum="" << sum << "", maxmin="" << maxmin << "", delta="" << sum - maxmin<< endl;
  return (sum - maxmin) / (m-2*k);
  }
 };
 /**
  * Your MKAverage object will be instantiated and called as such:
  * MKAverage* obj = new MKAverage(m, k);
  * obj->addElement(num);
  * int param_2 = obj->calculateMKAverage();
  */"
125,125,"class Solution {
 public:
  vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {
  vector<int> result(k, 0);
  unordered_map<int, set<int>> uam;
  for (auto& log : logs) {
  uam[log[0]].insert(log[1]);
  }
  for (auto& [id, t] : uam) {
  if (t.size() <= k) {
  result[t.size()-1]++;
  }
  }
  return result;
  }
 };"
126,126,"class Solution {
 private:
  void print(vector<vector<int>>& m) {
  int row = m.size();
  int col = m[0].size();
  for (int i=0; i<row; i++) {
  for(int j=0; j<col-1; j++) {
  cout << setw(3) << m[i][j] << "","";
  }
  cout << setw(3) << m[i][col-1] << endl;
  }
  cout << endl;
  }
 public:
  int kthLargestValue(vector<vector<int>>& matrix, int k) {
  int row = matrix.size();
  int col = matrix[0].size();
  vector<vector<int>> xmatrix(row, vector<int>(col, 0));
  priority_queue<int> minHeap;
  xmatrix[0][0] = matrix[0][0];
  minHeap.push(xmatrix[0][0]);
  for (int i=1; i<row; i++) {
  xmatrix[i][0] = xmatrix[i-1][0] ^ matrix[i][0];
  minHeap.push(xmatrix[i][0]);
  }
  for (int i=1; i<col; i++) {
  xmatrix[0][i] = xmatrix[0][i-1] ^ matrix[0][i];
  minHeap.push(xmatrix[0][i]);
  }
  for (int i=1; i<row; i++) {
  for(int j=1; j<col; j++) {
  xmatrix[i][j] = matrix[i][j] ^ 
  xmatrix[i-1][j] ^ xmatrix[i][j-1] ^ xmatrix[i-1][j-1];
  minHeap.push(xmatrix[i][j]);
  }
  }
  //print(matrix);
  //print(xmatrix);
  while( k-- > 1) {
  minHeap.pop();
  }
  return minHeap.top();
  }
 };"
127,127,"class MedianFinder {
 private:
  //we seprate the sorted array to two parts
  multiset<int> first, second;
 public:
  // Adds a number into the data structure.
  void addNum(int num) {
  if (first.empty() || num <= *(first.rbegin()) ) {
  first.insert(num);
  } else {
  second.insert(num);
  }
  if (first.size() > second.size() + 1) {
  auto it = first.end();
  it--;
  second.insert(*(it));
  first.erase(it);
  }
  if ( first.size() < second.size() ) {
  first.insert(*(second.begin()));
  second.erase(second.begin());
  }
  }
  // Returns the median of current data stream
  double findMedian() {
  if (first.size()> second.size()) {
  return *(first.rbegin());
  }
  double x = *first.rbegin();
  double y = *second.begin();
  return (x+y)/2;
  }
 };
 // Your MedianFinder object will be instantiated and called as such:
 // MedianFinder mf;
 // mf.addNum(1);
 // mf.findMedian();"
128,128,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 /* 
  * Obveriously, to search any sorted array, the binary search is the common sense.
  * 
  * To solve this problem, the idea is same as the search in rotated sorted array.
  */
 int findMin(vector<int> &num) {
  int low=0, high=num.size()-1;
  while(high-low>1){
  int mid = low + (high-low)/2;
  // Chek the array if it is non-rotated, then just return the first element.
  if (num[low] < num[mid] && num[mid] < num[high]){
  return num[low];
  }
  // The array is rotated
  // Split it into two part, the minimal value must be the rotated part
  // if the left part is rotated, warch the left part
  if (num[low] > num [mid]){
  high = mid;
  continue;
  }
  // if the right part is rotated, search the right part.
  if (num[mid] > num[high]){
  low = mid;
  continue;
  }
  }
  // the array only has 1 element
  if (high == low) return num[low];
  // the array has 2 elements
  return num[low] < num[high] ? num[low] : num[high];
 }
 void rotate_array(int a[], int n, int pos){
  int i, from=0;
  pos = pos % n;
  if (n<=0) return;
  int tmp = a[0];
  for(int i=0, step=0; step<n && i<pos; step++){
  int to;
  if (from-pos < 0) {
  to = n-pos+from; 
  }else{
  to = from-pos;
  }
  int t ;
  t = a[to];
  a[to] = tmp; 
  tmp = t;
  from = to;
  if ( to == i ){
  i++;
  from++;
  tmp = a[from];
  }
  }
 }
 void printArray(int A[], int n) {
  printf(""{"");
  for(int i=0; i<n; i++) {
  printf(""%d, "", A[i]);
  }
  printf(""}\n"");
 }
 int main(int argc, char** argv)
 {
  int cnt=20;
  if (argc>1) {
  cnt = atoi(argv[1]);
  }
  srand(time(NULL)); 
  int expectedMin, actualMin;
  int *a = new int[cnt];
  for(int n=0; n<=cnt; n++) {
  printf(""--------------------------------------\n"");
  for(int i=0; i<cnt; i++){
  a[i]=i;
  }
  expectedMin = a[0];
  //printArray(a, cnt);
  int rotate_pos = random() % cnt;
  //rotate_pos=2;
  printf(""rotate=%d\n"", rotate_pos);
  rotate_array(a, cnt, rotate_pos);
  printArray(a, cnt);
  vector<int> num(a, a+cnt);
  actualMin = findMin(num);
  cout << ""findMin = "" << actualMin << "" "" << (expectedMin==actualMin ? ""passed"" : ""failed"") << endl;
  }
  delete[] a;
  return 0;
 }"
129,129,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 /*
  * Need be very careful for the following cases:
  *
  * [3, 3, 3, 3, 3]
  * 
  * [3, 3, 3, 1, 3]
  *
  */
 int findMin(vector<int> &num) {
  int low=0, high=num.size()-1;
  while(high-low>1){
  //skip the same element, this would cause the O(n) run-time complexity. 
  while (high - low > 1 && num[low] == num[high]){
  low++;
  }
  //binary search
  int mid = low + (high-low)/2;
  //If the array is not rotated then return num[low]
  //Notes: checking the equal situation
  if (num[low] <= num[mid] && num[mid] <= num[high]){
  return num[low];
  }
  //move the high pointer to the middle, if sub-array from low to mid is rotated.
  if (num[low] > num [mid]){
  high = mid;
  continue;
  }
  // move the low pointer to the middle, if sub-array from mid to high is rotated.
  if (num[mid] > num[high]){
  low = mid;
  continue;
  }
  }
  // checking the edge case 
  if (high == low) return num[low];
  return num[low] < num[high] ? num[low] : num[high];
 }
 void rotate_array(int a[], int n, int pos){
  int i, from=0;
  pos = pos % n;
  if (n<=0) return;
  int tmp = a[0];
  for(int i=0, step=0; step<n && i<pos; step++){
  int to;
  if (from-pos < 0) {
  to = n-pos+from; 
  }else{
  to = from-pos;
  }
  int t ;
  t = a[to];
  a[to] = tmp; 
  tmp = t;
  from = to;
  if ( to == i ){
  i++;
  from++;
  tmp = a[from];
  }
  }
 }
 void printArray(int A[], int n) {
  printf(""{"");
  for(int i=0; i<n; i++) {
  printf(""%d, "", A[i]);
  }
  printf(""}\n"");
 }
 int main(int argc, char** argv)
 {
  int cnt=20;
  if (argc>1) {
  cnt = atoi(argv[1]);
  }
  srand(time(NULL)); 
  int expectedMin, actualMin;
  int *a = new int[cnt];
  for(int n=0; n<=cnt; n++) {
  printf(""--------------------------------------\n"");
  //generate the array with random elements
  for(int i=0; i<cnt; i++){
  a[i]=rand()%cnt;
  }
  //sort the array
  sort(a, a+cnt); 
  expectedMin = a[0];
  //printArray(a, cnt);
  int rotate_pos = random() % cnt;
  //rotate_pos=2;
  printf(""rotate=%d\n"", rotate_pos);
  rotate_array(a, cnt, rotate_pos);
  printArray(a, cnt);
  vector<int> num(a, a+cnt);
  actualMin = findMin(num);
  cout << ""findMin = "" << actualMin << "" "" << (expectedMin==actualMin ? ""passed"" : ""failed"") << endl;
  }
  delete[] a;
  return 0;
 }"
130,130,"class Solution {
 public:
  int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
  int result = -1;
  int distance = INT_MAX;
  for(int i=0; i<points.size(); i++) {
  if ( x != points[i][0] && y != points[i][1] ) continue;
  int dist = abs(x - points[i][0]) + abs( y - points[i][1]);
  if ( distance > dist ){
  distance = dist;
  result = i;
  }
  }
  return result;
  }
 };"
131,131,"#include <iostream>
 #include <vector>
 using namespace std;
 /*
  * Binary search is common idea here.
  *
  * However, you need to think about two senarios:
  *
  * 1) Becasue we need check `num[mid-1]`, `num[mid]`, `num[mid+1]`, 
  * So, we need make sure there hasn't out-of-boundary issue.
  * 
  *
  *
  * 2) There are multiple Peak elements.
  *
  * For example: [1,2,1,2,1], or [ 1,2,3,1,2,1]
  *
  * LeetCode doesn't tell you what the expected result is. I guess:
  *
  * 2.1) for [1,2,1,2,1] you can return either 1 or 3, because both them are peak elements
  *
  * 2.1) for [1,2,3,2,4,2,1] it should return 4, because num[4] is the real peak. but Leetcode accept either 2 or 4
  *
  */
 int findPeakElement(const vector<int> &num) {
  int n = num.size();
  int low = 0;
  int high = n - 1;
  int mid = 0, v1, v2;
  while ( low < high ) {
  // Find the index of middle element
  mid = low + ( high - low ) / 2;
  // Compare middle element with its neighbours (if neighbours exist)
  if ( ( mid == 0 || num[mid] > num[mid-1] ) && 
  ( mid == n-1 || num[mid] > num[mid+1] ) ){
  return mid;
  }
  // If middle element is not peak and its left neighbor is greater than it
  // then left half must have a peak element
  if (mid >0 && num[mid-1] > num[mid]){
  high = mid - 1;
  // If middle element is not peak and its right neighbor is greater than it
  // then right half must have a peak element
  }else{
  low = mid + 1;
  }
  }
  return low;
 }
 void printVector(vector<int> &n) {
  cout << ""[ "";
  int i;
  for(i=0; i<n.size(); i++){
  cout << n[i] << (i==n.size()-1 ? "" ]"" : "", "");
  }
  cout << endl;
 }
 void test(int a[], int n) {
  vector<int> v(a, a+n);
  cout << ""Peak Index = "" << findPeakElement(v) << ""\t"";
  printVector(v);
 }
 #define TEST(a) test(a, sizeof(a)/sizeof(a[0]))
 int main(int argc, char**argv)
 {
  int n0[] = {1};
  TEST(n0);
  int n1[] = {1,2};
  TEST(n1);
  int n2[] = {2,1};
  TEST(n2);
  int n3[] = {1,2,3};
  TEST(n3);
  int n4[] = {3,2,1};
  TEST(n4);
  int n5[] = {1,2,3,2};
  TEST(n5);
  int n6[] = {0,1,2,9,7,5,4,2,1};
  TEST(n6);
  int n7[] = {1,2,1,2,1};
  TEST(n7);
  int n8[] = {1,2,1,2,3,1};
  TEST(n8);
  int n9[] = {1,2,3,2,4,2,1};
  TEST(n9);
  int n10[] = {1,3,1,2,1,3,1};
  TEST(n10);
  return 0;
 }"
132,132,"class Solution {
 public:
  char findTheDifference(string s, string t) {
  unordered_map<char, int> m;
  for(auto c : s) m[c]++;
  for(auto c : t) {
  m[c]--;
  if (m[c] < 0) return c;
  }
  return '\0';
  }
 };"
133,133,"class Solution {
 public:
  //
  // This problem can be transfromed to ""Linked List Cycle"" problem.
  // There are two pointers, one goes one step, another goes two steps.
  //
  // Refer to: https://en.wikipedia.org/wiki/Cycle_detection
  //
  int findDuplicate(vector<int>& nums) {
  int n = nums.size();
  int one = n;
  int two = n;
  do{
  one = nums[one-1];
  two = nums[nums[two-1]-1];
  } while(one != two); 
  //find the start point of the cycle
  one = n;
  while(one != two){
  one = nums[one-1];
  two = nums[two-1];
  }
  return one;
  }
 };"
134,134,"class Solution {
 public:
  int largestAltitude(vector<int>& gain) {
  int result = 0;
  int sum = 0;
  for (auto& n : gain) {
  sum += n;
  result = max(result, sum);
  }
  return result;
  }
 };"
135,135,"class Solution {
 public:
  int getWinner(vector<int>& arr, int k) { 
  int left=0, right=1;
  int max = arr[left] > arr[right] ? arr[left] : arr[right];
  int winner; 
  int win_times = 0;
  while( right < arr.size()) {
  //if left < right, the move the `left` to the `right`
  if ( arr[left] < arr[right] ) {
  left = right;
  }
  // move the `right` to next element
  right++;
  //record current round winner.
  int w = arr[left]; 
  if (w == winner) {
  //if winner is same, count++
  win_times++; 
  }else{
  // if winner is new number, reset the count.
  winner = w;
  win_times = 1;
  }
  // if the time of win equal K, return winner. 
  if (win_times >= k) return winner;
  // find the max element of this array, if k > arr.size() then return this
  if (max < arr[right]) max = arr[right];
  }
  return max;
  }
 };"
136,136,"class Solution {
 public:
  int findTheWinner(int n, int k) {
  vector<int> persons(n);
  for(int i=0; i<n; i++) persons[i] = i + 1;
  for(int start=0; n>1; n--){
  start = (start + k -1) % n;
  persons.erase(persons.begin() + start);
  start = start %(n-1);
  }
  return persons[0];
  }
 };"
137,137,"class Solution {
 public:
  vector<vector<int>> restoreMatrix(vector<int>& row, vector<int>& col) {
  int n = row.size();
  int m = col.size();
  if(n==0 ||m==0)
  return {};
  vector<vector<int>> res(n,vector<int>(m,0));
  priority_queue<pair<int,int>> p,q;
  for(int i=0;i<n;i++){
  p.push({row[i],i});
  }
  for(int j=0;j<m;j++){
  q.push({col[j],j});
  }
  while(!q.empty() && !p.empty()){
  auto a = p.top();
  auto b = q.top();
  p.pop();
  q.pop();
  int t = min(a.first,b.first);
  res[a.second][b.second]=t;
  a.first-=t;
  b.first-=t;
  if(a.first>0)
  p.push(a);
  if(b.first>0)
  q.push(b);
  }
  return res;
  }
 };"
138,138,"class Solution {
 public:
  int getXORSum(vector<int>& arr1, vector<int>& arr2) {
  int x = arr1[0];
  for(int i = 1; i < arr1.size(); i++) {
  x ^= arr1[i];
  }
  int y = arr2[0];
  for(int i = 1; i< arr2.size(); i++) {
  y ^= arr2[i];
  }
  return x&y;
  }
 };"
139,139,"// Forward declaration of isBadVersion API.
 bool isBadVersion(int version);
 class Solution {
 public:
  //Binary search
  int firstBadVersion(int n) {
  int low=1, high=n;
  while(low <= high) {
  int mid = low + (high - low)/2;
  if (isBadVersion(mid) && !isBadVersion(mid-1)){
  return mid;
  }
  if (isBadVersion(mid)) {
  high = mid - 1;
  }else{
  low = mid + 1;
  }
  }
  return -1;
  }
 };"
140,140,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <map>
 using namespace std;
 #define INT_MAX 2147483647
 /*
  * Idea:
  * 
  * We can move the num to the place whcih the index is the num. 
  * 
  * for example, (considering the array is zero-based.
  * 1 => A[0], 2 => A[1], 3=>A[2]
  * 
  * Then, we can go through the array check the i+1 == A[i], if not ,just return i+1;
  * 
  * This solution comes from StackOverflow.com
  * http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list
 */
 int firstMissingPositive_move(int A[], int n) {
  if (n<=0) return 1;
  int num;
  for(int i=0; i<n; i++) {
  num = A[i];
  while (num>0 && num<n && A[num-1]!=num) {
  swap(A[i], A[num-1]);
  num = A[i];
  }
  }
  for (int i=0; i<n; i++){
  if (i+1 != A[i]){
  return i+1;
  }
  }
  return n+1;
 }
 /*
  * The idea is simple: 
  *
  * 1) put all of number into a map.
  * 2) for each number a[i] in array, remove its continous number in the map
  * 2.1) remove ... a[i]-3, a[i]-2, a[i]-1, a[i]
  * 2.2) remove a[i]+1, a[i]+2, a[i]+3,...
  * 3) during the removeing process, if some number cannot be found, which means it's missed.
  *
  * considering a case [-2, -1, 4,5,6], 
  * [-2, -1] => missed 0
  * [4,5,6] => missed 3
  *
  * However, we missed 1, so, we have to add dummy number 0 whatever.
  *
  * NOTE: this solution is not constant space slution!!!!
  *
  */
 int firstMissingPositive_map(int A[], int n) {
  map<int, int> cache;
  for(int i=0; i<n; i++){
  cache[A[i]] = i;
  }
  //add dummy
  if (cache.find(0)==cache.end() ) {
  cache[0] = -1;
  }
  int miss = INT_MAX;
  int x;
  for (int i=-1; i<n && cache.size()>0; i++){
  if (i == -1){
  x = 0; //checking dummy
  }else{
  x = A[i];
  } 
  if ( cache.find(x)==cache.end() ){
  continue;
  }
  int num ;
  // remove the ... x-3, x-2, x-1, x
  for( num=x; cache.find(num)!=cache.end(); num--){
  cache.erase(cache.find(num));
  }
  if ( num>0 && num < miss ){
  miss = num;
  }
  // remove the x+1, x+2, x+3 ...
  for ( num=x+1; cache.find(num)!=cache.end(); num++){
  cache.erase(cache.find(num));
  }
  if ( num>0 && num < miss) {
  miss = num;
  }
  }
  return miss;
 }
 int firstMissingPositive(int A[], int n) {
  srand(time(0));
  if (rand()%2){
  return firstMissingPositive_move(A, n);
  }
  return firstMissingPositive_map(A, n);
 }
 void printArray(int a[], int n){
  cout << ""[ "";
  for(int i=0; i<n-1; i++) {
  cout << a[i] << "", "";
  }
  cout << a[n-1] << "" ]"";
 }
 void Test(int a[], int n, int expected) {
  printArray(a, n);
  int ret = firstMissingPositive(a, n);
  cout << ""\t missed = "" << ret << "" "" << (ret==expected?""passed!"":""failed!"") << endl;
  //printArray(a, n);
  //cout <<endl;
 }
 int main()
 {
 #define TEST(a, e) Test(a, sizeof(a)/sizeof(int), e) 
  int a0[]={1};
  TEST(a0, 2);
  int a1[]={1,2,0};
  TEST(a1, 3);
  int a2[]={3,4,-1,1};
  TEST(a2, 2);
  int a3[]={1000,-1};
  TEST(a3, 1);
  int a4[]={1000, 200};
  TEST(a4, 1);
  int a5[]={2,5,3,-1};
  TEST(a5, 1);
  int a6[]={1, 100};
  TEST(a6, 2);
  int a7[]={7,8,9,11};
  TEST(a7, 1);
  int a8[]={4,3,2,1};
  TEST(a8, 5);
  return 0;
 }"
141,141,"class Solution {
 public:
  int firstUniqChar(string s) {
  //As the question mentioned, there only have lower case chars, 
  //so the MAX_CHAR can be defined as 26, but I want this algorithm be more general for all ASCII
  #define MAX_CHAR 256
  #define NOT_FOUND -1
  #define DUPLICATION -2
  // initlize all chars status to NOT_FOUND
  int pos_map[MAX_CHAR];
  memset(pos_map, NOT_FOUND,sizeof(pos_map));
  // if it is the first time to find, set the status to its postion
  // if it is the second time to find, set the status to duplication
  // if it has already duplicated, do nothing 
  for (int i=0; i<s.size(); i++){
  if ( pos_map[s[i]] >= 0 ) {
  pos_map[s[i]] = DUPLICATION;
  }else if ( pos_map[s[i]] == NOT_FOUND ) {
  pos_map[s[i]] = i;
  }
  }
  // find the lowest postion
  int pos = INT_MAX;
  for (auto item : pos_map) {
  cout << item << "","";
  if (item >= 0 && item < pos) {
  pos = item;
  }
  }
  return pos == INT_MAX ? -1 : pos;
  }
 };"
142,142,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  void flatten(TreeNode *root) {
  vector<TreeNode*> v, stack;
  stack.push_back(root);
  while(stack.size()>0){
  TreeNode* node = stack.back();
  stack.pop_back();
  v.push_back(node);
  if (node && node->right){
  stack.push_back(node->right);
  }
  if (node && node->left){
  stack.push_back(node->left);
  }
  }
  v.push_back(NULL);
  for(int i=0; i<v.size(); i++){
  if (v[i]){
  v[i]->left = NULL;
  v[i]->right = v[i+1];
  }
  }
  }
 };"
143,143,"/**
  * // This is the interface that allows for creating nested lists.
  * // You should not implement it, or speculate about its implementation
  * class NestedInteger {
  * public:
  * // Return true if this NestedInteger holds a single integer, rather than a nested list.
  * bool isInteger() const;
  *
  * // Return the single integer that this NestedInteger holds, if it holds a single integer
  * // The result is undefined if this NestedInteger holds a nested list
  * int getInteger() const;
  *
  * // Return the nested list that this NestedInteger holds, if it holds a nested list
  * // The result is undefined if this NestedInteger holds a single integer
  * const vector<NestedInteger> &getList() const;
  * };
  */
 class NestedIterator {
 private:
  vector<int> v;
  int index;
  void flatten(vector<NestedInteger> &nestedList) {
  for (auto item : nestedList){
  if (item.isInteger()){
  v.push_back( item.getInteger() );
  }else{
  flatten( item.getList() );
  }
  }
  }
 public:
  NestedIterator(vector<NestedInteger> &nestedList) {
  flatten(nestedList);
  index = 0;
  }
  int next() {
  return v[index++];
  }
  bool hasNext() {
  return (index < v.size() );
  }
 };
 /**
  * Your NestedIterator object will be instantiated and called as such:
  * NestedIterator i(nestedList);
  * while (i.hasNext()) cout << i.next();
  */"
144,144,"class Solution {
 public:
  bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {
  //constructing an length array
  // lens[0] = len(groups[0]) + len(groups[1]) + ... len(groups[n])
  // lens[1] = len(groups[1]) + len(groups[2]) + ... len(groups[n])
  // lens[2] = len(groups[2]) + len(groups[3]) + ... len(groups[n])
  // lens[n] = len(groups[n])
  //so that, we can quickly know whether there still has enough room to match rest groups
  vector<int> lens(groups.size());
  int total_len=0;
  for(int i=groups.size()-1; i >=0; i--) {
  total_len += groups[i].size();
  lens[i] = total_len;
  }
  // index i - loop for groups[]
  // index j - loop for nums[]
  int i = 0, j = 0; 
  while ( i < groups.size() && j < nums.size() ) {
  //if the rest room is not enought to match, return false;
  if (nums.size() - j < lens[i]) return false;
  //if the first char is not matched, check the next.
  if ( nums[j] != groups[i][0]) {
  j++;
  continue;
  }
  //if the first char is matched, then check the groups[i]
  bool match = true;
  for(int k=0; k<groups[i].size(); k++) {
  if ( nums[j+k] != groups[i][k]) {
  match=false;
  break;
  }
  }
  // if the groups[i] is matched, then go to next group
  if (match) {
  j += groups[i].size();
  i++;
  }else{
  j++; 
  }
  }
  return i == groups.size();
  }
 };"
145,145,"#include <stdlib.h>
 #include <iostream>
 #include <sstream>
 #include <string>
 #include <map>
 using namespace std;
 /*
  * Be careful the following cases:
  *
  * > 0/2
  * > 1/0
  * > 1/3
  * > 2/4
  * > 100/2
  * > 100/3
  * > 1/-4
  * > -1/4
  * > -1/-4
  * > 25/99 = 0.25252525....
  * > 1/7 = 0.142857142857...
  * > 1/17 = 0.(0588235294117647)
  */
 string fractionToDecimal(int numerator, int denominator) {
  string result;
  //deal with the `ZERO` cases
  if (denominator == 0){ return result; }
  if (numerator == 0) { return ""0""; }
  //using long long type make sure there has no integer overflow
  long long n = numerator;
  long long d = denominator;
  //deal with negtive cases 
  bool sign = ((float)numerator/denominator >= 0);
  if ( n < 0 ){ n = -n; }
  if ( d < 0 ){ d = -d; }
  if (sign == false){
  result.push_back('-');
  }
  long long remainder = n % d;
  long long division = n / d;
  ostringstream oss;
  oss << division;
  result += oss.str();
  if (remainder == 0){
  return result;
  }
  //remainder has value, the result is a float
  result.push_back('.');
  //using a map to record all of reminders and their position.
  //if the reminder appeared before, which means the repeated loop begin, 
  //then, get the place from map to insert ""("".
  //(In C++11, it's better to use unordered_map )
  map<long long, int> rec;
  for (int pos=result.size(); remainder!=0; pos++, remainder=(remainder*10)%d ) {
  if (rec.find(remainder) != rec.end()) {
  result.insert(result.begin()+rec[remainder], '(');
  result.push_back(')');
  return result;
  }
  rec[remainder] = pos;
  result.push_back((remainder*10)/d + '0');
  }
  return result;
 }
 void test(int num, int deno)
 {
  cout << ""numerator: "" << num << ""\tdenominator: "" << deno << ""\tresult: "" << fractionToDecimal(num, deno) << endl;
 }
 int main(int argc, char** argv)
 {
  test(1, 2);
  test(10, 2);
  test(100, 2);
  test(1, 3);
  test(100, 3);
  test(1, 6);
  test(100, 6);
  test(-1, 4);
  test(1, -3);
  test(-1, -6);
  test(25, 99);
  test(1, 7);
  test(10, 7);
  test(100, 7);
  test(1, 17);
  test(1, 1024);
  test( -2147483648, -1999);
  test(-1, -2147483648);
  if (argc > 2) {
  int num = atoi(argv[1]);
  int deno = atoi(argv[2]);
  test(num, deno);
  }
  return 0;
 }"
146,146,"class Solution {
 public:
  int maxFrequency(vector<int>& nums, int k) {
  sort(nums.begin(), nums.end());
  int m = 1;
  int start = 0;
  int i = 1;
  for(; i<nums.size(); i++){
  long delta = nums[i] - nums[i-1];
  k -= delta * (i - start);;
  if (k < 0 ) {
  // remove the first one
  k += (nums[i] - nums[start]) ;
  start++;
  }
  m = max(m, i - start +1);
  }
  return m;
  }
 };"
147,147,"class Solution {
 public:
  // -----------------------------------------------------------------------------
  //DFS solution is quite easy to understand, just like the ""Number of Island""
  int findCircleNum_DFS(vector<vector<int>>& M) {
  int n = 0;
  for (int i=0; i<M.size(); i++) {
  for (int j=0; j<M[0].size(); j++) {
  if ( M[i][j] == 1 ) {
  n++;
  M[i][j] = 2;
  mark(M, j);
  }
  }
  }
  return n;
  }
  void mark(vector<vector<int>>& M, int i ) {
  for ( int j=0; j<M[i].size(); j++ ){
  if ( M[i][j] == 1 ) {
  M[i][j] = 2;
  mark(M, j);
  }
  }
  }
  // -----------------------------------------------------------------------------
  //Union Find Solution
  int findCircleNum_UF(vector<vector<int>>& M) {
  vector<int> relations(M.size());
  for (int i=0; i<relations.size(); i++){
  relations[i] = i;
  }
  int n = M.size(); //by default, there are N friend cicles
  for (int i=0; i<M.size(); i++) {
  for (int j=0; j<M[0].size(); j++) {
  if ( M[i][j] == 1 && i != j ) {
  if ( join(relations, i, j) ) n--;
  }
  }
  }
  return n;
  }
  //find the tail node.
  // if a -> b -> c -> d, then find(a),find(b) or find(c) would return d;
  int find(vector<int>& relations, int i ) {
  while( relations[i] != i ) {
  i = relations[i];
  }
  return i;
  }
  // join the x cicle with y cicle,
  // if x and y are already in same friend cicle, then return false, else return true;
  bool join(vector<int> &relations, int x, int y) {
  int tx = find(relations, x);
  int ty = find(relations, y);
  if ( tx != ty ) relations[tx] = ty;
  return tx != ty;
  }
  // -----------------------------------------------------------------------------
  int findCircleNum(vector<vector<int>>& M) {
  return findCircleNum_UF(M);
  return findCircleNum_DFS(M);
  }
 };"
148,148,"class Solution {
 public:
  bool canCross_recursion(vector<int>& stones, int curr, int last_jump) {
  for(int i=curr+1; i<stones.size(); i++){
  int next_jump = stones[i] - stones[curr];
  //the minimal jump is far exceed the current node, go to check next node.
  if (next_jump < last_jump - 1) continue;
  //cannot reach this one, then simple reture false;
  if (next_jump > last_jump + 1) return false;
  if (i == stones.size() - 1 || canCross_recursion(stones, i, next_jump)) return true;
  }
  return false;
  }
  bool canCross_recursion_with_cache(vector<int>& stones, int curr, int last_jump, 
  unordered_map<int, unordered_map<int, bool>>& cache) 
  {
  //check the cache is hitted ?
  if (cache.find(curr) != cache.end() && cache[curr].find(last_jump)!=cache[curr].end()) {
  return cache[curr][last_jump];
  }
  for(int i=curr+1; i<stones.size(); i++){
  int next_jump = stones[i] - stones[curr];
  if (next_jump < last_jump - 1) continue;
  if (next_jump > last_jump + 1) break;
  if (i == stones.size() - 1 || canCross_recursion_with_cache(stones, i, next_jump, cache)) {
  cache[curr][last_jump] = true;
  return true;
  }
  }
  cache[curr][last_jump] = false;
  return false;
  }
  bool canCross_non_recursion(vector<int>& stones) {
  // the `jumps` map store the all possible `last jumps`
  unordered_map<int, unordered_set<int>> jumps = {{0, {0}}};
  for(int i=0; i<stones.size(); i++) {
  if (jumps.find(i) == jumps.end()){ 
  continue;
  }
  //for each possible last jump which reach the current node.
  for(int last_jump : jumps[i]) {
  //find the next nodes can be reached.
  for (int j=i+1; j < stones.size(); j++) {
  //ingore the rest node which cannot be reached
  if (stones[i] + last_jump + 1 < stones[j]) break;
  // evaluated three possbile jumps for next node 
  for (int next_jump = last_jump - 1; next_jump <= last_jump + 1; next_jump++) {
  if ( stones[i] + next_jump == stones[j] ) {
  jumps[j].insert(next_jump);
  }
  }
  }
  }
  }
  return jumps.find(stones.size()-1)!=jumps.end();
  }
  bool canCross(vector<int>& stones) {
  //Burst Force solution -- accepted ~500ms
  return canCross_non_recursion(stones);
  //DFS with cache solution - accepted ~160ms
  unordered_map<int, unordered_map<int, bool>> cache;
  return canCross_recursion_with_cache(stones, 0, 0, cache);
  // Time Limit Error 
  return canCross_recursion(stones, 0, 0); 
  }
 };"
149,149,"class Solution {
 public:
  // the problem here is we need store two states in one cell,
  // one is the original state, another is the new state
  // So, we could store the state into the bit.
  // - Old State: the first bit from the right
  // - New State: the second bit from the right
  void liveCheck(vector<vector<int>>& board, int r, int c) {
  int cnt = 0;
  for (int i=r-1; i<=r+1; i++) {
  if (i < 0 || i>=board.size()) continue;
  for (int j=c-1; j<=c+1; j++) {
  if (j<0 || j>=board[0].size() || (i==r && j==c)) continue;
  if ( board[i][j] & 1 ) cnt++;
  }
  }
  //live -> die
  //if (board[r][c]==1 && (cnt < 2 || cnt > 3)) board[r][c] = 1;
  //live -> live
  if ( board[r][c] == 1 && (cnt == 2 || cnt == 3) ) board[r][c] = 3;
  //die -> live
  if ( board[r][c] == 0 && cnt == 3 ) board[r][c] = 2;
  }
  void gameOfLife(vector<vector<int>>& board) {
  for (int i=0; i<board.size(); i++) {
  for (int j=0; j<board[0].size(); j++) {
  liveCheck(board, i, j);
  }
  }
  for (int i=0; i<board.size(); i++) {
  for (int j=0; j<board[0].size(); j++) {
  board[i][j] >>= 1;
  }
  }
  }
 };"
150,150,"class Solution {
 public:
  int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
  int current = 0;
  int start = gas.size(); //start from the end to beginning
  int total = 0;
  do {
  if (total + gas[current] - cost[current] >= 0) {
  total += (gas[current] - cost[current]);
  current++; // can go from current to current+1
  }else{
  start--; //not enough gas, try to start the one before origin start point.
  total += (gas[start] - cost[start]);
  }
  } while(current != start);
  return total>=0 ? start % gas.size() : -1;
  }
 };"
151,151,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 void generator(vector<string>& result, int left, int right, string s);
 vector<string> generateParenthesis(int n) {
  vector<string> result;
  string s;
  generator(result, n, n, s);
  return result;
 }
 void generator(vector<string>& result, int left, int right, string s){
  if (left==0 && right==0){
  result.push_back(s);
  return;
  }
  if (left>0){
  generator(result, left-1, right, s+'(');
  }
  if (right>0 && right>left){
  generator(result, left, right-1, s+')');
  }
 }
 void printResult(vector<string>& result)
 {
  for(int i=0; i<result.size(); i++){
  cout << result[i] <<endl;
  }
 }
 int main(int argc, char** argv) 
 {
  int n=3;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector<string> r = generateParenthesis(n);
  printResult(r);
  return 0;
 }"
152,152,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 /*
  * I designed the following stupid algorithm base on the blow observation
  * 
  * I noticed I can use a `mirror-like` binary tree to figure out the gray code.
  * 
  * For example:
  * 
  * 0 
  * __/ \__ 
  * 0 1 
  * / \ / \ 
  * 0 1 1 0
  * So, the gray code as below: (top-down, from left to right)
  *
  * 0 0 0 
  * 0 0 1
  * 0 1 1
  * 0 1 0
  * 
  * 0
  * _____/ \_____
  * 0 1
  * __/ \__ __/ \__
  * 0 1 1 0
  * / \ / \ / \ / \
  * 0 1 1 0 0 1 1 0
  * 
  * So, the gray code as below:
  *
  * 0 0 0 0 
  * 0 0 0 1
  * 0 0 1 1
  * 0 0 1 0
  * 0 1 1 0
  * 0 1 1 1 
  * 0 1 0 1
  * 0 1 0 0
  */
 vector<int> grayCode01(int n) {
  vector<int> v;
  //n = 1<<n;
  int x =0; 
  v.push_back(x); 
  for(int i=0; i<n; i++){
  int len = v.size();
  for (int j=0; j<len; j++){
  x = v[j]<<1;
  if (j%2==0){
  v.push_back(x);
  v.push_back(x+1);
  }else{
  v.push_back(x+1);
  v.push_back(x);
  }
  }
  v.erase(v.begin(), v.begin()+len);
  }
  return v;
 }
 /*
  * Actually, there is a better way.
  * The mathematical way is: (num >> 1) ^ num; 
  * Please refer to http://en.wikipedia.org/wiki/Gray_code
  */
 vector<int> grayCode02(int n) {
  vector<int> ret; 
  int size = 1 << n; 
  for(int i = 0; i < size; ++i) {
  ret.push_back((i >> 1)^i); 
  }
  return ret; 
 }
 //random invoker
 vector<int> grayCode(int n) {
  srand(time(0));
  if (rand()%2){
  return grayCode01(n);
  }
  return grayCode02(n);
 }
 void printBits(int n, int len){
  for(int i=len-1; i>=0; i--) {
  if (n & (1<<i)) {
  printf(""1"");
  }else{
  printf(""0"");
  }
  }
 }
 void printVector(vector<int>& v, int bit_len)
 {
  vector<int>::iterator it;
  for(it=v.begin(); it!=v.end(); ++it){
  //bitset<bit_len> bin(*it);
  printBits(*it, bit_len);
  cout << "" "";
  //cout << *it << "" "";
  }
  cout << endl;
 }
 int main(int argc, char** argv)
 {
  int n = 2;
  if (argc>1){
  n = atoi(argv[1]); 
  }
  vector<int> v = grayCode(n);
  printVector(v, n);
  return 0;
 }"
153,153,"class Solution {
 private:
  // Euclidean algorithm
  // https://en.wikipedia.org/wiki/Euclidean_algorithm
  // recursive way
  int findGCD_r(int a, int b) {
  if (a == 0)
  return b;
  return gcd(b % a, a);
  }
  // non-recursive way
  int findGCD(int a, int b) {
  int t = 1;
  while(t != 0) {
  t = a % b;
  a = b;
  b = t;
  }
  return a;
  }
  bool isStrRepeatByLen(string& s, int len) {
  if (s.size() == len) return true;
  if (s.size() % len != 0 ) return false;
  for (int l=0; l<len; l++) {
  for (int i=1; i<s.size()/len; i++) {
  if (s[l] != s[i*len+l]) return false;
  }
  }
  return true;
  }
  bool strPrefixComp(string& s1, string &s2, int len){
  for(int i=0; i<len; i++) {
  if (s1[i] != s2[i]) return false;
  }
  return true;
  }
 public:
  string gcdOfStrings(string s1, string s2) {
  int gcd = findGCD(s1.size(), s2.size());
  if (strPrefixComp(s1, s2, gcd) &&
  isStrRepeatByLen(s1, gcd)&&
  isStrRepeatByLen(s2, gcd) ){
  return s2.substr(0,gcd);
  }
  return """";
  }
 };"
154,154,"/* 
  * Solutions
  * =========
  *
  * A simple solution would be to sort the vector and then run through it starting with
  * the last element. At every step we need to check whether this element is not less than
  * the remaining number of elements bigger than it(including itself) and all the values of
  * the other elements smaller than it are not more than that number. The h_index is this
  * number of elements bigger than it(including itself).
  * 
  * Time Complexity: O(N log N)
  * Space Complexity: O(1)
  * 
  */
 #include <algorithm>
 class Solution {
 public:
  int hIndex(vector<int>& citations) {
  return hIndex02(citations);
  return hIndex01(citations);
  }
  int hIndex01(vector<int>& citations) {
  sort(citations.begin(), citations.end());
  int h_index = 0;
  for(int i = citations.size() - 1; i >= 0; i--)
  if(citations[i] >= citations.size() - i && (i - 1 < 0 || citations[i - 1] <= citations.size() - i))
  h_index = citations.size() - i;
  return h_index;
  }
  // same solution but a bit different implemtation
  int hIndex02(vector<int>& citations) {
  sort(citations.begin(), citations.end());
  int n = citations.size();
  for (int i=0; i<n; i++){
  if (citations[i] >= n-i){
  return n-i;
  }
  }
  return 0;
  }
 };"
155,155,"class Solution {
 public:
  // binary search - O(log(n))
  int hIndex(vector<int>& citations) {
  int n = citations.size();
  int low = 0, high = n-1;
  while( low <= high ) {
  int mid = low + (high-low)/2;
  if (citations[mid] == n - mid) {
  return n - mid;
  }else if (citations[mid] > n-mid){
  high = mid - 1;
  }else {
  low = mid + 1;
  }
  }
  return n-low;
  }
 };"
156,156,"#include <stdlib.h>
 #include <iostream>
 #include <map>
 using namespace std;
 int squares(int n) {
  int result = 0;
  int sq = 0;
  for (; n>0; n/=10) {
  sq = n%10;
  result += (sq * sq);
  }
  return result;
 }
 bool isHappy(int n) {
  if (n==1) return true;
  map<int, bool> m;
  m[n]=true;
  while (n!=1) {
  n = squares(n);
  //cout << n << endl;
  if (m.find(n) != m.end()){
  return false;
  }
  m[n] = true;
  }
  return true;
 }
 int main(int argc, char** argv) 
 {
  int n = 2;
  if (argc > 1){
  n = atoi(argv[1]);
  }
  cout << n << (isHappy(n) ? "" is "" : "" isn't "") << ""a happy number"" << endl;
  return 0;
 }"
157,157,"#include <time.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std; 
 /*
  * Dynamic Programming
  *
  * We can easy find the recurive fomular:
  *
  * dp[n] = max( 
  * dp[n-1], // the previous house has been robbed. 
  * dp[n-2] + money[n] // the previous house has NOT been robbed.
  * )
  * 
  * The initalization is obvious:
  * dp[1] = money[1]
  * dp[2] = max(money[1], money[2])
  *
  */
 int rob1(vector<int> &money) {
  int n = money.size();
  if (n==0) return 0;
  vector<int> dp(n, 0);
  if (n>=1) dp[0] = money[0];
  if (n>=2) dp[1] = max(money[0], money[1]);
  for (int i=2; i<n; i++){
  dp[i] = max(dp[i-1], dp[i-2] + money[i]);
  }
  return dp[n-1];
 }
 /*
  * Acutally, we no need to allocate an additional array for DP.
  * we can only use several variables to record previous steps
  */
 int rob2(vector<int> &money) {
  int n2=0; // dp[i-2];
  int n1=0; // dp[i-1];
  for (int i=0; i<money.size(); i++){
  int current = max(n1, n2 + money[i]);
  n2 = n1;
  n1 = current;
  }
  return n1;
 }
 int rob(vector<int> &num) {
  if (rand()%2)
  return rob1(num);
  return rob2(num);
 }
 void printVector( vector<int> &v ){
  cout << '[' ;
  for(int i=0; i<v.size(); i++){
  cout << v[i] << (i==v.size()-1 ? "" "" :"", "");
  }
  cout << ']' << endl;
 }
 int main(int argc, char** argv) {
  srand(time(0));
  vector<int> money;
  if (argc>1){
  for (int i=1; i<argc; i++) {
  money.push_back(atoi(argv[i]));
  }
  }else{
  money.push_back(2);
  money.push_back(1);
  money.push_back(3);
  money.push_back(4);
  }
  printVector(money);
  cout << rob(money) << endl;
 }"
158,158,"class Solution {
 public:
  int orginal_rob(vector<int> &money, int start, int end) {
  int n2=0; 
  int n1=0; 
  for (int i=start; i<end; i++){
  int current = max(n1, n2 + money[i]);
  n2 = n1;
  n1 = current;
  }
  return n1;
  }
  int rob(vector<int>& nums) {
  int n = nums.size();
  switch (n) {
  case 0:
  return 0;
  case 1:
  return nums[0];
  case 2:
  return max(nums[0], nums[1]);
  default:
  /*
  * the idea is we cannot rob[0] and rob[n-1] at same time
  * so, we rob [0 .. n-2] or [1 .. n-1], can return the maxinum one.
  */
  int m1 = orginal_rob(nums, 0, n-1);
  int m2 = orginal_rob(nums, 1, n);
  return max(m1, m2);
  }
  }
 };"
159,159,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
  /* 
  * Solution 1 - O(N log N)
  * =========
  *
  * We can use a recursive function that computes the solution for every node of the tree 
  * using the previous solutions calculated for the left and right subtrees. At every step
  * we have 2 options:
  *
  * 1) Take the value of the current node + the solution of the left and right subtrees of
  * each of the left and right children of the current node.
  * 2) Take the solution of the left and right subtrees of the current node, skipping over
  * its value.
  *
  * This way we can make sure that we do not pick 2 adjacent nodes.
  *
  * If we implemented this right away we would get TLE. Thus, we need to optimize the
  * algorithm. One key observation would be that we only need to compute the solution for
  * a certain node once. We can use memoization to calculate every value once and then
  * retrieve it when we get subsequent calls. As the header of the recursive function
  * doesn't allow additional parameters we can use a map to link every node(a pointer) to
  * its solution(an int). For every call the map lookup of an element and its insertion
  * take logarithmic time and there are a constant number of calls for each node. Thus, the
  * algorithm takes O(N log N) time to finish.
  * 
  */
 class Solution {
 public:
  map<TreeNode*, int> dict;
  int rob(TreeNode* root) {
  if(root == NULL)
  return 0;
  else if(dict.find(root) == dict.end())
  {
  int lwith = rob(root->left);
  int rwith = rob(root->right);
  int lwithout = 0, rwithout = 0;
  if(root->left != NULL)
  lwithout = rob(root->left->left) + rob(root->left->right);
  if(root->right != NULL)
  rwithout = rob(root->right->left) + rob(root->right->right);
  //cout << lwith << "" "" << rwith << "" "" << lwithout << "" "" << rwithout << '\n';
  dict[root] = max(root->val + lwithout + rwithout, lwith + rwith);
  }
  return dict[root];
  }
 };
 // Another implementation - Hao Chen
 class Solution {
 public:
  int max(int a, int b) {
  return a > b ? a: b;
  }
  int max(int a, int b, int c) {
  return max(a, max(b,c));
  }
  int max(int a, int b, int c, int d) {
  return max(a, max(b, max(c,d)));
  }
  void rob_or_not(TreeNode* root, int& max_robbed, int& max_not_robbed) {
  // NULL room return 0;
  if (root == NULL) {
  max_robbed = max_not_robbed = 0;
  return ;
  }
  // we have two options, rob current room or not.
  int max_left_robbed, max_left_not_robbed;
  int max_right_robbed, max_right_not_robbed;
  rob_or_not(root->left, max_left_robbed, max_left_not_robbed);
  rob_or_not(root->right, max_right_robbed, max_right_not_robbed);
  // If root is robbed, then both left and right must not be robbed.
  max_robbed = root->val + max_left_not_robbed + max_right_not_robbed;
  // If root is not robbed, then 4 combinations are possible:
 // left is robbed or not and right is either robbed or not robbed,
  max_not_robbed = max(max_left_robbed + max_right_robbed,
  max_left_robbed + max_right_not_robbed,
  max_left_not_robbed + max_right_robbed,
  max_left_not_robbed + max_right_not_robbed);
  }
  int rob(TreeNode* root) {
  int robbed, not_robbed;
  rob_or_not(root, robbed, not_robbed);
  return max(robbed, not_robbed);
  }
 };"
160,160,"* Depending on your language, stack may not be supported natively. You may simulate a 
  * stack by using a list or deque (double-ended queue), as long as you use only 
  * standard operations of a stack.
  * You may assume that all operations are valid (for example, no pop or peek operations 
  * will be called on an empty queue).
  * 
  **********************************************************************************/
 class Queue {
 public:
  // Push element x to the back of queue.
  void push(int x) {
  s1.push(x);
  }
  // Removes the element from in front of queue.
  void pop(void) {
  transfer(s1, s2);
  s2.pop();
  transfer(s2, s1);
  }
  // Get the front element.
  int peek(void) {
  transfer(s1, s2);
  int ret = s2.top();
  transfer(s2, s1);
  return ret;
  }
  // Return whether the queue is empty.
  bool empty(void) {
  return s1.empty();
  }
 private:
  stack<int> s1, s2;
  void transfer(stack<int>& s1, stack<int>& s2) {
  while(!s1.empty()){
  s2.push(s1.top());
  s1.pop();
  }
  }
 };"
161,161,"class Stack {
  public:
  // Push element x onto stack.
  void push(int x) {
  nums.push(x);
  }
  // Removes the element on top of the stack.
  void pop() {
  if (!empty()) {
  int len = nums.size()-1;
  //Don't treat the ""-->"" is a new operator. ;-)
  while ( len-->0) {
  nums.push(nums.front());
  nums.pop();
  }
  nums.pop();
  }
  }
  // Get the top element.
  int top() {
  return nums.back();
  }
  // Return whether the stack is empty.
  bool empty() {
  return nums.empty();
  }
  private:
  queue<int> nums;
 };"
162,162,"class TrieNode {
 public:
  // Initialize your data structure here.
  TrieNode():isWord(false) { }
  unordered_map<char, TrieNode*> children;
  bool isWord;
 };
 class Trie {
 public:
  Trie() {
  root = new TrieNode();
  }
  // Inserts a word into the trie.
  void insert(string s) {
  if (s.size()<=0) return;
  TrieNode * node = root;
  for (int i=0; i<s.size(); i++) {
  if (node->children.find(s[i]) == node->children.end()){
  node->children[s[i]] = new TrieNode();
  }
  node = node->children[s[i]];
  }
  node->isWord = true;
  }
  // Returns if the word is in the trie.
  bool search(string key) {
  return retrieve(key, true);
  }
  // Returns if there is any word in the trie
  // that starts with the given prefix.
  bool startsWith(string prefix) {
  return retrieve(prefix, false);
  }
 private:
  inline bool retrieve(const string& key, bool isWord) {
  if (key.size() <= 0) return false;
  TrieNode * node = root;
  for (int i=0; i<key.length(); i++) {
  if (node->children.find(key[i]) == node->children.end()) {
  return false;
  }
  node = node->children[key[i]];
  }
  return isWord ? node->isWord : true;
  }
  TrieNode* root;
 };
 // Your Trie object will be instantiated and called as such:
 // Trie trie;
 // trie.insert(""somestring"");
 // trie.search(""key"");"
163,163,"class Solution {
 public:
  bool increasingTriplet(vector<int>& nums) {
  bool solution = false;
  if(nums.size())
  {
  int first = nums[0];
  int second = 0x7fffffff; //MAX_INT so we can always find something smaller than it
  for(int i = 1; i < nums.size() && !solution; i++)
  {
  if(nums[i] > second)
  solution = true;
  else if(nums[i] > first && nums[i] < second)
  second = nums[i];
  else if(nums[i] < first)
  first = nums[i];
  }
  }
  return solution;
  }
 };
 //Hao Chen's implementation
 class Solution {
 public:
  bool increasingTriplet(vector<int>& nums) {
  if (nums.size() < 3) return false;
  int first=INT_MAX, second = INT_MAX;
  for(int i=0; i<nums.size(); i++) {
  if ( first > nums[i] ) {
  first = nums[i];
  }else if ( first < nums[i] && nums[i] < second) {
  second = nums[i];
  }else if (nums[i] > second){
  return true;
  }
  }
  return false;
  }
 };"
164,164,"class Solution {
 public:
  vector<int> memLeak(int memory1, int memory2) {
  int i=0;
  while(++i) {
  int& himem = memory1 >= memory2 ? memory1 : memory2;
  if (himem < i) break;
  himem -= i;
  }
  vector<int> result={i, memory1, memory2};
  return result;
  }
 };"
165,165,"class RandomizedSet {
 public:
  /** Initialize your data structure here. */
  RandomizedSet() {
  srand(time(NULL));
  }
  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
  bool insert(int val) {
  if ( find(val) ) return false; 
  data.push_back(val);
  valpos[val] = data.size() - 1;
  return true;
  }
  /** Removes a value from the set. Returns true if the set contained the specified element. */
  bool remove(int val) {
  if ( !find(val) ) return false; 
 /*
  * Tricky
  * ------
  * 1) Copy the data from the last one to the place need be removed.
  * 2) Remove the last one.
  */
  int _idx = valpos[val];
  int _val = data.back();
  data[_idx] = _val;
  valpos[_val] = _idx;
  valpos.erase(val);
  data.pop_back();
  return true;
  }
  /** Get a random element from the set. */
  int getRandom() {
  return data[ rand() % data.size() ];
  }
 private: 
  unordered_map<int, int> valpos; //value position map
  vector<int> data;
  bool find(int val) {
  return (valpos.find(val) != valpos.end());
  }
 };
 /**
  * Your RandomizedSet object will be instantiated and called as such:
  * RandomizedSet obj = new RandomizedSet();
  * bool param_1 = obj.insert(val);
  * bool param_2 = obj.remove(val);
  * int param_3 = obj.getRandom();
  */"
166,166,"class RandomizedCollection {
 public:
  /** Initialize your data structure here. */
  RandomizedCollection() {
  srand(time(NULL));
  }
  /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
  bool insert(int val) {
  data.push_back(val);
  valpos[val].insert( data.size() - 1 );
  return (valpos[val].size() == 1);
  }
  /** Removes a value from the collection. Returns true if the collection contained the specified element. */
  bool remove(int val) {
  // not found
  if (!find(val)) return false;
  //same idea with non-duplication version, but need be careful with some edge case
  int _idx = *(valpos[val].begin());
  int _val = data.back();
  valpos[_val].insert(_idx);
  data[_idx] = _val;
  valpos[val].erase(_idx);
  if (valpos[val].size()==0){
  valpos.erase(val);
  }
  data.pop_back();
  if ( _idx < data.size() ){
  valpos[_val].erase(data.size());
  valpos[_val].insert(_idx);
  }
  return true; 
  }
  /** Get a random element from the collection. */
  int getRandom() {
  return data[ rand() % data.size() ];
  }
 private:
  unordered_map<int, unordered_set<int>> valpos; //value position map
  vector<int> data;
  bool find(int val) {
  return (valpos.find(val) != valpos.end());
  }
 };
 /**
  * Your RandomizedCollection object will be instantiated and called as such:
  * RandomizedCollection obj = new RandomizedCollection();
  * bool param_1 = obj.insert(val);
  * bool param_2 = obj.remove(val);
  * int param_3 = obj.getRandom();
  */"
167,167,"#include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 struct Interval {
  int start;
  int end;
  Interval() : start(0), end(0) {}
  Interval(int s, int e) : start(s), end(e) {}
 };
 //Two factors sorting [start:end]
 bool compare(const Interval& lhs, const Interval& rhs){
  return (lhs.start==rhs.start) ? lhs.end < rhs.end : lhs.start < rhs.start;
 }
 vector<Interval> merge(vector<Interval> &intervals) {
  vector<Interval> result;
  if (intervals.size() <= 0) return result;
  //sort the inervals. Note: using the customized comparing function.
  sort(intervals.begin(), intervals.end(), compare);
  for(int i=0; i<intervals.size(); i++) {
  int size = result.size();
  // if the current intervals[i] is overlapped with previous interval.
  // merge them together
  if( size>0 && result[size-1].end >= intervals[i].start) {
  result[size-1].end = max(result[size-1].end, intervals[i].end);
  }else{
  result.push_back(intervals[i]);
  }
  }
  return result;
 }
 //just reuse the solution of ""Merge Intervals"", quite straight forward
 vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
  intervals.push_back(newInterval);
  return merge(intervals);
 }
 int main(int argc, char**argv)
 {
  Interval i1(1,2);
  Interval i2(3,5);
  Interval i3(6,7);
  Interval i4(8,10);
  Interval i5(12,16);
  vector<Interval> intervals;
  intervals.push_back(i1);
  intervals.push_back(i2);
  intervals.push_back(i3);
  intervals.push_back(i4);
  intervals.push_back(i5);
  Interval n(4,9);
  vector<Interval> r = insert(intervals, n);
  for(int i=0; i<r.size(); i++){
  cout << ""[ "" << r[i].start << "", "" << r[i].end << "" ] "";
  }
  cout <<endl;
  return 0;
 }"
168,168,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *insertionSortList(ListNode *head) {
  // zero or one element in list
  if (head == NULL || head->next ==NULL){
  return head;
  }
  ListNode *pSorted = NULL;
  while ( head != NULL ){
  /* remember the head */
  ListNode *pHead = head;
  /* trailing pointer for efficient splice */
  ListNode **ppTrail = &pSorted;
  /* pop head off list */
  head = head->next;
  /* splice head into sorted list at proper place */
  while( *ppTrail!=NULL && pHead->val > (*ppTrail)->val ) {
  ppTrail = &(*ppTrail)->next;
  }
  pHead->next = *ppTrail;
  *ppTrail = pHead;
  }
  return pSorted;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main(int argc, char** argv)
 {
  int n = 10;
  if (argc>1){
  n = atoi(argv[1]);
  }
  srand(time(NULL));
  int *a = new int[n];
  for(int i=0; i<n; i++){
  a[i] = random()%n + 1;
  }
  ListNode *p = createList(a, n);
  printList(p);
  printList(insertionSortList(p));
  delete[] a;
 }"
169,169,"class Solution {
 public:
  // As the hint said, checking the n with ranging from 7 to 10 to discover the regularities.
  // n = 7, 3*4 = 12
  // n = 8, 3*3*2 = 18
  // n = 9, 3*3*3 = 27
  // n = 10, 3*3*4 = 36
  // n = 11, 3*3*3*2 = 54
  //
  // we can see we can break the number by 3 if it is greater than 4;
  //
  int integerBreak(int n) {
  if ( n == 2 ) return 1;
  if ( n == 3 ) return 2;
  int result = 1;
  while( n > 4 ) {
  result *= 3;
  n -= 3;
  }
  result *= n;
  return result;
  }
 };
 // DP
 class Solution {
 public:
  int integerBreak(int n) {
  vector<int> dp(n+1,1);
  for(int i=2;i<=n;i++){
  for(int j=1;j<=i/2;j++){
  dp[i] = max(dp[i],max(dp[j],j)*max(dp[i-j],i-j));
  }
  }
  return dp[n];
  }
 };"
170,170,"class Solution {
 public:
  int integerReplacement_recursion(int n) {
  if ( n <= 1) return 0; // recursive exited point
  if ( n == INT_MAX ) return 32; // special case to avoid integer overflow.
  if ( n % 2 == 0 ) return integerReplacement(n/2) + 1;
  return min( integerReplacement(n+1), integerReplacement(n-1) ) + 1;
  }
  int integerReplacement_recursionWithCache(int n) {
  static unordered_map<int, int> cache;
  //if hitted the cache, just return the result
  if (cache.find(n) != cache.end()) return cache[n];
  int result;
  if ( n <= 1) return 0; // recursive exited point
  if ( n == INT_MAX ) return 32; // special case to avoid integer overflow.
  if ( n % 2 == 0 ) result = integerReplacement(n/2) + 1;
  else result = min( integerReplacement(n+1), integerReplacement(n-1) ) + 1;
  //add into cache
  cache[n] = result;
  return result;
  }
  int integerReplacement_simple(int n){
  int ans = 0;
  size_t m = n;
  while (1 != m) {
  if (1 == (m & 1)) {
  if (m==3) --m; //special case
  else m = (m&0b11^0b01) ? m + 1 : m - 1;
  }
  else m >>= 1;
  ++ans;
  }
  return ans;
  }
  int integerReplacement(int n) {
  return integerReplacement_recursionWithCache(n);
  return integerReplacement_simple(n);
  }
 };"
171,171,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 static string dict1[] ={""Zero"",""One"", ""Two"", ""Three"", ""Four"", ""Five"", ""Six"", ""Seven"", ""Eight"", ""Nine"",
  ""Ten"", ""Eleven"", ""Twelve"", ""Thirteen"", ""Fourteen"", ""Fifteen"", ""Sixteen"", 
  ""Seventeen"", ""Eighteen"", ""Nineteen""};
 static string dict2[]={"""","""", ""Twenty"", ""Thirty"", ""Forty"", ""Fifty"", ""Sixty"", ""Seventy"", ""Eighty"", ""Ninety"" };
 static string dict3[]={""Hundred"", ""Thousand"", ""Million"", ""Billion"" };
 // This function only converts the number which less than 1000
 string numberLess1000ToWords(int num) {
  //char n[3] = {0, 0, 0};
  string result;
  if (num == 0) {
  return result;
  }else if (num < 20) {
  return dict1[num];
  } else if (num < 100) {
  result = dict2[num/10];
  if (num%10 > 0) { 
  result += "" "" + dict1[num%10];
  }
  }else {
  result = dict1[num/100] + "" "" + dict3[0];
  if ( num % 100 > 0 ) {
  result += "" "" + numberLess1000ToWords( num % 100 );
  }
  }
  return result;
 }
 string numberToWords(int num) {
  //edge case
  if (num ==0 ) return dict1[num];
  vector<string> ret;
  for( ;num > 0; num/=1000 ) {
  ret.push_back( numberLess1000ToWords(num % 1000) );
  }
  string result=ret[0];
  for (int i=1; i<ret.size(); i++){
  if (ret[i].size() > 0 ){
  if ( result.size() > 0 ) {
  result = ret[i] + "" "" + dict3[i] + "" "" + result; 
  } else {
  result = ret[i] + "" "" + dict3[i]; 
  }
  }
  }
  return result;
 }
 #define TEST(num) cout << num << "" -> \"""" << numberToWords(num) << ""\"""" << endl
 int main(int argc, char** argv) 
 {
  int num = 123;
  if (argc >1){
  num = atoi(argv[1]);
  }
  TEST(num);
  TEST(0);
  TEST(1);
  TEST(10);
  TEST(11);
  TEST(18);
  TEST(20);
  TEST(22);
  TEST(30);
  TEST(99);
  TEST(100);
  TEST(101);
  TEST(110);
  TEST(120);
  TEST(256);
  TEST(1000);
  TEST(1001);
  TEST(1010);
  TEST(1110);
  TEST(1111);
  TEST(10000);
  TEST(10001);
  TEST(100000);
  TEST(100001);
  TEST(1000000);
  TEST(1000001);
  TEST(10000000);
  TEST(10000001);
  TEST(100000000);
  TEST(100000001);
  TEST(1000000000);
  TEST(1000000001);
  TEST(2147483647);
  return 0;
 }"
172,172,"#include <stdlib.h>
 #include <string>
 #include <iostream>
 using namespace std;
 //greeding algorithm
 string intToRoman(int num) {
  string symbol[] = {""M"",""CM"",""D"",""CD"",""C"",""XC"",""L"",""XL"",""X"",""IX"",""V"",""IV"",""I""}; 
  int value[] = {1000,900,500,400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; 
  string result;
  for(int i=0; num!=0; i++){
  while(num >= value[i]){
  num -= value[i];
  result+=symbol[i];
  }
  }
  return result;
 }
 int main(int argc, char** argv)
 {
  int num = 1234;
  if (argc>0){
  num = atoi(argv[1]);
  } 
  cout << num << "" : "" << intToRoman(num) << endl;
  return 0;
 }"
173,173,"#include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 /*
 Considering:
  s1 = a1, a2 ........a(i-1), ai
  s2 = b1, b2, .......b(j-1), bj
  s3 = c1, c3, .......c(i+j-1), c(i+j)
 Defined 
  match[i][j] means s1[0..i] and s2[0..j] is matched S3[0..i+j]
  So, if ai == c(i+j), then match[i][j] = match[i-1][j], which means
  s1 = a1, a2 ........a(i-1)
  s2 = b1, b2, .......b(j-1), bj
  s3 = c1, c3, .......c(i+j-1)
  Same, if bj = c(i+j), then match[i][j] = match[i][j-1];
 Formula:
  Match[i][j] = 
  (s3[i+j-1] == s1[i]) && match[i-1][j] || 
  (s3[i+j-1] == s2[j]) && match[i][j-1]
 Initialization:
  i=0 && j=0, match[0][0] = true;
  i=0, s3[j] == s2[j], match[0][j] |= match[0][j-1]
  s3[j] != s2[j], match[0][j] = false;
  j=0, s3[i] == s1[i], match[i][0] |= match[i-1][0]
  s3[i] != s1[i], Match[i][0] = false;
 */
 //Dynamic Programming
 bool isInterleave(string s1, string s2, string s3) {
  if (s1.size() + s2.size() != s3.size()) {
  return false;
  }
  vector< vector<int> > match(s1.size()+1, vector<int>(s2.size()+1, false) );
  match[0][0] = true;
  for(int i=1; i<=s1.size(); i++) {
  if (s1[i-1] == s3[i-1] ) {
  match[i][0] = true;
  }else{
  break;
  }
  }
  for(int i=1; i<=s2.size(); i++) {
  if (s2[i-1] == s3[i-1] ) {
  match[0][i] = true;
  }else{
  break;
  }
  }
  for(int i=1; i<=s1.size(); i++) {
  for(int j=1; j<=s2.size(); j++) {
  if (s1[i-1] == s3[i+j-1]) {
  match[i][j] = match[i-1][j] || match[i][j];
  }
  if (s2[j-1] == s3[i+j-1]) {
  match[i][j] = match[i][j-1] || match[i][j];
  }
  }
  }
  return match[s1.size()][s2.size()];
 }
 //Time Limit Exceeded
 bool isInterleave_dfs(string s1, string s2, string s3) {
  if (s1.size() + s2.size() != s3.size()) {
  return false;
  }
  const char *p1 = s1.c_str(), *p2 = s2.c_str(), *p3 = s3.c_str();
  for (; *p3 != '\0'; p3++){
  if (*p3 == *p1 && *p3!=*p2) {
  p1++;
  }else if ( *p3 == *p2 && *p3 != *p1) {
  p2++;
  }else if (*p3==*p1 && *p3 ==*p2) {
  if (isInterleave(p1+1, p2, p3+1) == false){
  return isInterleave(p1, p2+1, p3+1);
  }
  return true;
  }else{
  return false;
  }
  }
  return ( *p1 =='\0' && *p2 =='\0' && *p3 =='\0' );
 }
 #define TEST(s1, s2, s3) cout << s1 << "", "" << s2 << "" = "" << s3 << "" : "" << isInterleave(s1,s2,s3) << endl;
 int main(int argc, char**argv)
 {
  string s1= ""aabcc"", s2 = ""dbbca"";
  TEST(s1,s2, ""aadbbcbcac"");
  TEST(s1,s2, ""aadbbbaccc"");
  s1=""c""; s2=""ca"";
  TEST(s1, s2, ""cca"");
  TEST(s1, s2, ""cac"");
  s1 = ""bbbbbabbbbabaababaaaabbababbaaabbabbaaabaaaaababbbababbbbbabbbbababbabaabababbbaabababababbbaaababaa"";
  s2 = ""babaaaabbababbbabbbbaabaabbaabbbbaabaaabaababaaaabaaabbaaabaaaabaabaabbbbbbbbbbbabaaabbababbabbabaab"";
  string s3 = ""babbbabbbaaabbababbbbababaabbabaabaaabbbbabbbaaabbbaaaaabbbbaabbaaabababbaaaaaabababbababaababbababbbababbbbaaaabaabbabbaaaaabbabbaaaabbbaabaaabaababaababbaaabbbbbabbbbaabbabaabbbbabaaabbababbabbabbab"";
  TEST(s1, s2, s3);
  return 0;
 }"
174,174,"class Solution {
 public:
  set <int> inter1, inter2;//we use sets so as to avoid duplicates
  vector <int> solution;
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
  for(int i = 0; i < nums1.size(); i++)
  inter1.insert(nums1[i]);//get all of the unique elements in nums1 sorted
  for(int i = 0; i < nums2.size(); i++)
  if(inter1.find(nums2[i]) != inter1.end())//search inter1 in O(logN)
  inter2.insert(nums2[i]);//populate the intersection set
  for(set<int>::iterator it = inter2.begin(); it != inter2.end(); ++it)
  solution.push_back(*it);//copy the set into a vector
  return solution;
  }
 };
 /*
  * This Solution use one unordered_set 
  */
 class Solution2 {
 public:
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
  unordered_set<int> hash_set(nums1.begin(), nums1.end());
  vector<int> res ;
  for (auto it& : nums2) {
  if (hash_set.count(it)) {
  res.push_back(it);
  hash_set.erase(it);
  }
  }
  return res;
  }
 };
 /*
  * This Solution use unordered_map, insert the data into a map is more efficent than set
  */
 class Solution {
 public:
  vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
  unordered_map<int, bool> m;
  for (auto n : nums1) {
  m[n] = true;
  }
  vector<int> result;
  for (auto n : nums2){
  if (m.find(n) != m.end() && m[n] ){
  result.push_back(n);
  m[n]=false;
  } 
  }
  return result;
  }
 };"
175,175,"/* Solution
  * --------
  *
  * Follow up:
  * 
  * 1)If the given array is already sorted we can skip the sorting.
  * 
  * 2)If nums1 is significantly smaller than nums2 we can only sort nums1 and then binary
  * search every element of nums2 in nums1 with a total complexity of (MlogN) or if nums2
  * is already sorted we can search every element of nums1 in nums2 in O(NlogM)
  *
  * 3)Just like 2), we can search for every element in nums2, thus having an online
  * algorithm.
  */
 class Solution { // O(NlogN + MlogM)
 public:
  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
  sort(nums1.begin(), nums1.end());//we sort both vectors in order to intersect
  sort(nums2.begin(), nums2.end());//them later in O(N + M), where N = nums1.size()
  vector <int> solution; //M = nums2.size() 
  int index = 0;
  bool finished = false;
  for(int i = 0; i < nums1.size() && !finished; i++)
  {
  while(index < nums2.size() && nums1[i] > nums2[index])//we skip over the
  index++;//smaller elements in nums2
  if(index == nums2.size())//we have reached the end of nums2 so we have no more
  finished = true;//elements to add to the intersection
  else if(nums1[i] == nums2[index])//we found a common element
  {
  solution.push_back(nums1[i]);
  index++;
  }
  }
  return solution;
  }
 };
 /*
  * Just simply use the map can have O(M+N) time complexity.
  *
  */
 class Solution {
 public:
  vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
  unordered_map<int, int> m;
  for (auto n: nums1) {
  m[n]++;
  }
  vector<int> result;
  for (auto n:nums2){
  if (m.find(n) != m.end() && m[n]>0 ){
  result.push_back(n);
  m[n]--;
  } 
  }
  return result;
  }
 };"
176,176,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
  public:
  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
  //caculate the length of each List
  int lenA = getListLength(headA);
  int lenB = getListLength(headB);
  if (lenA<=0 || lenB<=0 ) return NULL;
  //let List A is the longest List;
  if (lenA < lenB){
  swap(headA, headB);
  }
  //move head of List A, make both of Lists are same length 
  for (int i=0; i<abs(lenA-lenB); i++){
  headA = headA->next;
  }
  //synced travel both of Lists and check their nodes are same or not 
  while (headA != headB){
  headA = headA->next;
  headB = headB->next;
  }
  return headA;
  }
  private: 
  inline int getListLength(ListNode *head){
  int len=0;
  while(head!=NULL){
  head = head->next;
  len++;
  }
  return len;
  }
 };"
177,177,"/**
  * Definition for an interval.
  * struct Interval {
  * int start;
  * int end;
  * Interval() : start(0), end(0) {}
  * Interval(int s, int e) : start(s), end(e) {}
  * };
  */
 class Solution {
 public:
  //return true if lhs starts earlier than rhs
  bool compareInterval(Interval& lhs, Interval& rhs) {
  return lhs.start < rhs.start;
  }
  //check two interval overlapped or not
  bool overlapped(Interval& lhs, Interval& rhs) {
  return (compareInterval(lhs, rhs)) ?
  lhs.end >= rhs.start:
  rhs.end >= lhs.start;
  }
  //merge two interval - return the intersections of two intervals
  Interval mergeTwoInterval(Interval& lhs, Interval& rhs) {
  Interval result;
  result.start = max(lhs.start, rhs.start);
  result.end = min(lhs.end, rhs.end);
  return result;
  }
  vector<Interval> intervalIntersection(vector<Interval>& A, vector<Interval>& B) {
  int lenA = A.size();
  int lenB = B.size();
  vector<Interval> result;
  if (lenA <=0 || lenB<=0) return result; //edge case
  int i=0, j=0;
  while ( i < lenA && j < lenB ) {
  if( overlapped(A[i], B[j]) ) {
  result.push_back(mergeTwoInterval(A[i], B[j]));
  // if the current interval is not overlapped with next one,
  // then we move the next interval.
  int nexti = i;
  if ( j==lenB-1 || !overlapped(A[i], B[j+1]) ) nexti=i+1;
  if ( i==lenA-1 || !overlapped(A[i+1], B[j]) ) j++;
  i = nexti;
  }else{
  //if not overlapped, we just move the next one
  compareInterval(A[i], B[j]) ? i++ : j++;
  }
  }
  return result;
  }
 };"
178,178,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  TreeNode* invertTree_recursive(TreeNode* root) {
  if (root==NULL) return root;
  TreeNode* node = invertTree_recursive(root->left);
  root->left = invertTree_recursive(root->right);
  root->right = node;
  return root;
  }
  TreeNode* invertTree_non_recursive(TreeNode* root) {
  if (root==NULL) return root;
  vector<TreeNode*> stack;
  stack.push_back(root);
  while (!stack.empty()) {
  TreeNode* node = stack.back();
  stack.pop_back();
  swap(node->left, node->right);
  if (node->left) stack.push_back(node->left);
  if (node->right) stack.push_back(node->right);
  }
  return root;
  }
  TreeNode* invertTree(TreeNode* root) {
  if (rand()%2){
  return invertTree_non_recursive(root);
  }
  return invertTree_recursive(root); 
  }
 };"
179,179,"class Solution {
 public:
  int edge(vector<vector<int>> &grid, int x, int y) {
  int edge = 0;
  if (x==0 || (x>0 && grid[x-1][y] == 0 ) ) edge++; //up
  if (y==0 || (y>0 && grid[x][y-1] == 0 ) ) edge++; //left
  if (x == grid.size() - 1 || 
  (x < grid.size() - 1 && grid[x+1][y] == 0)) edge++; //down
  if (y == grid[0].size() - 1 || 
  (y < grid[0].size() - 1 && grid[x][y+1] == 0)) edge++; //right
  return edge;
  }
  int islandPerimeter(vector<vector<int>>& grid) {
  int perimeter = 0;
  for(int i=0; i<grid.size(); i++) {
  for(int j=0; j<grid[0].size(); j++) {
  if (grid[i][j] == 1) {
  perimeter += edge (grid, i, j);
  }
  }
  }
  return perimeter;
  }
 };"
180,180,"class Solution {
 public:
  bool isIsomorphic(string s, string t) {
  if (s.size()!=t.size()) return false;
  const int MAXCHAR = 256;
  char maps[MAXCHAR]={0}, mapt[MAXCHAR]={0};
  //memset(maps, 0, sizeof(maps));
  //memset(mapt, 0, sizeof(mapt));
  for(int i=0; i<s.size(); i++){
  if(maps[s[i]] == 0 && mapt[t[i]] == 0){
  maps[s[i]] = t[i];
  mapt[t[i]] = s[i];
  continue;
  }
  if(maps[s[i]] == t[i] && mapt[t[i]] == s[i]) {
  continue;
  }
  return false;
  }
  return true;
  }
 };"
181,181,"class Solution {
 public:
  bool isSubsequence(string s, string t) {
  if (s.size() <= 0) return true;
  int ps=0, pt=0;
  while (pt < t.size()) {
  if (s[ps] == t[pt]) {
  ps++; pt++;
  if (ps >= s.size()) return true;
  }else {
  pt++;
  }
  }
  return false;
  }
 };"
182,182,"class Solution {
 public:
  int numJewelsInStones(string J, string S) {
  bool map[256] = {false};
  for (auto c : J) {
  map[c]=true;
  }
  int cnt=0;
  for (auto c : S) {
  if (map[c]) cnt++;
  }
  return cnt;
  }
 };"
183,183,"class Solution {
 public:
  bool canJump(int A[], int n) {
  if (n<=0) return false;
  // the basic idea is traverse array, maintain the most far can go
  int coverPos=0;
  // the condition i<=coverPos means traverse all of covered position 
  for(int i=0; i<=coverPos && i<n; i++){
  if (coverPos < A[i] + i){
  coverPos = A[i] + i;
  }
  if (coverPos>=n-1){
  return true;
  }
  }
  return false;
  }
 };"
184,184,"#include <iostream>
 using namespace std;
 //Acutally, using the Greedy algorithm can have the answer
 int jump(int A[], int n) {
  if (n<=1) return 0;
  int steps = 0;
  int coverPos = 0;
  for (int i=0; i<=coverPos&& i<n; ){
  if (A[i]==0) return -1; 
  if(coverPos < A[i]+i){
  coverPos = A[i]+i;
  steps++;
  }
  if (coverPos >= n-1){
  return steps;
  }
  //Greedy: find the next place which can have biggest distance
  int nextPos=0;
  int maxDistance=0;
  for(int j=i+1; j<=coverPos; j++){
  if ( A[j]+j > maxDistance ) {
  maxDistance = A[j]+j;
  nextPos = j;
  }
  }
  i = nextPos;
  }
  return steps;
 }
 void printArray(int a[], int n){
  cout << ""{ "";
  for(int i=0; i<n; i++){
  if(i) cout << "", "";
  cout << a[i];
  }
  cout << "" } "";
 }
 int main()
 {
  #define TEST(a) printArray(a, sizeof(a)/sizeof(a[0])); cout<<jump(a, sizeof(a)/sizeof(a[0]))<<endl;
  int a1[]={0};
  TEST(a1);
  int a2[]={1};
  TEST(a2);
  int a3[]={3,2,1,0,4};
  TEST(a3);
  int a4[]={2,3,1,1,4};
  TEST(a4);
  int a5[]={1,2,3};
  TEST(a5);
  // 0 -> 1 -> 4 -> end
  int a6[]={2,3,1,1,4,0,1};
  TEST(a6);
  // 0 -> 1 -> 3 -> end
  int a7[]={2,3,1,2,0,1};
  TEST(a7);
  return 0;
 }"
185,185,"class Solution {
 public:
  //STL using qsort to solve this problem
  int findKthLargest_buildin(vector<int>& nums, int k) {
  int n=nums.size();
  std::nth_element(nums.begin(),nums.end()-k,nums.end());
  return nums[n-k];
  }
  //qsort partition
  int partition(vector<int>& nums, int left, int right) {
  int pivot = nums[left];
  int l = left + 1, r = right;
  while (l <= r) {
  if (nums[l] < pivot && nums[r] > pivot){
  swap(nums[l++], nums[r--]);
  }
  if (nums[l] >= pivot) l++;
  if (nums[r] <= pivot) r--;
  }
  swap(nums[left], nums[r]);
  return r;
  }
  int findKthLargest_qsort(vector<int>& nums, int k) {
  int left = 0, right = nums.size() - 1;
  while (true) {
  int pos = partition(nums, left, right);
  if (pos == k - 1){ 
  return nums[pos];
  }
  if (pos > k - 1) {
  right = pos - 1;
  }else{
  left = pos + 1; 
  } 
  }
  }
  int findKthLargest(vector<int>& nums, int k) {
  return findKthLargest_qsort(nums, k);
  }
 };"
186,186,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  // in-order travel - recursive way
  int kthSmallestHelper_recursive(TreeNode* root, int& k) {
  if (root==NULL) return 0; //this behavior is undefined!
  //in-order travel
  int result = kthSmallestHelper_recursive(root->left, k);
  if (k==0) return result;
  k--;
  if (k==0) return root->val;
  return kthSmallestHelper_recursive(root->right, k);
  }
  // in-order travel - non-recursive way
  int kthSmallestHelper_nonRecursive(TreeNode* root, int k){
  stack<TreeNode*> s;
  while(!s.empty() || root){
  while (root) { 
  s.push(root);
  root = root->left;
  }
  k--;
  root = s.top()->right;
  if (k==0) return s.top()->val;
  s.pop();
  }
  return -1;
  }
  int kthSmallest(TreeNode* root, int k) {
  //return kthSmallestHelper_nonRecursive(root, k);
  return kthSmallestHelper_recursive(root, k);
  }
 };"
187,187,"const int COLOR_CNT = 26;
 class Node {
 public:
  Node(char c) {
  incomming = 0;
  color = c;
  processed = false;
  memset(colors, 0, sizeof(colors));
  }
  void AddMyColor() { colors[color]++; }
  void Processed() { processed = true; }
  bool isProcessed() { return processed; }
  void AddIncomming(int n=1) { incomming += n;}
  int Incomming() {return incomming;}
  void AddChildNode(int n) { children.push_back(n); }
  vector<int>& Children() { return children; }
  int ChildrenCount() { return children.size(); }
  int* Colors() {return colors;}
  int MaxColorValue() {
  int m = -1;
  for(auto c: colors) {
  m = max(m, c);
  }
  return m;
  }
  void MergeChildColors(Node& child){
  int* c = child.Colors();
  for(int i=0; i<COLOR_CNT; i++) {
  colors[i] = max(colors[i], c[i]);
  }
  }
 private:
  int incomming; // incomming connection
  char color; // node's color
  bool processed; // if the node has been processed
  int colors[COLOR_CNT]; // the colors count stastices 
  vector<int> children; // children nodes
 };
 class Solution {
 private:
  void print(vector<int>& v) {
  cout << ""["";
  int i = 0;
  for(; i<v.size()-1; i++) {
  cout << v[i] << "","";
  }
  cout << v[i] << ""]"" << endl;
  }
 private:
  int nodes_cnt;
  vector<Node> nodes;
 public:
  int largestPathValue(string colors, vector<vector<int>>& edges) {
  nodes_cnt = colors.size() ;
  for(int i=0; i<nodes_cnt; i++) {
  Node n( colors[i]-'a');
  nodes.push_back(n);
  }
  for(auto& e : edges) {
  nodes[e[0]].AddChildNode(e[1]);
  nodes[e[1]].AddIncomming();
  }
  vector<bool> visited(nodes_cnt, false);
  // We can do toplogical sort
  // 
  //vector<int> topSort;
  //for(int id=0; id <nodes_cnt; id++){
  // auto& n = nodes[id];
  // topologicalSort(id, topSort, visited);
  //}
  //print(topSort);
  int m = -1;
  for (int i=0; i<nodes_cnt; i++) {
  //int id = topSort[i];
  int id = i;
  auto& n = nodes[id];
  //using to check cycle.
  std::fill(visited.begin(), visited.end(), false);
  bool succ = travel(id, visited);
  if (!succ) return -1;
  m = max(m, nodes[id].MaxColorValue());
  }
  return m;
  }
  void topologicalSort(int i, vector<int>& topSort, vector<bool>& visited) {
  if (visited[i]) return;
  visited[i] = true;
  for(auto& id : nodes[i].Children()) {
  if (!visited[id]) {
  topologicalSort(id, topSort, visited);
  }
  }
  topSort.push_back(i);
  }
  //return true if it is successful
  //return false if there is an error - has cycle
  bool travel(int i, vector<bool>& visited ) {
  //this node has been processed already
  if (nodes[i].isProcessed()) return true;
  //cycled 
  if (visited[i]) return false;
  visited[i] = true;
  // leaf node
  if (nodes[i].ChildrenCount() <= 0 ) {
  nodes[i].AddMyColor();
  nodes[i].Processed();
  return true;
  }
  for(auto& n : nodes[i].Children() ) {
  bool succ = travel(n, visited);
  if (!succ) return false;
  nodes[i].MergeChildColors( nodes[n] );
  }
  nodes[i].AddMyColor();
  nodes[i].Processed();
  //cout << ""[""<< i << ""]: "" ;
  //for(int k=0; k<26; k++) {
  // cout << nodes[i].colors[k] << "" "";
  //}
  //cout << endl;
  return true;
  }
 };"
188,188,"class Solution {
 private:
  bool string_cmp(string& s1, int p1, string& s2, int p2) {
  for (; p1 < s1.size() && p2 < s2.size() ; p1++, p2++) {
  if (s1[p1] == s2[p2]) continue;
  return s1[p1] > s2[p2];
  }
  return (s1.size() - p1 > s2.size() - p2);
  }
 public:
  string largestMerge(string word1, string word2) {
  int p1 = 0, p2 = 0;
  int len1 = word1.size(), len2 = word2.size();
  string merge(len1+len2, '\0');
  int p = 0;
  while (p1 < len1 && p2 < len2) {
  if ( string_cmp(word1, p1, word2, p2) ){ // take char from `word1`
  merge[p++] = word1[p1++];
  }else{ //take char from `word2`
  merge[p++] = word2[p2++];
  }
  }
  while (p1 < len1) merge[p++] = word1[p1++];
  while (p2 < len2) merge[p++] = word2[p2++];
  return merge;
  }
 };"
189,189,"class Solution {
  public:
  //compare function
  static bool comp (string& s1, string& s2) { return s1+s2 > s2+s1; }
  string largestNumber(vector<int> &num) {
  //convert int to string
  vector<string> v;
  for (int i=0; i<num.size(); i++) {
  v.push_back(to_string(num[i]));
  }
  //sort the string
  sort(v.begin(), v.end(), comp);
  //generate the result
  string result;
  for(int i=0; i<v.size(); i++ ){
  result+=v[i];
  }
  //special case: start with zero (e.g. [0, 0])
  if (result[0]=='0') return ""0"";
  return result;
  }
 };"
190,190,"#include <iostream>
 #include <vector>
 using namespace std;
 //Time Limit Exceeded
 int largestRectangleArea_01(vector<int>& heights) {
  if (heights.size() == 0) return 0;
  // idx of the first bar in the left or right that is lower than current bar
  vector<int> left(heights.size()); 
  vector<int> right(heights.size());
  right[heights.size() - 1] = heights.size();
  left[0] = -1;
  for (int i = 1; i < heights.size(); i++) {
  int l = i - 1;
  while (l >= 0 && heights[l] >= heights[i]) {
  l--;
  }
  left[i] = l;
  }
  for (int i = heights.size() - 2; i >= 0; i--) {
  int r = i + 1;
  while (r < heights.size() && heights[r] >= heights[i]) {
  r++;
  }
  right[i] = r;
  }
  int maxArea = 0;
  for (int i = 0; i < heights.size(); i++) {
  maxArea = max(maxArea, heights[i] * (right[i] - left[i] - 1));
  }
  return maxArea; 
 }
 // As we know, the area = width * height
 // For every bar, the 'height' is determined by the loweset bar.
 //
 // 1) We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. 
 // 2) A bar is popped from stack when a bar of smaller height is seen. 
 // 3) When a bar is popped, we calculate the area with the popped bar as smallest bar. 
 // 4) How do we get left and right indexes of the popped bar â€“ 
 // the current index tells us the â€˜right indexâ€™ and index of previous item in stack is the â€˜left indexâ€™. 
 //
 //
 // In other word, the stack only stores the incresing bars, let's see some example 
 //
 // Example 1
 // ---------
 // height = [1,2,3,4]
 //
 // stack[] = [ 0, 1, 2, 3 ], i=4
 //
 // 1) pop 3, area = height[3] * 1 = 4
 // 2) pop 2, area = height[2] * 2 = 4
 // 3) pop 1, area = height[1] * 3 = 6
 // 4) pop 0, area = height[0] * 4 = 4
 //
 //
 // Example 2
 // ---------
 // height = [2,1,2]
 //
 // stack[] = [ 0 ], i=1
 // 1) pop 0, area = height[0] * 1 = 2
 //
 // stack[] = [ 1,2 ], i=3, meet the end
 // 1) pop 2, area = height[2] * 1 = 2
 // 2) pop 1, area = height[1] * 3 = 3
 //
 //
 // Example 3
 // ---------
 // height = [4,2,0,3,2,5] 
 //
 // stack[] = [ 0 ], i=1, height[1] goes down
 // 1) pop 0, area = height[0] * 1 = 4
 //
 // stack[] = [ 1 ], i=2, height[2] goes down
 // 1) pop 1, area = height[1] * 2 = 4 // <- how do we know the left?
 // start from the 0 ?? 
 //
 // stack[] = [ 2, 3 ], i=4, height[4] goes down
 // 1) pop 3, area = height[3] * 1 = 3
 // 2) pop 2, area = height[2] * ? = 0 // <- how do we know the left? 
 // start from the 0 ??
 //
 // stack[] = [ 2,4,5 ], i=6, meet the end
 // 1) pop 5, area = height[5] * 1 = 5
 // 2) pop 4, area = height[4] * 3 = 6 // <- how do we know the left?
 // need check the previous item.
 // 3) pop 2, area = height[2] * ? = 4 // <- how do we know the left?
 // start from the 0 ??
 //
 // so, we can see, when the stack pop the top, the area formular is 
 //
 // height[stack_pop] * i - stack[current_top] - 1, if stack is not empty
 // height[stack_pop] * i, if stack is empty
 //
 int largestRectangleArea(vector<int> &height) {
  if (height.size()<=0) return 0;
  //Create an empty stack.
  vector<int> stack;
  //add a flag as a trigger if the end bar is met, and need to check the stack is empty of not .
  height.push_back(0);
  int maxArea = 0;
  for(int i=0; i<height.size(); i++){
  //If stack is empty or height[i] is higher than the bar at top of stack, then push â€˜iâ€™ to stack.
  if ( stack.size()<=0 || height[i] >= height[stack.back()] ) {
  stack.push_back(i);
  continue;
  }
  //If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. 
  //Let the removed bar be height[top]. Calculate area of rectangle with height[top] as smallest bar. 
  //For height[top], the â€˜left indexâ€™ is previous (previous to top) item in stack and â€˜right indexâ€™ is â€˜iâ€™ (current index).
  int topIdx = stack.back();
  stack.pop_back();
  int area = height[topIdx] * (stack.size()==0 ? i : i - stack.back() - 1 );
  if ( area > maxArea ) {
  maxArea = area;
  }
  //one more time. Because the stack might still have item.
  i--;
  }
  return maxArea;
 }
 void printArray(vector<int> &v)
 {
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << ""}"" << endl;
 }
 void test(int a[], int n)
 {
  vector<int> v(a, a + n);
  printArray(v);
  cout << largestRectangleArea(v) << endl;
 }
 int main()
 {
 #define TEST(a) test(a, sizeof(a)/sizeof(int))
  int a0[] = {2,1,3,1};
  TEST(a0);
  int a1[] = {2,1,5,6,2,3};
  TEST(a1);
  return 0;
 }
 /*int main()
  {
  int a[] = {2,1,5,6,2,3};
  vector<int> v(a, a + sizeof(a)/sizeof(int));
  printArray(v);
  cout << largestRectangleArea(v) << endl;
  return 0;
  }*/"
191,191,"class Solution {
 public:
  int largestSubmatrix(vector<vector<int>>& matrix) {
  int rows = matrix.size();
  int cols = matrix[0].size();
  vector<int> height (cols, 0);
  int result = 0;
  for(int r = 0; r < rows; r++) {
  for(int c = 0; c < cols; c++) {
  if (matrix[r][c] == 1) height[c]++;
  else height[c] = 0;
  }
  vector<int> h = height;
  sort(h.begin(), h.end());
  for(int i = 0; i < cols; i++) {
  result = max(result, h[i] * ( cols - i)); 
  }
  }
  return result;
  }
 };"
192,192,"class Solution {
 public:
  int maxLengthBetweenEqualCharacters(string s) {
  int pos[26]={0};
  int longest = -1 ;
  for (int i=0; i<s.size(); i++){
  int idx = s[i] -'a';
  if (pos[idx] == 0) pos[idx] = i + 1; 
  else longest = max(longest, i - pos[idx]);
  }
  return longest;
  }
 };"
193,193,"class Solution {
 public:
  string maximumTime(string time) {
  if (time[0] == '?' ) {
  time[0] = (time[1] == '?' || time[1] < '4') ? '2' : '1';
  }
  if (time[1] == '?' ) {
  time[1] = ( time[0] == '2' ) ? '3' : '9';
  }
  if (time[3] == '?') time[3] = '5';
  if (time[4] == '?') time[4] = '9'; 
  return time;
  }
 };"
194,194,"#include <stdio.h>
 #include <ctype.h>
 int lengthOfLastWord(const char *s) {
  if ( !s ||!*s ) return 0;
  int wordLen=0;
  int cnt=0;
  for (;*s!='\0';s++) {
  if (isalpha(*s)){
  cnt++;
  }
  if (!isalpha(*s)){
  if (cnt>0){
  wordLen = cnt;
  }
  cnt=0;
  }
  }
  return cnt>0 ? cnt : wordLen;
 }
 int main(int argc, char** argv)
 {
  const char* p;
  p = ""hello world"";
  printf(""%s, %d\n"", p, lengthOfLastWord(p)); 
  p = ""a"";
  printf(""%s, %d\n"", p, lengthOfLastWord(p)); 
  if(argc>1){
  p = argv[1];
  printf(""%s, %d\n"", p, lengthOfLastWord(p)); 
  }
 }"
195,195,"#include <iostream>
 #include <vector>
 #include <string>
 #include <algorithm>
 using namespace std;
 vector<string> letterCombinations(string digits) {
  char phone[10][4]={ {' ', '\0', '\0', '\0' }, //0
  {'\0', '\0', '\0', '\0' }, //1
  {'a', 'b', 'c', '\0' }, //2
  {'d', 'e', 'f', '\0' }, //3
  {'g', 'h', 'i', '\0' }, //4
  {'j', 'k', 'l', '\0' }, //5
  {'m', 'n', 'o', '\0' }, //6
  {'p', 'q', 'r', 's' }, //7
  {'t', 'u', 'v', '\0' }, //8
  {'w', 'x', 'y', 'z' } //9
  };
  vector<string> result;
  if (digits.size()<=0){
  result.push_back("""");
  return result;
  }
  for( int i=0; i<digits.size(); i++ ) {
  if (!isdigit(digits[i])) {
  vector<string> r;
  return r;
  } 
  int d = digits[i] - '0';
  if (result.size()<=0){
  for( int j=0; j<4 && phone[d][j]!='\0'; j++ ){
  string s;
  s += phone[d][j];
  result.push_back(s);
  }
  continue;
  }
  vector<string> r;
  for (int j=0; j<result.size(); j++){
  for( int k=0; k<4 && phone[d][k]!='\0'; k++ ){
  string s = result[j] + phone[d][k];
  //sort(s.begin(), s.end());
  r.push_back(s); 
  }
  }
  result = r;
  }
  //sort(result.begin(), result.end());
  return result; 
 }
 void printVector(vector<string>& ss){
  cout << ""{ "";
  for(int i=0; i<ss.size(); i++){
  if (i>0) cout << "", ""; 
  cout << ss[i];
  }
  cout << "" }"" << endl;
 }
 int main(int argc, char**argv)
 {
  string s=""23"";
  if (argc>1){
  s=argv[1];
  }
  vector<string> ss = letterCombinations(s);
  printVector(ss);
  return 0;
 }"
196,196,"class Solution {
 private:
  unordered_map<string, bool> processed;
  void rotate_str(string& s, int n) {
  std::rotate(s.begin(), s.begin()+n, s.end());
  }
  void add_str(string& s, int n) {
  for(int i=1; i<s.size(); i+=2) {
  s[i] = (s[i] -'0' + n) % 10 +'0';
  }
  }
 public:
  string findLexSmallestString(string s, int a, int b) {
  string result = s;
  dfs(s, a, b, result);
  return result;
  }
  void dfs(string& s, int a, int b, string& result) {
  if (processed.find(s) != processed.end()) return;
  processed[s] = true;
  if (s < result) result = s;
  string str = s;
  rotate_str(str, b); 
  dfs(str, a, b, result);
  str = s;
  add_str(str, a); 
  dfs(str, a, b, result);
  }
 };"
197,197,"class Solution {
 //Solution 1: convert the int to string for sort, Time complexity is high (Time Limited Error)
 public:
  vector<int> lexicalOrder01(int n) {
  vector<int> result;
  for (int i=1; i<=n; i++) {
  result.push_back(i);
  }
  sort(result.begin(), result.end(), this->myComp);
  return result;
  }
 private:
  static bool myComp(int i,int j) { 
  static char si[32]={0}, sj[32]={0};
  sprintf(si, ""%d\0"", i);
  sprintf(sj, ""%d\0"", j);
  return (strcmp(si, sj)<0); 
  }
 //Solution 2 : using recursive way to solution the problem, 540ms
 public:
  vector<int> lexicalOrder02(int n) {
  vector<int> result;
  for (int i=1; i<=n && i<=9; i++) {
  result.push_back(i);
  lexicalOrder_helper(i, n, result);
  }
  return result;
  }
 private:
  void lexicalOrder_helper(int num, int& n, vector<int>& result) {
  for (int i=0; i<=9; i++) {
  int tmp = num * 10 + i;
  if (tmp > n) {
  break;
  }
  result.push_back(tmp);
  lexicalOrder_helper(tmp, n, result);
  }
  }
 //Solution 3: no recursive way, but the code is not easy to read
 public :
  vector<int> lexicalOrder03(int n) {
  vector<int> result;
  int curr = 1;
  while (result.size()<n) {
  // Step One
  // ---------
  //Adding all of the possible number which multiply 10 as much as possible 
  // such as: curr = 1, then 1, 10, 100, 1000 ...
  // curr = 12, then 12, 120, 1200, ...
  for (; curr <= n; curr*=10 ) {
  result.push_back(curr);
  }
  // Step Two
  // ---------
  // After find the number which multiply 10 greater than `n`, then go back the previous one,
  // and keep adding 1 until it carry on to next number
  // for example:
  // curr = 100, then we need evalute: 11,12,13,14,15,16,17,18,19, but stop at 20
  // curr = 230, then we need evaluate: 24,25,26,27,28,29, but stop at 30.
  curr = curr/10 + 1;
  for (; curr <= n && curr % 10 != 0; curr++) {
  result.push_back(curr);
  }
  // Step Three
  // ----------
  // Now, we finished all of the number, we need go back for next number
  // Here is a bit tricky.
  // 
  // Assuming the n is 234, and Step One evaluted 190, and Step Two, evaluted 191,192,...,199
  // Now, the `curr` is 200, and we need start from 2 instead of 20, that's why need keep dividing 10
  for (; curr%10 == 0; curr/=10);
  }
  return result;
  }
 //start point
 public:
  vector<int> lexicalOrder(int n) {
  srand(time(NULL));
  if (rand()%2) 
  return lexicalOrder02(n); // recursive way 560ms
  else 
  return lexicalOrder03(n); // non-recursive way, 460ms
  }
 };"
198,198,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  bool hasCycle(ListNode *head) {
  return hasCycle04(head);
  return hasCycle03(head);
  return hasCycle02(head);
  return hasCycle01(head);
  }
  // using a map to store the nodes we walked
  bool hasCycle01(ListNode *head) {
  unordered_map<ListNode*,bool > m;
  ListNode* p = head;
  m[(ListNode*)NULL] = true;
  while( m.find(p) == m.end() ) {
  m[p] = true;
  p = p -> next;
  }
  return p != NULL;
  }
  // Change the node's of value, mark the footprint by a special value
  bool hasCycle02(ListNode *head) {
  ListNode* p = head;
  // using INT_MAX as the mark could be a bug!
  while( p && p->val != INT_MAX ) {
  p->val = INT_MAX;
  p = p -> next;
  }
  return p != NULL;
  }
  /*
  * if there is a cycle in the list, then we can use two pointers travers the list.
  * one pointer traverse one step each time, another one traverse two steps each time.
  * so, those two pointers meet together, that means there must be a cycle inside the list.
  */
  bool hasCycle03(ListNode *head) {
  if (head==NULL || head->next==NULL) return false;
  ListNode* fast=head;
  ListNode* slow=head;
  do{
  slow = slow->next;
  fast = fast->next->next;
  }while(fast != NULL && fast->next != NULL && fast != slow);
  return fast == slow? true : false;
  }
  // broken all of nodes 
  bool hasCycle04(ListNode *head) {
  ListNode dummy (0);
  ListNode* p = NULL;
  while (head != NULL) {
  p = head;
  head = head->next;
  // Meet the old Node that next pointed to dummy
  //This is cycle of linked list
  if (p->next == &dummy) return true;
  p->next = &dummy; // next point to dummy
  }
  return false;
  }
 };"
199,199,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 private:
  ListNode *p1, *p2;
 public:
  bool hasCycle(ListNode *head) {
  if (head==NULL) return false;
  p1=head;
  p2=head;
  while (p1!=NULL && p2!=NULL){
  p1=p1->next;
  if (p2->next == NULL) return false;
  p2=p2->next->next;
  if (p1==p2) return true;
  }
  return false;
  } 
  /* 
  * So, the idea is:
  * 1) Using the cycle-chcking algorithm.
  * 2) Once p1 and p1 meet, then reset p1 to head, and move p1 & p2 synchronously
  * until p1 and p2 meet again, that place is the cycle's start-point 
  */
  ListNode *detectCycle(ListNode *head) {
  if (hasCycle(head)==false){
  return NULL;
  }
  p1 = head;
  while (p1!=p2) {
  p1 = p1->next;
  p2 = p2->next;
  }
  return p1;
  }
 };"
200,200,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  /** @param head The linked list's head.
  Note that the head is guaranteed to be not null, so it contains at least one node. */
  Solution(ListNode* head) {
  this->head = head;
  this->len = 0;
  for(ListNode*p = head; p!=NULL; p=p->next, len++);
  srand(time(NULL));
  }
  /** Returns a random node's value. */
  int getRandom() {
  int pos = rand() % len;
  ListNode *p = head;
  for (; pos > 0; pos--, p=p->next);
  return p->val;
  }
  ListNode* head;
  int len;
 };
 /**
  * Your Solution object will be instantiated and called as such:
  * Solution obj = new Solution(head);
  * int param_1 = obj.getRandom();
  */"
201,201,"class Solution {
 public:
  bool checkZeroOnes(string s) {
  int zeros = 0;
  int ones = 0;
  int i = 0;
  while (i < s.size()) {
  if(s[i] == '0') {
  int cnt = 0;
  for (;s[i] == '0' && i < s.size(); i++) cnt++;
  zeros = max(zeros, cnt);
  }else {
  int cnt = 0;
  for (;s[i] == '1'&& i < s.size(); i++) cnt++;
  ones = max(ones, cnt);
  }
  }
  return ones > zeros;
  }
 };"
202,202,"class Solution {
 public:
  // Solution
  // --------
  // We can see the input formation has the order
  // so, we can maintain an array which states the current level's path length
  //
  // For example:
  // dir
  // subdir1 <- length[ level1 = len(""dir"")+len(""/""), 
  // level2 = len(""dir"")+len(""/"")+len(""subdir1"")+len(""/"") ] 
  // file.ext
  // subdir2
  // file.ext
  // subsubdir1 <- length[ level1 = len(""dir"")+len(""/""), 
  // level2 = len(""dir"")+len(""/"")+len(""subdir2"")+len(""/""), 
  // level3 = len(""dir"")+len(""/"")+len(""subdir2"")+len(""/"")+len(""subsubdir1"")+len(""/"") ] 
  // file.ext 
  //
  int lengthLongestPath(string input) {
  stringstream ss(input); 
  string line;
  int result = 0;
  vector<int> length;
  length.push_back(0); //initialize top dummy level's length is zero
  while (getline(ss, line, '\n')) {
  //get current level, start from 1
  int level = 0;
  while ( line[level++] == '\t'); // get the level
  int len = line.size() - level + 1;
  //if is a file, then cacualte the total length.
  if (line.find('.') != string::npos) { 
  if ( length[level-1] + len > result ) {
  result = length[level-1] + len;
  }
  } else {
  if (length.size() <= level) {
  length.push_back(0); 
  }
  // if it a folder, then update the current level's length
  length[level] = length[level-1] + len + 1; // 1 for ""/"" path delimiter
  }
  }
  return result;
  }
 };"
203,203,"#include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 string longestCommonPrefix(vector<string> &strs) {
  string word;
  if (strs.size()<=0) return word;
  for(int i=1; i<=strs[0].size(); i++){
  string w = strs[0].substr(0, i);
  bool match = true;
  int j=1;
  for(j=1; j<strs.size(); j++){
  if (i>strs[j].size() || w!=strs[j].substr(0, i) ) {
  match=false;
  break;
  }
  }
  if (!match) {
  return word;
  }
  word = w;
  }
  return word;
 }
 int main()
 {
  const char* s[]={""abab"",""aba"",""abc""};
  vector<string> v(s, s+3);
  cout << longestCommonPrefix(v) <<endl;
 }"
204,204,"//
 // Obviously, the easist way is sort the array, however the run-time complexity is O(nlogn)
 // 
 // If we cannot use the sort algorithm, then it seems we have to use O(n^2) solution.
 //
 // That's fine, let's take a look the O(n^2) soultion
 //
 // 1) for each item num[i] in the array
 // 2) for loop to seach ...... num[i-2], num[i-1], num[i]+1, num[i]+2 ......
 // 
 // We can see, the search is really heavy, and the best data structure for seaching is HashMap.
 // hash map is O(1) run-time complexity for seaching.
 //
 // So, we can have the following solution by using Hash Map.
 // 
 class Solution {
 public:
  int longestConsecutive(vector<int> &num) {
  map<int, int> m;
  for (int i=0; i<num.size(); i++){
  m[num[i]]=i;
  }
  int max_seq=0; 
  for (int i=0; i<num.size(); i++){
  int cnt=1;
  for(int n = num[i]+1;m.find(n)!=m.end();n++){
  m.erase(m.find(n));
  cnt++;
  }
  for(int n = num[i]-1;m.find(n)!=m.end();n--){
  m.erase(m.find(n));
  cnt++;
  }
  if (max_seq < cnt){
  max_seq = cnt;
  }
  if (m.size()==0){
  break;
  }
  }
  return max_seq;
  }
 };"
205,205,"class Solution {
 public:
  int longestIncreasingPath(vector<vector<int>>& matrix) {
  int result = 0;
  int row = matrix.size();
  int col = row ? matrix[0].size() : 0;
  vector<vector<int>> path = vector<vector<int>>(row, vector<int>(col, 0));
  for (int r = 0; r < row; r++) {
  for (int c = 0; c < col; c++) {
  result = max(result, helper(matrix, path, row, col, r, c));
  }
  }
  return result;
  }
  int helper(vector<vector<int>>& matrix, vector<vector<int>>& path, const int row, const int col, int r, int c) {
  if (path[r][c]>0) return path[r][c];
  int maxPath = 0;
  int tmp = matrix[r][c]; 
  matrix[r][c]=INT_MIN; 
  if (r < row-1 && tmp < matrix[r+1][c]) {
  maxPath = max(maxPath, helper(matrix, path, row, col, r+1, c));
  }
  if (c < col-1 && tmp < matrix[r][c+1]) {
  maxPath = max(maxPath, helper(matrix, path, row, col, r, c+1));
  }
  if (r > 0 && tmp < matrix[r-1][c]) {
  maxPath = max(maxPath, helper(matrix, path, row, col, r-1, c));
  }
  if (c > 0 && tmp < matrix[r][c-1]) {
  maxPath = max(maxPath, helper(matrix, path, row, col, r, c-1));
  }
  matrix[r][c] = tmp;
  path[r][c] = maxPath + 1;
  return path[r][c];
  }
 };"
206,206,"// O(n^2) - dynamic programming
 class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
  int len = nums.size();
  int maxLen = 0;
  vector<int> dp(len, 1);
  for (int i=0; i<len; i++) {
  for(int j=0; j<i; j++) {
  if ( nums[j] < nums[i] ) {
  dp[i] = max(dp[i], dp[j] + 1);
  }
  }
  maxLen = max(maxLen, dp[i]);
  }
  return maxLen;
  }
 };
 class Solution {
 public:
 /* 
  * Solution 1 - O(N^2)
  * =========
  *
  * LIS - longest increasing subsequence
  *
  * We iterate through the elements to find the LIS that ends with the current element. 
  * To do that we need to look at all of the previous elements and find one smaller than
  * the current one so that we can add the current one to the sequence terminated in the 
  * smaller one. The length of the LIS ending in the current element is the length of the
  * LIS ending in the smaller one + 1. To find the maximum current LIS we need to use the
  * maximum previous LIS that satisfies the conditions.
  * 
  */
  vector <int> longest_LIS;
  int lengthOfLIS(vector<int>& nums) {
  int answer = 0;
  if(nums.size())
  { 
  longest_LIS.push_back(1);
  answer = 1;
  for(int i = 1; i < nums.size(); i++)
  {
  int maximum = 1;
  for(int j = 0; j < longest_LIS.size(); j++)
  if(nums[i] > nums[j])
  maximum = max(maximum, longest_LIS[j] + 1);
  longest_LIS.push_back(maximum);
  answer = max(maximum, answer);
  }
  }
  return answer;
  }
 /* 
  * Solution 2 - O(N * logN)
  * =========
  *
  * LIS - longest increasing subsequence
  * 
  * We iterate through the elements to find the position of the current element in the
  * current LIS. After we find its position we change the LIS replacing the next biggest 
  * element with the current one or increase the size of the sequence if the current element
  * is bigger than the biggest one. This way we keep the LIS with the smallest possible
  * elements. By keeping any other LIS we can encounter an element that could have been added
  * to the LIS with the smallest elements, but can't be added to the current one, therefore
  * missing the solution.
  * 
  */
  vector <int> longest_subsequence; // the LIS
  vector <int> nums;
  int binary_search(int number)
  {
  int start = 0, end = longest_subsequence.size() - 1;
  if(start == end)
  {
  if(number > longest_subsequence[start])
  return start + 1;
  else
  return start;
  }
  while(start < end)
  {
  if(start == end - 1)
  {
  if(number > longest_subsequence[start] && number <= longest_subsequence[end])
  return end;
  else if(number <= longest_subsequence[start])
  return start;
  else
  return end + 1;
  }
  int middle = (start + end + 1) / 2;
  if(longest_subsequence[middle] < number)
  start = middle;
  else
  end = middle;
  }
  }
  int lengthOfLIS(vector<int>& nums) {
  int answer = 0;
  if(nums.size())
  { 
  answer = 1;
  longest_subsequence.push_back(nums[0]);
  for(int i = 1; i < nums.size(); i++)
  {
  int position = binary_search(nums[i]);
  if(position == longest_subsequence.size())
  longest_subsequence.push_back(nums[i]);
  else
  longest_subsequence[position] = nums[i];
  answer = max(answer, position + 1);
  }
  }
  return answer;
  }
 };"
207,207,"class Solution {
  inline int getCharIndex(char c) {
  return (c >='A' && c <='Z') ? c - 'A' : c - 'a';
  }
  inline int getCaseIndex(char c) {
  return (c >='A' && c <='Z') ? 1 : 0;
  }
 public:
  string longestNiceSubstring(string s) {
  vector<bitset<26>> check(2);
  int start = 0, len = 0;
  for (int i = 0; i < s.size() -1; i++){
  for (int j = i+1; j < s.size(); j++) {
  check[0] = check[1] = 0;
  for (int x=i; x<=j; x++){
  int i = getCaseIndex(s[x]);
  int j = getCharIndex(s[x]);
  check[i][j] = true;
  }
  if ( (check[0] ^ check[1]) == 0 ) {
  if ( j - i + 1 > len ){
  start = i;
  len = j-i+1;
  }
  }
  }
  }
  return s.substr(start, len);
  }
 };"
208,208,"class Solution {
 public:
  int longestPalindrome(string s) {
  int hashtable[128];
  memset(hashtable, 0, sizeof(hashtable));
  for(char ch : s) {
  hashtable[ch]++;
  }
  int result = 0;
  bool hasOdd = false;
  for (int n : hashtable) {
  if ( n%2 == 0 ) {
  result += n;
  } else {
  result += n -1;
  hasOdd = true;
  }
  }
  return hasOdd ? result + 1 : result;
  }
 };"
209,209,"/*
  supposed s = ""abbcba""
  we can have a matrix, 
  - dp[start, end] is the longest from s[start] to s[end]
  - if (start == end) dp[statr, end] = 1, it means every char can be palindromic
  a b b c b a
  a 1 0 0 0 0 0 
  b 0 1 0 0 0 0 
  b 0 0 1 0 0 0
  c 0 0 0 1 0 0
  b 0 0 0 0 1 0
  a 0 0 0 0 0 1 
  calculating from the bottom to up. (Note: only care about the top-right trangle)
  a b b c b a
  a 1 1 2 2 3 [5] <-- a == a , so ""abbcba"" comes from ""bbcb"" + 2 
  b 0 1 [2] 2 3 3 <-- b == b , so ""bb"" comes from """" + 2
  b 0 0 1 1 [3] 3 <-- b == b , so ""bcb"" comes from ""c"" + 2 
  c 0 0 0 1 1 [1] <-- c != a , so ""cba"" comes from max(""cb"", ""a"") 
  b 0 0 0 0 1 [1] <-- b != a , so ""ba"" comes from max (""b"", ""a"")
  a 0 0 0 0 0 1 
  So, we can have the following formular:
  s[start] != s[end] ==> dp[start, end] = max (dp[start+1, end], dp[start, end-1]);
  s[start] == s[end] ==> dp[start, end] = dp[start+1, end-1] + 2;
 */
 class Solution {
 public:
  int longestPalindromeSubseq(string s) {
  int n = s.size(); 
  vector<vector<int>> dp(n, vector<int>(n, 0));
  for (int start = n-1; start>=0; start--) {
  for (int end = start ; end < n ; end++) {
  if (start == end) {
  dp[start][end] = 1;
  continue;
  }
  if (s[start] == s[end]) {
  dp[start][end] = dp[start+1][end-1] + 2;
  }else{
  dp[start][end] = max (dp[start+1][end], dp[start][end-1]);
  }
  }
  }
  return dp[0][n-1];
  }
 };"
210,210,"#include <string.h>
 #include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 string findPalindrome(string s, int left, int right)
 {
  int n = s.size();
  int l = left;
  int r = right;
  while (left>=0 && right<=n-1 && s[left] == s[right]) {
  left--;
  right++;
  }
  return s.substr(left+1, right-left-1);
 }
 // This is the common solution.
 // Actuatlly it's faster than DP solution under Leetcode's test
 // the below optimized DP solution need 700ms+, this needs around 250ms.
 string longestPalindrome_recursive_way(string s) {
  int n = s.size();
  if (n<=1) return s;
  string longest;
  string str;
  for (int i=0; i<n-1; i++) {
  str = findPalindrome(s, i, i);
  if (str.size() > longest.size()){
  longest = str;
  } 
  str = findPalindrome(s, i, i+1);
  if (str.size() > longest.size()){
  longest = str;
  } 
  }
  return longest; 
 }
 //================================================================================
 void findPalindrome(string s, int left, int right, int& start, int& len)
 {
  int n = s.size();
  int l = left;
  int r = right;
  while (left>=0 && right<=n-1 && s[left] == s[right]) {
  left--;
  right++;
  }
  if (right-left-1 > len){
  len = right-left-1;
  start = left+1;
  }
 }
 //The following solution is better than previous solution.
 //Because it remove the sub-string return in findPalindrome().
 string longestPalindrome_recursive_way2(string s) {
  int n = s.size();
  if (n<=1) return s;
  int start=0, len=0; 
  string longest;
  string str;
  for (int i=0; i<n-1; i++) {
  findPalindrome(s, i, i, start, len);
  findPalindrome(s, i, i+1, start, len);
  }
  return s.substr(start, len);
 }
 //================================================================================
 // Time/Memory Limit Exceeded
 string longestPalindrome_dp_way(string s) {
  string longest;
  int n = s.size();
  if (n<=1) return s;
  //Construct a matrix, and consdier matrix[i][j] as s[i] -> s[j] is Palindrome or not.
  //using char or int could cause the `Memory Limit Error`
  //vector< vector<char> > matrix (n, vector<char>(n));
  //using bool type could cause the `Time Limit Error`
  vector< vector<bool> > matrix (n, vector<bool>(n));
  // Dynamic Programming 
  // 1) if i == j, then matrix[i][j] = true;
  // 2) if i != j, then matrix[i][j] = (s[i]==s[j] && matrix[i+1][j-1])
  for (int i=n-1; i>=0; i--){
  for (int j=i; j<n; j++){
  // The following if statement can be broken to 
  // 1) i==j, matrix[i][j] = true
  // 2) the length from i to j is 2 or 3, then, check s[i] == s[j]
  // 3) the length from i to j > 3, then, check s[i]==s[j] && matrix[i+1][j-1]
  if ( i==j || (s[i]==s[j] && (j-i<2 || matrix[i+1][j-1]) ) ) {
  matrix[i][j] = true;
  if (longest.size() < j-i+1){
  longest = s.substr(i, j-i+1);
  }
  }
  }
  }
  return longest;
 }
 // Optimized DP soltuion can be accepted by LeetCode.
 string longestPalindrome_dp_opt_way(string s) {
  int n = s.size();
  if (n<=1) return s;
  //Construct a matrix, and consdier matrix[j][i] as s[i] -> s[j] is Palindrome or not.
  // ------^^^^^^
  // NOTE: it's [j][i] not [i][j]
  //Using vector could cause the `Time Limit Error`
  //So, use the native array
  bool **matrix = (bool**)malloc(n*sizeof(bool*));
  int start=0, len=0;
  // Dynamic Programming
  // 1) if i == j, then matrix[i][j] = true;
  // 2) if i != j, then matrix[i][j] = (s[i]==s[j] && matrix[i-1][j+1])
  for (int i=0; i<n; i++){
  matrix[i] = (bool*)malloc((i+1)*sizeof(bool));
  memset(matrix[i], false, (i+1)*sizeof(bool));
  matrix[i][i]=true;
  for (int j=0; j<=i; j++){
  // The following if statement can be broken to
  // 1) j==i, matrix[i][j] = true
  // 2) the length from j to i is 2 or 3, then, check s[i] == s[j]
  // 3) the length from j to i > 3, then, check s[i]==s[j] && matrix[i-1][j+1]
  if ( i==j || (s[j]==s[i] && (i-j<2 || matrix[i-1][j+1]) ) ) {
  matrix[i][j] = true;
  if (len < i-j+1){
  start = j;
  len = i-j+1;
  }
  }
  }
  }
  for (int i=0; i<n; i++) { 
  free (matrix[i]);
  }
  free(matrix);
  return s.substr(start, len);
 }
 string longestPalindrome(string s) {
  return longestPalindrome_dp_way(s);
  return longestPalindrome_dp_opt_way(s);
  return longestPalindrome_recursive_way2(s);
  return longestPalindrome_recursive_way(s);
 }
 int main(int argc, char**argv)
 {
  string s = ""abacdfgdcaba"";
  if (argc > 1){
  s = argv[1];
  }
  cout << s << "" : "" << longestPalindrome(s) << endl;
  s = ""321012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210012321001232100123210123210012321001232100123210123"";
  cout << s << "" : "" << longestPalindrome(s) << endl;
  //""illi""
  s = ""iptmykvjanwiihepqhzupneckpzomgvzmyoybzfynybpfybngttozprjbupciuinpzryritfmyxyppxigitnemanreexcpwscvcwddnfjswgprabdggbgcillisyoskdodzlpbltefiz"";
  cout << s << "" : "" << longestPalindrome(s) << endl;
  return 0;
 }"
211,211,"class Solution {
 private:
  enum Vowels{
  A = 0,
  E = 1,
  I = 2,
  O = 3,
  U = 4,
  INVAILD = -1,
  };
  Vowels isVowels(char c) {
  switch(c) {
  case 'a' : return A;
  case 'e' : return E;
  case 'i' : return I;
  case 'o' : return O;
  case 'u' : return U;
  }
  return INVAILD;
  }
 public:
  int longestBeautifulSubstring(string word) {
  word += 'a';
  int len = 0;
  for(int i=0; i<word.size(); i++) {
  if (word[i] != 'a') continue;
  int prevIdx = A;
  int j=i;
  for(; j<word.size(); j++) {
  int currIdx = isVowels(word[j]);
  // the current char is same as before.
  if ( currIdx == prevIdx || currIdx == INVAILD) continue;
  // the current char is the next vowel.
  if ( currIdx == prevIdx + 1) { prevIdx++; continue;}
  // the current char is not in order, 
  // and the previous char is the final vowel.
  if ( prevIdx == U ){
  len = max(len, j-i);
  }
  break;
  }
  i = j-1;
  }
  return len;
  }
 };"
212,212,"const int NO_OF_CHARS = 256;
 /* if every character appears at least k times, the whole string is ok. 
  * Otherwise split by a least frequent character.
  * 
  * Because it will always be too infrequent and thus can't be part of any ok substring
  * and make the most out of the splits.
  */
 class Solution {
 public:
  int longestSubstring(string s, int k) {
  //deal with edge cases
  if (s.size() == 0 || s.size() < k) return 0;
  if (k==1) return s.size();
  //declare a map for every char's counter
  int count[NO_OF_CHARS];
  memset(count , 0, sizeof(count));
  //counting every char
  for (char ch : s) {
  count[ch]++;
  }
  int i=0;
  for ( i=0; i<NO_OF_CHARS; i++) {
  if (count[i] !=0 && count[i] < k) break;
  }
  //all of the chars meet the requirement
  if ( i >= NO_OF_CHARS ) return s.size();
  // find the most infrequent char
  char least = 0;
  for (int c = 0; c < NO_OF_CHARS; c++) {
  if (count[c] == 0) continue;
  if (least == 0) {
  least = c;
  } else if ( count[c] < count[least]) {
  least = c;
  }
  }
  //split the string and run them recursively
  vector<string> subs;
  split(s, least, subs);
  int res = 0;
  for (string str: subs) {
  res = max(res, longestSubstring(str, k));
  }
  return res;
  return 0;
  }
 private:
  inline int max(int x, int y) { return x>y? x:y; }
  inline void split(const string &s, char delim, vector<string> &elems) {
  stringstream ss;
  ss.str(s);
  string item;
  while (getline(ss, item, delim)) {
  cout << item << endl;
  elems.push_back(item);
  }
  }
  inline vector<string> split(const string &s, char delim) {
  vector<string> elems;
  split(s, delim, elems);
  return elems;
  }
 };"
213,213,"#include <string.h>
 #include <iostream>
 #include <string>
 #include <map>
 using namespace std;
 /*
  * Idea:
  * 
  * Using a map store each char's index.
  * 
  * So, we can be easy to know the when duplication and the previous duplicated char's index.
  * 
  * Then we can take out the previous duplicated char, and keep tracking the maxiumn length. 
  * 
  */
 int lengthOfLongestSubstring1(string s) {
  map<char, int> m;
  int maxLen = 0;
  int lastRepeatPos = -1;
  for(int i=0; i<s.size(); i++){
  if (m.find(s[i])!=m.end() && lastRepeatPos < m[s[i]]) {
  lastRepeatPos = m[s[i]];
  }
  if ( i - lastRepeatPos > maxLen ){
  maxLen = i - lastRepeatPos;
  }
  m[s[i]] = i;
  }
  return maxLen;
 }
 //don't use <map>
 int lengthOfLongestSubstring(string s) {
  const int MAX_CHARS = 256;
  int m[MAX_CHARS];
  memset(m, -1, sizeof(m));
  int maxLen = 0;
  int lastRepeatPos = -1;
  for(int i=0; i<s.size(); i++){
  if (m[s[i]]!=-1 && lastRepeatPos < m[s[i]]) {
  lastRepeatPos = m[s[i]];
  }
  if ( i - lastRepeatPos > maxLen ){
  maxLen = i - lastRepeatPos;
  }
  m[s[i]] = i;
  }
  return maxLen;
 }
 int main(int argc, char** argv)
 {
  string s = ""abcabcbb"";
  cout << s << "" : "" << lengthOfLongestSubstring(s) << endl;
  s = ""bbbbb"";
  cout << s << "" : "" << lengthOfLongestSubstring(s) << endl;
  s = ""bbabcdb"";
  cout << s << "" : "" << lengthOfLongestSubstring(s) << endl;
  if (argc>1){
  s = argv[1];
  cout << s << "" : "" << lengthOfLongestSubstring(s) << endl;
  }
  return 0;
 }"
214,214,"class Solution {
 public:
  int maxTurbulenceSize_01(vector<int>& A) {
  if (A.size() <= 1) return A.size();
  // declare status to mark the current pair status is go up or go down.
  enum Status {
  up,
  down,
  none
  } s = none;
  int maxlen = 1;
  int len = 1;
  for (int i=1; i< A.size(); i++) {
  // if there is a pair is equal, reset the status
  if ( A[i] == A[i-1] ) { 
  s = none;
  continue;
  }
  // init the first status
  if ( s == none ) {
  s = A[i] > A[i-1] ? up : down;
  len = 2;
  continue;
  }
  // keep tracking the status
  // make sure the status is zigzag pattern...up-down-up-down...
  if ( s == up ) {
  if ( A[i] < A[i-1] ) {
  len++;
  s = down;
  }else{
  len=2;
  }
  }else{
  if ( A[i] > A[i-1] ) {
  len++;
  s = up;
  }else{
  len=2;
  }
  }
  maxlen = len > maxlen ? len : maxlen;
  }
  return maxlen;
  }
  // The previous solution is quite straight forward, but the code is a bit complcated 
  // the following solution tries to use another way to make the code simpler.
  //
  // Then, we need to tracking the previous length of the zigzag pattern.
  //
  // And we have to tacking the length for both UP and DOWN patterns 
  //
  // - UP means the previous status goes up. and the previous length of the zigzog pattern.
  // - DOWN is same.
  // 
  // So, 
  //
  // - if the previous is UP, then the previous DWON must be 1, and vice versa.
  //
  // - the current UP could be two values : 1 or DOWN + 1 , and vice versa. 
  // - if A[k] > A[k-1], UP = DWON +1, otherwise UP = 1
  // - if A[K] < A[K-1], DOWN = UP + 1ï¼Œ otherise DOWN = 1
  //
  int maxTurbulenceSize_02(vector<int>& A) {
  if (A.size() <= 1) return A.size();
  int up = 1;
  int down = 1;
  int maxlen = 1;
  for (int k=1; k<A.size(); k++) { 
  //memory the previous UP and Down
  int u = up, d = down;
  up = (A[k] > A[k-1]) ? d + 1 : 1;
  down = (A[k] < A[k-1]) ? u + 1 : 1;
  int len = down > up ? down : up;
  maxlen = len > maxlen ? len : maxlen;
  }
  return maxlen;
  }
  int maxTurbulenceSize(vector<int>& A) {
  return maxTurbulenceSize_02(A);
  return maxTurbulenceSize_01(A);
  }
 };"
215,215,"#include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 int longestValidParentheses(string s) {
  int maxLen = 0;
  int lastError = -1;
  vector<int> stack;
  for(int i=0; i<s.size(); i++){
  if (s[i] == '('){
  stack.push_back(i);
  }else if (s[i] == ')') {
  if (stack.size()>0 ){
  stack.pop_back();
  int len;
  if (stack.size()==0){
  len = i - lastError;
  } else {
  len = i - stack.back();
  }
  if (len > maxLen) {
  maxLen = len;
  }
  }else{
  lastError = i;
  }
  }
  }
  return maxLen;
 }
 int main(int argc, char** argv)
 {
  string s = "")()())"";
  if (argc>1){
  s = argv[1];
  }
  cout << s << "" : "" << longestValidParentheses(s) << endl;
  return 0;
 }"
216,216,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <map>
 using namespace std;
 // The idea here is quite simple:
 // 1) A Map to index the key. O(1) key search time-complexity.
 // 2) A List to sort the cache data by accessed time.
 // 
 // Considering there are too many insert/delete opreations for the List, 
 // The ouble linked list is the good data structure to performance it.
 class Node {
  public:
  int key;
  int value;
  Node *next, *prev;
  Node(int k, int v) { key=k; value=v; next = prev = NULL; }
  //Node(int k, int v, Node* n=NULL, Node* p=NULL): key(k), value(v), next(n), prev(p) {}
 };
 // the following double linked list seems a bit commplicated.
 class DoubleLinkedList {
  private:
  Node *pHead, *pTail;
  int size;
  public:
  DoubleLinkedList(){
  pHead = pTail = NULL;
  size = 0;
  }
  ~DoubleLinkedList() {
  while(pHead!=NULL){
  Node*p = pHead;
  pHead = pHead->next;
  delete p;
  }
  }
  int Size() const {
  return size;
  }
  Node* NewAtBegin(int key, int value) {
  Node *n = new Node(key, value);
  return AddAtBegin(n);
  }
  Node* NewAtEnd(int key, int value) {
  Node *n = new Node(key, value);
  return AddAtEnd(n);
  }
  Node* AddAtBegin(Node* n){
  size++;
  if (pHead==NULL) { 
  pHead = pTail = n; 
  return n; 
  }
  n->next = pHead;
  n->prev = NULL;
  pHead->prev = n;
  pHead = n;
  return n;
  }
  Node* AddAtEnd(Node* n) {
  size++;
  if (pHead==NULL) { 
  pHead = pTail = n; 
  return n; 
  }
  pTail->next = n;
  n->prev = pTail;
  n->next = NULL;
  pTail = n;
  }
  void Unlink(Node* n){
  Node* before = n->prev;
  Node* after = n->next;
  if (before){
  before->next = after; 
  }
  if (after){ 
  after->prev = before;
  }
  if(pHead == n){
  pHead = pHead->next;
  }else if(pTail == n) {
  pTail = pTail->prev;
  }
  size--;
  }
  void Delete(Node* n){
  Unlink(n);
  delete n;
  }
  void TakeToBegin(Node* n){
  Unlink(n);
  AddAtBegin(n);
  } 
  Node* GetTailNode() {
  return pTail;
  } 
  void DeleteLast() {
  Delete(pTail);
  } 
  void Print(){
  Node* p = pHead;
  while(p!=NULL) {
  cout << ""("" << p->key << "","" << p->value << "") "";
  p = p->next;
  }
  cout << endl;
  }
 };
 class LRUCache{
  private:
  //cacheList - store the date
  DoubleLinkedList cacheList;
  //cacheMap - index the date for searching
  map<int, Node*> cacheMap;
  //the max capcity of cache
  int capacity;
  public:
  LRUCache(int capacity) {
  this->capacity = capacity; 
  }
  void print(){
  cacheList.Print();
  }
  int get(int key) {
  // The accessed node must be up-to-time -- take to the front 
  if (cacheMap.find(key) != cacheMap.end() ){
  cacheList.TakeToBegin(cacheMap[key]);
  return cacheMap[key]->value;
  }
  return -1;
  }
  void set(int key, int value) {
  // key found, update the data, and take to the front 
  if (cacheMap.find(key) != cacheMap.end() ){
  Node *p = cacheMap[key];
  p->value = value;
  cacheList.TakeToBegin(cacheMap[key]);
  }else{
  // key not found, new a node to store data
  cacheMap[key] = cacheList.NewAtBegin(key, value);
  // if the capacity exceed, remove the last one.
  if( cacheList.Size() > capacity) {
  int key = cacheList.GetTailNode()->key; 
  cacheMap.erase(key);
  cacheList.DeleteLast();
  }
  }
  }
 };
 int main(int argc, char** argv) 
 {
  /*
  LRUCache c(2);
  c.set(2,1);
  c.print();
  c.set(2,2);
  c.print();
  c.get(2);
  c.print();
  c.set(1,1);
  c.print();
  c.set(4,1);
  c.print();
  c.get(2);
  c.print();
  cout << ""---------"" << endl;
  */
  srand(time(0));
  int capacity = 5;
  int test_loop_times = 10;
  if (argc>1){
  capacity = atoi(argv[1]);
  }
  if (argc>2){
  test_loop_times = atoi(argv[1]);
  }
  LRUCache cache(capacity);
  int v; 
  for(int i=0; i<test_loop_times; i++) {
  v = i;//rand() % capacity;
  cout << ""set "" << v << "": "";
  cache.set(v, v);
  cache.print();
  v = rand() % capacity;
  cout << ""get "" << v << "": "" << cache.get(v);
  cache.print();
  cout << endl;
  }
  return 0;
 }"
217,217,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <string>
 #include <sstream>
 using namespace std;
 // Moore Voting Algorithm
 // Refer to: 
 // http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html
 int majorityElement(vector<int> &num) {
  int majority;
  int cnt = 0;
  for(int i=0; i<num.size(); i++){
  if ( cnt ==0 ){
  majority = num[i];
  cnt++;
  }else{
  majority == num[i] ? cnt++ : cnt --;
  if (cnt > num.size()/2) return majority;
  }
  }
  return majority;
 }
 vector<int> &split(const string &s, char delim, vector<int> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
  elems.push_back(atoi(item.c_str()));
  }
  return elems;
 }
 vector<int> split(const string &s, char delim) {
  vector<int> elems;
  split(s, delim, elems);
  return elems;
 }
 int main(int argc, char** argv)
 {
  //string array = ""1,2,1,2,1,2,1,2,1,2,1"";
  string array = ""2,2,1,1,1"";
  if (argc > 1){
  array = argv[1];
  }
  cout << ""["" << array << ""]"" << endl;
  vector<int> num = split(array, ',');
  cout << majorityElement(num) <<endl;
  return 0;
 }"
218,218,"class Solution {
 public:
  //O(n) Space compexity
  vector<int> majorityElement01(vector<int>& nums) {
  vector<int> result;
  unordered_map<int, int> counts;
  int n = nums.size();
  for(auto item : nums){
  counts[item]++;
  if (counts[item] > n/3 ){
  result.push_back(item); 
  counts[item] = -n; // Tricky: make sure the item only can be put into result once.
  } 
  }
  return result;
  }
  //We know, there could be at most two numbers can be more than 1/3
  //so, same as Majority Element I problem, we can have two counters.
  vector<int> majorityElement02(vector<int>& nums) {
  if(nums.size()<=1) return nums;
  //the same algorithm as Majority Element I problem
  int majority1=0, majority2=0, cnt1=0, cnt2=0;
  for(auto item: nums) {
  if (cnt1 == 0 && majority2 != item ) {
  majority1 = item;
  cnt1 = 1;
  } else if (majority1 == item) {
  cnt1++;
  } else if (cnt2 == 0) {
  majority2 = item;
  cnt2 = 1;
  } else if (majority2 == item) {
  cnt2++;
  } else {
  cnt1--;
  cnt2--;
  }
  }
  //re-check it again, in case there has less than two numbers of majority
  cnt1 = cnt2 = 0;
  for (auto item : nums) {
  if (majority1 == item) cnt1++;
  else if (majority2 == item) cnt2++;
  }
  vector<int> result;
  if (cnt1 > nums.size()/3) result.push_back(majority1);
  if (cnt2 > nums.size()/3) result.push_back(majority2);
  return result;
  }
  vector<int> majorityElement(vector<int>& nums) {
  return majorityElement02(nums);
  return majorityElement01(nums);
  }
 };"
219,219,"/*
  First K length subarray: 
  a1^a2^a3^.....^ak=0 ;
  Second K length subarray :
  a2^a3^a4^....^ak+1=0 ; 
  On combining both : 
  a1^(a2^a3^....^ak)^(a2^a3^....^ak)^a[k+1] =0 
  a1^a[k+1]=0
  Therefore it is easy to see that for any i and j : 
  a[i%k]^a[j%k] = 0 ;
  -> a[i%k]=a[j%k] ;
  Hence, a[1] = a[k+1] = a[2k+1] = ...
  a[2] = a[k+2] = a[2k+2] = ...
  a[3] = a[k+3] = a[2k+3] = ...
  .
  .
  .
  a[k] = a[2k] = a[3k] = ...
  So we just need to obtain the first k length subarray and the rest would be determined by it.
 */
 class Solution {
 public:
  int minChanges(vector<int>& nums, int k) {
  const int max_value = 1024; //0 <= nums[i] < 2^10
  int n = nums.size();
  //freq[i][v] means frequency of the number `v` at `i` position in [0, k-1];
  vector<vector<int>> freq(k, vector<int>(max_value, 0));
  for (int i=0; i<n; i++) {
  freq[i%k][nums[i]]++;
  }
  //dp[i][v] means minimum number of changes in first i elements such that the xor value is `v`
  vector<vector<int>> dp(k, vector<int>(max_value, n+1));
  //initailization
  int minChanges = n + 1;
  for (int v = 0; v < max_value; v++) {
  int cntOfPos = n / k + (((n % k) > 0) ? 1 : 0);
  dp[0][v] = cntOfPos - freq[0][v];
  minChanges = min(minChanges, dp[0][v]);
  } 
  for (int i=1; i<k; i++) {
  // how many i indices exist in the array
  int cntOfPos = n / k + (((n % k) > i) ? 1 : 0);
  //track minimum changes
  int m = n + 1;
  //for all of possible values
  for (int v = 0; v < max_value; v++) {
  for (int j = i; j < n; j += k) {
  int x = v ^ nums[j];
  dp[i][v] = min( dp[i][v], dp[i-1][x] + cntOfPos - freq[i][nums[j]]);
  }
  //for all of numbers don't occur at index i
  dp[i][v] = min(dp[i][v], minChanges + cntOfPos);
  m = min(m, dp[i][v]);
  }
  minChanges = m;
  } 
  return dp[k-1][0];
  }
 };"
220,220,"class Cell{
 public:
  int x;
  int y;
  int height;
 };
 class Solution {
 private:
  void setHeight(vector<vector<int>>& height, 
  queue<Cell>& q,
  int x, int y, int h, 
  int m, int n) 
  {
  if (x < 0 || y < 0 || x>=m || y>=n ) return;
  if (height[x][y] == -1) {
  height[x][y] = h;
  q.push({x, y, h});
  }
  }
 public:
  vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
  int m = isWater.size();
  int n = isWater[0].size();
  vector<vector<int>> height(m, vector(n, -1));
  queue<Cell> q;
  for (int i=0; i<m; i++) {
  for (int j=0; j<n; j++) {
  if (isWater[i][j]) {
  height[i][j] = 0;
  q.push({i, j, 0});
  }
  }
  }
  while(!q.empty()){
  auto cell = q.front(); q.pop();
  setHeight(height, q, cell.x-1, cell.y, cell.height+1, m, n);
  setHeight(height, q, cell.x+1, cell.y, cell.height+1, m, n);
  setHeight(height, q, cell.x, cell.y-1, cell.height+1, m, n);
  setHeight(height, q, cell.x, cell.y+1, cell.height+1, m, n);
  }
  return height;
  }
 };"
221,221,"class Solution {
 public:
  void put(int R, int C, int r, int c, vector<vector<int>>& res) {
  if (r>=0 && r < R && c>=0 && c<C ) {
  res.push_back({r,c});
  }
  }
  vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {
  int n = R+C-2;
  vector<vector<int>> result;
  result.push_back({r0,c0});
  for(int i=1; i<= n; i++) {
  // from (r0-i, c0) to (r0, c0+i)
  for(int r=r0-i,c=c0;r!=r0; r++, c++) put (R, C, r ,c, result);
  // from (r0, c0+i) to (r0+i, c0)
  for(int r=r0, c=c0+i; c!=c0; r++, c-- ) put (R, C, r, c, result);
  // from (r0+i, c0) to (r0, c0-i)
  for (int r=r0+i, c=c0; r!=r0; r--, c--) put (R, C, r, c, result);
  // from (r0, c0-i) to (r0-i, c0)
  for (int r=r0, c=c0-i; c!=c0; r--, c++) put (R, C, r, c, result);
  }
  return result;
  }
 };"
222,222,"class Solution {
 public:
  int maxAreaOfIsland(vector<vector<int>>& grid) {
  int maxArea = 0;
  for (int i=0; i<grid.size(); i++) {
  for(int j=0; j<grid[0].size(); j++) {
  if ( grid[i][j] == 1 ) {
  int area = 0;
  maxAreaOfIsland_DFS(grid, i, j, area);
  maxArea = max( maxArea, area );
  }
  }
  }
  return maxArea;
  }
  void maxAreaOfIsland_DFS( vector<vector<int>>& grid, int i, int j, int& area ) {
  if (i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j] != 1 ) return;
  area++;
  grid[i][j] = -1;
  maxAreaOfIsland_DFS(grid, i-1, j, area);
  maxAreaOfIsland_DFS(grid, i+1, j, area);
  maxAreaOfIsland_DFS(grid, i, j-1, area);
  maxAreaOfIsland_DFS(grid, i, j+1, area);
  }
 };"
223,223,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 // The problem can be convert to the problem - ""Largest Rectangle in Histogram""
 // 1) we can take each row to calculate each row's histogram.
 // 2) using the algorithm of ""Largest Rectangle in Histogram"" to find the largest area histogram.
 // 3) tracking the maximal area.
 //
 // For the 1), it's easy. 
 // heights[i][j] = 1, if (i==0)
 // heights[i][j] = heights[i-1][j] + 1;, if (i>0)
 //
 // For the 2), please referr to ""Largest Rectangle in Histogram""
 // 
 int largestRectangleArea(vector<int> &height) {
  if (height.size()<=0) return 0;
  height.push_back(0);
  vector<int> stack;
  int maxArea=0;
  for(int i=0; i<height.size(); ){
  if (stack.size()==0 || height[i] >= height[ stack.back() ] ){
  stack.push_back(i);
  i++;
  }else{
  int topIdx = stack.back();
  stack.pop_back();
  int area = height[topIdx] * ( stack.size()==0 ? i : i - stack.back() - 1 );
  if (area > maxArea){
  maxArea = area;
  }
  }
  }
  return maxArea;
 }
 int maximalRectangle(vector<vector<char> > &matrix) {
  if (matrix.size()<=0 || matrix[0].size()<=0) return 0;
  int row = matrix.size();
  int col = matrix[0].size();
  vector< vector<int> > heights(row, vector<int>(col));
  int maxArea = 0;
  for(int i=0; i<row; i++){
  for(int j=0; j<col; j++) {
  if (matrix[i][j]=='1'){
  heights[i][j] = (i==0 ? 1 : heights[i-1][j] + 1);
  }
  }
  int area = largestRectangleArea(heights[i]);
  if (area > maxArea){
  maxArea = area;
  }
  }
  return maxArea;
 }
 void printArray(vector<int> &v)
 {
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << ""}"" << endl;
 }
 void test(int a[], int n)
 {
  vector<int> v(a, a + n);
  printArray(v);
  cout << largestRectangleArea(v) << endl;
 }
 int main(int argc, char** argv)
 {
  #define TEST(a) test(a, sizeof(a)/sizeof(int))
  int a0[] = {2,1,3,1};
  TEST(a0);
  int a1[] = {2,1,5,6,2,3};
  TEST(a1);
  cout << ""------------------"" << endl; 
  srand(time(0));
  int r = 3;
  int c = 3;
  if (argc>2){
  r = atoi(argv[1]);
  c = atoi(argv[2]);
  }
  vector< vector<char> > matrix;
  for(int i=0; i<r; i++){
  vector<char> v;
  cout << ""["";
  for(int j=0; j<c; j++) {
  char ch = random()%2+'0';
  v.push_back(ch);
  cout << "" "" << ch;
  }
  matrix.push_back(v);
  cout << "" ]"" << endl;
  }
  cout << ""------------------"" << endl; 
  cout << ""maxArea = "" << maximalRectangle(matrix) << endl;
  return 0;
 }"
224,224,"/*
  * Dynamic Programming
  *
  * 1) P[0][j] = matrix[0][j] (topmost row);
  * 2) P[i][0] = matrix[i][0] (leftmost column);
  * 3) For i > 0 and j > 0: 
  * 3.1) if matrix[i][j] = 0, P[i][j] = 0; 
  * 3.2) if matrix[i][j] = 1, P[i][j] = min(P[i-1][j], P[i][j-1], P[i-1][j-1]) + 1.
  *
  * The details of this algorithm has been well described here.
  * https://leetcode.com/discuss/38489/easy-solution-with-detailed-explanations-8ms-time-and-space
  * 
  * 
  * Well, this problem desires for the use of dynamic programming. They key to any DP problem is to 
  * come up with the state equation. In this problem, we define the state to be the maximal size of
  * the square that can be achieved at point (i, j), denoted as P[i][j]. Remember that we use size
  * instead of square as the state (square = size^2).
  * 
  * Now let's try to come up with the formula for P[i][j].
  * 
  * First, it is obvious that for the topmost row (i = 0) and the leftmost column (j = 0), 
  * P[i][j] = matrix[i][j]. This is easily understood. Let's suppose that the topmost row 
  * of matrix is like [1, 0, 0, 1]. Then we can immediately know that the first and last point 
  * can be a square of size 1 while the two middle points cannot make any square, giving a size of 0. 
  * Thus, P = [1, 0, 0, 1], which is the same as matrix. The case is similar for the leftmost column. 
  * Till now, the boundary conditions of this DP problem are solved.
  * 
  * Let's move to the more general case for P[i][j] in which i > 0 and j > 0. First of all, 
  * let's see another simple case in which matrix[i][j] = 0. It is obvious that P[i][j] = 0 too. 
  * Why? Well, since matrix[i][j] = 0, no square will contain matrix[i][j], according to our 
  * definition of P[i][j], P[i][j] is also 0.
  * 
  * Now we are almost done. The only unsolved case is matrix[i][j] = 1. Let's see an example.
  * 
  * Suppose matrix = [[0, 1], [1, 1]], it is obvious that P[0][0] = 0, P[0][1] = P[1][0] = 1, 
  * what about P[1][1]? Well, to give a square of size larger than 1 in P[1][1], all of its 
  * three neighbors (left, up, left-up) should be non-zero, right? In this case, the left-up 
  * neighbor P[0][0] = 0, so P[1][1] can only be 1, which means that it contains the square of itself.
  * 
  * Now you are near the solution. In fact, P[i][j] = min(P[i-1][j], P[i][j-1], P[i-1][j-1]) + 1 in this case.
  * 
  * 
  */
 class Solution {
 public:
  inline int min(int x, int y) {
  return x<y? x:y;
  }
  inline int min(int x, int y, int z) {
  return min(x, min(y, z));
  }
  int maximalSquare(vector<vector<char>>& matrix) {
  int row = matrix.size();
  if (row <=0) return 0;
  int col = matrix[0].size();
  int maxSize = 0;
  vector<vector<int>> dp(row, vector<int>(col));
  for (int i=0; i<matrix.size(); i++) {
  for (int j=0; j<matrix[i].size(); j++){
  //convert the `char` to `int`
  dp[i][j] = matrix[i][j] -'0';
  //for the first row and first column, or matrix[i][j], dp[i][j] is ZERO
  //so, it's done during the previous conversion
  // i>0 && j>0 && matrix[i][j]=='1'
  if (i!=0 && j!=0 & dp[i][j]!=0){
  dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
  }
  //tracking the maxSize
  if (dp[i][j] > maxSize ){
  maxSize = dp[i][j];
  }
  }
  }
  return maxSize*maxSize;
  }
 };"
225,225,"/*
  considering `primeFactors = 5`
  So, we can have the following options:
  1) [2,3,5,7,11] - all of factors are different, then we only can have 1 nice divisor
  2) [2,2,3,5,7] - we can have 2*1*1*1 = 2 nice divisors: 2*3*5*7 and 2*2*3*5*7
  3) [2,2,3,3,5] - we can have 2*2*1 = 4 nice divisors: 2*3*5ï¼Œ 2*2*3*5ï¼Œ 2*3*3*5ï¼Œ 2*2*3*3*5
  4) [2,2,3,3,3] - we can have 2*3 = 6 nice divisors
  5ï¼‰[2,2,2,2,3] - we can have 4*1 =4 nice divisors: 2*3, 2*2*3, 2*2*2*3, 2*2*2*2*3
  6) [2,2,2,2,2] - we can have 5 nice divisors: 2, 2*2, 2*2*2, 2*2*2*2, 2*2*2*2*2
  So, we can see we must have some duplicated factors.
  And what is the best number of duplication ?
  primeFactors = 1, then 1 - example: [2]
  primeFactors = 2, then 2 - example: [2,2]
  primeFactors = 3, then 3 - example: [5,5,5]
  primeFactors = 4, then 4 = 2*2 - example: [2,2,5,5])
  primeFactors = 5, then 5 = 2*3 - example: [3,3,3,5,5])
  primeFactors = 5, then 6 = 3*3 - example: [3,3,3,5,5,5])
  primeFactors = 7, then 3*4 = 12 - example: [3,3,3,5,5,5,5])
  primeFactors = 8, then 3*3*2 = 18 whcih > (2*2*2*2, 2*4*2, 3*5)
  primeFactors = 9, then 3*3*3 = 27 
  primeFactors = 10, then 3*3*4 = 36
  So, we can see the '3' & '4' are specifial,
  - most of case, we can be greedy for `3`
  - but if the final rest is 4, then we need take 4.
  */
 const int mod = 1000000007;
 class Solution {
 public:
  int maxNiceDivisors(int primeFactors) {
  return maxNiceDivisors_03(primeFactors);
  return maxNiceDivisors_02(primeFactors); //TLE
  return maxNiceDivisors_01(primeFactors); //TLE
  }
  int maxNiceDivisors_01(int primeFactors) {
  int result = 1;
  while ( primeFactors > 4 ) {
  primeFactors -= 3;
  result = (result * 3l) % mod;
  }
  result = (result * (long)primeFactors) % mod;
  return result;
  }
  int maxNiceDivisors_02(int primeFactors) {
  if (primeFactors <= 4 ) return primeFactors;
  int result = 1;
  for (int i = 4; i > 0; i-- ){
  if ((primeFactors - i) % 3 == 0){ 
  result = i;
  primeFactors -= i;
  // now, `primeFactors` is 3 times - 3X
  // we need convert 3X to 3^X
  for (int x = primeFactors/3; x > 0; x-- ) {
  result = (result * 3l) % mod;
  }
  break;
  }
  }
  return result;
  }
  int pow3(int x) {
  long result = 1;
  long factor = 3;
  while(x > 0) {
  if (x & 1) {
  result = (result * factor) % mod;
  }
  factor *= factor;
  factor %= mod;
  x /= 2;
  }
  return result % mod;
  }
  int maxNiceDivisors_03(int primeFactors) {
  if (primeFactors <= 4 ) return primeFactors;
  int result = 1;
  for (int i = 4; i > 0; i-- ){
  if ((primeFactors - i) % 3 == 0){ 
  primeFactors -= i;
  // now, `primeFactors` is 3 times - 3X
  // we need convert 3X to 3^X
  int x = primeFactors / 3;
  result = (long(i) * pow3(x)) % mod;
  break;
  }
  }
  return result;
  }
 };"
226,226,"/*
  // The basic algorthim come from
  // https://leetcode.com/problems/longest-palindromic-subsequence/
  int longestPalindromeSubseq(string& s) {
  int n = s.size(); 
  vector<vector<int>> dp(n, vector<int>(n, 0));
  for (int start = n-1; start>=0; start--) {
  for (int end = start ; end < n ; end++) {
  if (start == end) {
  dp[start][end] = 1;
  continue;
  }
  if (s[start] == s[end]) {
  dp[start][end] = dp[start+1][end-1] + 2;
  }else{
  dp[start][end] = max (dp[start+1][end], dp[start][end-1]);
  }
  }
  }
  return dp[0][n-1];
  }
 */
 class Solution {
 public:
  int longestPalindrome(string word1, string word2) {
  string s = word1 + word2;
  int n = s.size(); 
  vector<vector<int>> dp(n, vector<int>(n, 0));
  int result = 0; 
  for (int start = n-1; start>=0; start--) {
  for (int end = start ; end < n ; end++) {
  if (start == end) {
  dp[start][end] = 1;
  continue;
  }
  if (s[start] == s[end]) {
  dp[start][end] = dp[start+1][end-1] + 2;
  // <----------- different -----------> 
  //only consider when `start` and `end` in different string.
  if (start < word1.size() && end >= word1.size()){
  result = max(result, dp[start][end]);
  }
  // <----------- different -----------> 
  }else{
  dp[start][end] = max (dp[start+1][end], dp[start][end-1]);
  }
  }
  } 
  return result;
  }
 };"
227,227,"class Solution {
 private:
  // Euclidean algorithm
  // https://en.wikipedia.org/wiki/Euclidean_algorithm
  int gcd(int a, int b) {
  while(a != b) {
  if(a > b) a = a - b;
  else b = b - a;
  }
  return a;
  }
  unordered_map<int, int> cache;
 public:
  int maxScore(vector<int>& nums) {
  int n = nums.size();
  vector<vector<int>> pair_gcd(n, vector<int>(n, 0) );
  for (int i=0; i< n - 1; i++) {
  for (int j=i+1; j < n; j++ ) {
  pair_gcd[i][j] = gcd(nums[i], nums[j]);
  }
  }
  // used_mark[] - remember the num has been used.
  return maxScore(pair_gcd, 0, n, n/2);
  }
  int maxScore(vector<vector<int>>& pair_gcd, int mask, int n, int step) {
  if (cache.find(mask) != cache.end()) {
  return cache[mask];
  }
  int m = 0;
  for (int i=0; i< n - 1; i++) {
  if ( (1<<i) & mask ) continue;
  for (int j=i+1; j < n; j++ ) {
  if ((1<<j) & mask) continue;
  if (step == 1) {
  return pair_gcd[i][j];
  }
  m = max(m, step * pair_gcd[i][j] + 
  maxScore(pair_gcd, mask | (1<<i) | (1<<j), n, step-1));
  }
  }
  cache[mask] = m;
  return m;
  }
 };"
228,228,"class Solution {
 public:
  int maxAbsoluteSum(vector<int>& nums) {
  return maxAbsoluteSum02(nums); //56ms
  return maxAbsoluteSum01(nums); //56ms
  }
  int maxAbsoluteSum01(vector<int>& nums) {
  return std::max(maxSumArray(nums), std::abs(minSumArray(nums)) );
  }
  //https://en.wikipedia.org/wiki/Maximum_subarray_problem
  int maxSumArray(vector<int>& nums) {
  int max = nums[0];
  int sum = nums[0];
  for (int i = 1; i < nums.size(); i++) {
  if (sum < 0 ) sum = nums[i];
  else sum += nums[i];
  if (max < sum) max = sum;
  }
  return max;
  }
  int minSumArray(vector<int>& nums) {
  int min = nums[0];
  int sum = nums[0];
  for (int i = 1; i < nums.size(); i++) {
  if (sum > 0 ) sum = nums[i];
  else sum += nums[i];
  if (min > sum) min = sum;
  }
  return min;
  }
  // Becasue maxSumArray() & minSumArray() are two similar,
  // we can merge them together to save one loop
  int maxAbsoluteSum02(vector<int>& nums) {
  int max = nums[0];
  int max_sum = nums[0];
  int min = nums[0];
  int min_sum = nums[0];
  for (int i = 1; i < nums.size(); i++) {
  if (max_sum < 0 ) max_sum = nums[i];
  else max_sum += nums[i];
  if (max < max_sum) max = max_sum;
  if (min_sum > 0 ) min_sum = nums[i];
  else min_sum += nums[i];
  if (min > min_sum) min = min_sum;
  }
  return std::max(max, abs(min));
  }
 };"
229,229,"class Solution {
 public:
  int maxAscendingSum(vector<int>& nums) {
  int maxSum = nums[0];
  int sum = maxSum;
  for(int i=1; i<nums.size(); i++) {
  if (nums[i] > nums[i-1]) {
  sum += nums[i];
  }else{
  maxSum = maxSum < sum ? sum : maxSum;
  sum = nums[i];
  }
  }
  maxSum = maxSum < sum ? sum : maxSum;
  return maxSum;
  }
 };"
230,230,"class Solution {
 private:
  template<typename T>
  void print_queue(T q) { // NB: pass by value so the print uses a copy
  while(!q.empty()) {
  auto [profit, c] = q.top();
  auto [pass, total] = c;
  cout << ""["" << profit << "" - "" << pass << "", "" << total <<""], "";
  q.pop();
  }
  cout << '\n';
  }
  //calculating ratio
  double ratio(double pass, double total) {
  return pass / total;
  }
  //calculating the profit
  double profit(double pass, double total) {
  return ratio(pass + 1, total + 1) - ratio(pass, total);
  }
 public:
  double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
  priority_queue<pair<double, pair<int,int>> > q;
  double total_ratio = 0;
  int cnt = 0;
  for (auto& c : classes) {
  total_ratio += ratio(c[0], c[1]);
  q.push({profit(c[0], c[1]), {c[0],c[1]}});
  }
  //print_queue(q);
  while(extraStudents--){
  auto [added_profit, c] = q.top();
  auto [pass, total] = c;
  q.pop();
  total_ratio += added_profit;
  pass++; total++;
  q.push({profit(pass, total), {pass, total}});
  }
  //print_queue(q);
  return total_ratio / classes.size();
  }
 };"
231,231,"class Solution {
 public:
  double findMaxAverage(vector<int>& nums, int k) {
  int sum=0;
  for(int i=0; i<k; i++ ) {
  sum += nums[i];
  }
  int s = sum;
  for (int i=k; i< nums.size(); i++) {
  s += nums[i];
  s -= nums[i-k];
  if (s > sum) {
  sum = s;
  }
  }
  return (double)sum/k;
  }
 };"
232,232,"/* 
 At first , it's not difficult to work out the max height between two buildings.
 **Case study**
 considering the following restractions:
 1) Building #1 `max-height = 1`, Building #5 `max-height = 1`
  then we can have the building height list - `[1,2,3,2,1] `
 2) Building #1 `max-height = 3`, Building #5 `max-height = 1`
  then we can have the building height list - `[3,4,3,2,1]` 
 3) Building #1 `max-height = 1`, Building #5 `max-height = 9`
  then we can have the building height list - `[1,2,3,4,5]`
 So, we can figure out the following rules :
 1) if two restraction has same limited height, suppose we have `[n ......... n]`, 
  then we can have the building height list `[n, n+1, n+2, ... n+m-1, n+m, n+m-1 ..., n+2, n+1, n]`
 So, **`m = width /2`** - the `width` is the number of buildings. 
 2) if two restraction has different limited height, suppose we have `[n ...... n+x]`
  then we still can have the building height list like 1) - we just add some buildings behind `[n .... n+x, (n+x-1... n) ]`
 So, **`m = (width+x)/2`** - we need to extend x buildings
 3) if there hasn't enough buildings between two restractions. then, the max height we can make is **`width`**. For examples:
  - Building#1 max-height = 2, building#3 max-height = 5 : then, we only can make `[2,3,4]`
  - Building#1 max-height = 2, building#2 max-height = 9 : then, we only can make `[2,3]`
 So, we can have the following source code to calculate the max height between two restractions.
 ```
  int getMaxHeight(vector<int>& left, vector<int>& right) {
  int width = right[0] - left[0];
  int height_delta = abs(right[1] - left[1]);
  int min_height = min (left[1], right[1]);
  //if the `width` is enough to have `height_delta`
  if (width >= height_delta) return min_height + (width + height_delta) / 2;
  // if the `width` is not enought have `height_delta`
  // then, the `width` is the max height we can make
  int max_height = min_height + width;
  return max_height;
  }
 ```
 BUT, we still have a case need to deal with, considering we have the following restractions:
 `[1,1], [2,2] ,[3,3], [4,0]`
 we can process them couple by couple.
 - step 1: `[1,1], [2,2]` : max-height = 2
 - step 2: `[2,2] ,[3,3]` : max-height = 3
 - step 3: `[3,3], [4,0]` : max-height = 1
 for the last couple of restractions, we can see the building#3 max-height is 1, so we have go backwards to recaluate the building#2 and building#1.
 - step 3: `[3,1], [4,0]` : max-height = 1 (change the `[3,3]` to `[3,1]` )
 - step:4: `[2,2] ,[3,1]` : max-height = 2
 - step 5: `[1,1], [2,2]` : max-height = 2
 So, the correct answer of max height is `2`
 finally, we have the whole source code with debug code inside.
 */
 class Solution {
 private:
  void print(vector<vector<int>>& vv){
  cout << ""["" ;
  for(int i = 0; i < vv.size()-1; i++) {
  cout << ""["" <<vv[i][0] << "","" << vv[i][1] << ""],"";
  }
  int i = vv.size() - 1;
  cout << ""["" << vv[i][0] << "","" << vv[i][1] << ""]]"" << endl;
  }
 public:
  int getMaxHeight(vector<int>& left, vector<int>& right) {
  int width = right[0] - left[0];
  int height_delta = abs(right[1] - left[1]);
  int min_height = min (left[1], right[1]);
  //if the `width` is enough to have `height_delta`
  if (width >= height_delta) return min_height + (width + height_delta) / 2;
  // if the `width` is not enought have `height_delta`
  // then, the `width` is the max height we can make
  int max_height = min_height + width;
  // if the restriction is higher then make it to right limitation.
  left[1] = min (left[1], max_height);
  right[1] = min (right[1], max_height);
  return max_height;
  }
  int maxBuilding(int n, vector<vector<int>>& restrictions) {
  restrictions.push_back({1,0});
  restrictions.push_back({n, n-1});
  sort(restrictions.begin(), restrictions.end());
  //print(restrictions);
  for(int i=0; i<restrictions.size()-1; i++){
  int height = getMaxHeight(restrictions[i], restrictions[i+1]);
  //cout << ""["" << restrictions[i][0] << "","" << restrictions[i][1]<< ""] - ""
  // << ""["" << restrictions[i+1][0] << "","" << restrictions[i+1][1]<< ""] = ""
  // << height << endl;
  }
  cout << endl;
  int maxHeight = 0;
  for(int i= restrictions.size()-1; i>0; i--){
  int height = getMaxHeight(restrictions[i-1], restrictions[i]);
  //cout << ""["" << restrictions[i-1][0] << "","" << restrictions[i-1][1]<< ""] - ""
  // << ""["" << restrictions[i][0] << "","" << restrictions[i][1]<< ""] = ""
  // << height << endl;
  maxHeight = max(maxHeight, height);
  }
  // cout << endl;
  return maxHeight;
  }
 };"
233,233,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  int maxDepth(TreeNode *root) {
  if (root==NULL){
  return 0;
  }
  if (!root->left && !root->right){
  return 1;
  }
  int left=1, right=1;
  if (root->left){
  left += maxDepth(root->left);
  }
  if (root->right){
  right += maxDepth(root->right);
  }
  return left>right?left:right;
  }
 };
 class Solution2 {
 public:
  int maxDepth(TreeNode *root) {
  if (root==NULL) return 0;
  return max(maxDepth(root->left), maxDepth(root->right)) + 1;
  }
 };"
234,234,"class Solution {
 public:
  int maxDistance(vector<int>& nums1, vector<int>& nums2) {
  return maxDistance2(nums1, nums2);
  return maxDistance1(nums1, nums2);
  }
  int binary_search(vector<int>& nums, int start, int target) {
  int end = nums.size() - 1;
  while (start <= end) {
  int mid = start + (end - start) /2;
  if(nums[mid] < target) end = mid - 1;
  else start = mid+1;
  }
  return end;
  }
  int maxDistance1(vector<int>& nums1, vector<int>& nums2) {
  int mDist=0;
  int right = nums2.size() - 1;
  for(int i=0; i<nums1.size(); i++) {
  int j = binary_search(nums2, i, nums1[i]);
  mDist = max(mDist, j-i);
  }
  return mDist;
  }
  int maxDistance2(vector<int>& nums1, vector<int>& nums2) {
  int i=0, j=0, dist = 0;
  while (i < nums1.size() && j < nums2.size() ){
  if ( nums1[i] > nums2[j] ) i++;
  else dist = max(dist, j++ - i);
  }
  return dist;
  }
 };"
235,235,"class Solution {
 public:
  int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {
  sort(arr.begin(), arr.end());
  int m = arr[0] = 1;
  for(int i=0; i<arr.size()-1; i++) {
  if (abs(arr[i] - arr[i+1]) <= 1) {
  m = max(arr[i], arr[i+1]);
  continue;
  }
  arr[i+1] = arr[i] + 1;
  m = arr[i+1];
  }
  return m;
  }
 };"
236,236,"class Solution {
 public:
  int maximumUniqueSubarray(vector<int>& nums) {
  //unordered_map<int, int> pos;
  const int NIL = -1;
  int pos[10001];
  memset(pos, NIL, sizeof(pos));
  int start=0;
  int max_sum =0, sum = 0;
  for(int i = 0; i < nums.size(); i++) {
  int n = nums[i];
  // if find duplicated number
  if ( pos[n] != NIL) {
  max_sum = max(max_sum, sum);
  //remove the previous numbers until to duplicatied position 
  for(;start <= pos[n]; start++){
  sum -= nums[start];
  pos[nums[start]] = NIL;
  }
  }
  sum += n;
  pos[n] = i;
  }
  max_sum = max( max_sum , sum );
  return max_sum;
  }
 };"
237,237,"#include <iostream>
 #include <vector>
 using namespace std;
 int maximumGap(vector<int> &num) {
  if (num.size() < 2) return 0;
  //find the max & min element
  int min=num[0], max=num[0];
  for(int i=1; i<num.size(); i++){
  min = min > num[i] ? num[i] : min;
  max = max < num[i] ? num[i] : max;
  }
  //Divide the interval [min, max] into n ""buckets"" of equal size = (max -min)/n
  int bucket_size = (max - min)/num.size() + 1;
  //For each of the remaining n-2 numbers, determin in which bucket it falls .
  //The number num[i] belongs to the kth bucket B[k] if and only if (num[i]-min)/m = k-1
  vector< vector<int> > buckets ( (max-min)/bucket_size + 1);
  //For each bucket B[k], compute its max & min among the numbers which falls in B[k].
  //if the bucket is empty, remain it nothing.
  //if the bucket has one number, make this number as both max & min 
  for(int i=0; i<num.size(); i++){
  int idx = (num[i] - min) / bucket_size ;
  if (buckets[idx].empty()){
  buckets[idx].push_back(num[i]);
  buckets[idx].push_back(num[i]);
  }else{
  buckets[idx][0] = buckets[idx][0] > num[i] ? num[i] : buckets[idx][0];
  buckets[idx][1] = buckets[idx][1] < num[i] ? num[i] : buckets[idx][1];
  }
  }
  //calculate the max gap
  int maxGap = 0;
  int prev = 0;
  for (int i = 1; i < buckets.size(); i++) {
  if (buckets[i].empty()) continue;
  int gap = buckets[i][0] - buckets[prev][1];
  maxGap = maxGap > gap ? maxGap : gap;
  prev = i;
  }
  return maxGap;
 }
 int main()
 {
  //int a[] = {3, 6, 19, 1};
  int a[] = {1,1,1,1,1,5,5,5,5,5};
  vector<int> num(a, a+sizeof(a)/sizeof(a[0]));
  cout << maximumGap(num) << endl;
  return 0;
 }"
238,238,"class Solution {
 public:
  int maxIceCream(vector<int>& costs, int coins) {
  sort(costs.begin(), costs.end());
  int cnt = 0;
  for(int i=0; i<costs.size() && costs[i] <= coins; i++) {
  cnt++;
  coins -= costs[i];
  }
  return cnt;
  }
 };"
239,239,"class Solution {
 private:
  int sum(int n) {
  int s = 0;
  for(; n > 0; n /= 10){
  s += n % 10;
  }
  return s;
  }
 public:
  int countBalls(int lowLimit, int highLimit) {
  int cnt[46] ={0}; //10^5 means 9+9+9+9+9 = 45
  int m = 0;
  for (int n = lowLimit; n<=highLimit; n++) {
  int box = sum(n);
  cnt[box]++;
  m = max(m, cnt[box]);
  }
  return m;
  }
 };"
240,240,"class Solution {
 public:
  int getMaximumConsecutive(vector<int>& coins) {
  int maxNum = 1; //at least, we can make 0
  //sort the coins
  sort(coins.begin(), coins.end());
  //If we can make X, it means we can make [1,2,3,4,...X]
  //So, if Y <= X, then we can make [Y+1, Y+2, Y+3.... Y+X]
  //It meas we can make X+Y
  for (auto& c : coins) {
  if (c > maxNum) break;
  maxNum += c;
  }
  return maxNum;
  }
 };"
241,241,"class Solution {
 private:
  static const bool comp_start(vector<int>& x, vector<int>& y) {
  if ( x[0] != y[0] ) return x[0] < y[0];
  return x[1] < y[1];
  }
  static const bool comp_end(vector<int>& x, vector<int>& y) {
  if ( x[1] != y[1] ) return x[1] < y[1];
  return x[0] < y[0];
  }
  //union find
  int find(int x, vector<int>& f) {
  if(f[x] == x) {
  return x;
  } else {
  return f[x] = find(f[x], f);
  }
  }
  void print(vector<vector<int>>& events){
  cout << ""["" ;
  for(auto e: events) {
  cout << ""["" << e[0] << "","" << e[1] << ""],"" ;
  }
  cout << ""]"" << endl;
  }
 public:
  int maxEvents(vector<vector<int>>& events) {
  return maxEvents_priority_queue(events);//332ms
  return maxEvents_union_find(events); // 336ms
  }
  int maxEvents_priority_queue(vector<vector<int>>& events) {
  std::sort(events.begin(), events.end(), comp_start);
  //print(events);
  int start = events[0][0];
  int end = 0;
  for(auto& e:events){
  end = max(end, e[1]);
  }
  int result = 0;
  int i = 0;
  priority_queue<int, vector<int>, greater<int>> pq;
  for (int day = start; day <= end; day++) {
  while (i<events.size() && events[i][0]==day) {
  pq.push(events[i][1]); //push the ending day
  i++;
  }
  //remove out-of-date event
  while(!pq.empty() && pq.top() < day) {
  pq.pop();
  }
  //if there still has event, then choose current day.
  if (!pq.empty()){
  pq.pop();
  result++;
  }
  //no more date need to process
  if (pq.empty() && i >= events.size()) break;
  }
  return result;
  }
  int maxEvents_union_find(vector<vector<int>>& events) {
  std::sort(events.begin(), events.end(), comp_end);
  int end = events[events.size()-1][1];
  int start = end;
  for(auto& e:events){
  start = min(start, e[0]);
  }
  vector<int> dict;
  for (int i=0; i<=end-start+1; i++){
  dict.push_back(i);
  }
  int result = 0;
  for(auto& e : events) {
  int x = find(e[0]-start, dict);
  if ( x <= e[1]-start ){
  result++;
  dict[x] = find(x+1, dict);
  }
  }
  return result;
  }
 };"
242,242,"class Solution {
 private:
  static const bool comp_start(vector<int>& x, vector<int>& y) {
  if ( x[0] != y[0] ) return x[0] < y[0];
  return x[1] < y[1];
  }
  static const bool comp_end(vector<int>& x, vector<int>& y) {
  if ( x[1] != y[1] ) return x[1] < y[1];
  return x[0] < y[0];
  }
  void print(vector<vector<int>>& events){
  cout << ""["" ;
  for(int i = 0; i<events.size(); i++) {
  cout << ""[""; 
  for (int j = 0; j < events[i].size(); j++) {
  cout << events[i][j] << (j == events[i].size() - 1 ? """":"","") ;
  }
  cout << (i == events.size()-1 ? ""]"": ""],"") ;
  }
  cout << ""]"" << endl;
  }
 public:
  int maxValue(vector<vector<int>>& events, int k) {
  //Solution3 - DP
  std::sort(events.begin(), events.end(), comp_end);
  return maxValueDP(events, k); 
  std::sort(events.begin(), events.end(), comp_start);
  //Solution 2 - DFS with cache --> Time Limit Exceeded
  vector<vector<int>> cache(events.size()+1, vector<int>(k+1, -1));
  return maxValueDFS(events, 0, k, cache);
  //Solution 1 - DFS --> Time Limit Exceeded
  return maxValueDFS(events, 0, k); 
  }
  //binary search to find the first event which start day is greater than the `day`
  /* 
  * for (int i = low; i < events.size(); i++) {
  * if ( events[i][0] > day ) break;
  * }
  */
  int findNextEvent(vector<vector<int>>& events, int low, int day) {
  int high = events.size() - 1;
  while (low < high) {
  int mid = low + (high - low) / 2;
  if ( events[mid][0] <= day) {
  low = mid + 1;
  }else{
  high = mid;
  }
  }
  return ( events[low][0] > day ) ? low : low+1;
  }
  int maxValueDFS(vector<vector<int>>& events, int current, int k) {
  if (current >= events.size() || k == 0 ) return 0;
  // if we select the events[index], then find the next events
  int next = findNextEvent(events, current, events[current][1]);
  // we have two choice, attend the event or not
  int attend = events[current][2] + maxValueDFS(events, next, k-1);
  int skip = maxValueDFS(events, current + 1, k);
  return std::max(attend, skip);
  }
  int maxValueDFS(vector<vector<int>>& events, int current, int k, vector<vector<int>>& cache) {
  if (current >= events.size() || k == 0 ) return 0;
  //if find in cache, then return
  if (cache[current][k] != -1) return cache[current][k];
  // if we select the events[index], then find the next events
  int next = findNextEvent(events, current, events[current][1]);
  // we have two choice, attend the event or not
  int attend = events[current][2] + maxValueDFS(events, next, k-1);
  int skip = maxValueDFS(events, current + 1, k);
  return cache[current][k] = std::max(attend, skip);
  }
  //binary search to find the nearest previous event which ending day is less than the `day`
  /* 
  * for (int i = high; i >= 0; i++) {
  * if ( events[i][1] < day ) break;
  * }
  */
  int findPrevEvent(vector<vector<int>>& events, int high, int day) {
  int low = 0;
  while (low < high) {
  int mid = low + (high - low) / 2;
  if ( events[mid][1] < day) {
  low = mid + 1;
  }else{
  high = mid;
  }
  }
  return low - 1;
  }
  int maxValueDP(vector<vector<int>>& events, int k) {
  // for each event, find the previous nearest event which 
  // ending day is less than its starting day
  for (int i = 0; i < events.size(); i++) {
  events[i].push_back( findPrevEvent(events, i, events[i][0]));
  }
  //print(events);
  vector<vector<int>> dp(events.size(), vector<int>(k, 0));
  //---== initial the dp table ==---
  //if we only have first event
  for(int i = 0; i<k; i++) {
  dp[0][i] = events[0][2];
  }
  //if we only can attend one event.
  for (int i = 1; i < events.size(); i++) {
  dp[i][0] = max(dp[i-1][0], events[i][2]);
  }
  for (int times = 1; times<k; times++) {
  for (int current = 1; current < events.size(); current++) {
  int prev = events[current][3];
  int attend = (prev == -1) ? 
  events[current][2]: // not found the previous event
  dp[prev][times-1] + events[current][2]; //found previouse event
  int skip = dp[current-1][times];
  dp[current][times] = max (attend, skip );
  }
  }
  //print (dp);
  return dp.back().back();
  }
 };"
243,243,"class Solution {
 public:
  int maxHappyGroups(int batchSize, vector<int>& groups) {
  vector<int> reminder(batchSize, 0);
  for(auto& g : groups) {
  reminder[g % batchSize]++;
  }
  // greedy for reminder is zero and two groups reminder is zero.
  // for example: batchSize = 3, groups = [1,2,3,4,5,6]
  // then we will find: (3) (6) (1,5) (2,4) 
  // greedy for one group
  int result = reminder[0]; 
  //greedy for two groups
  for (int i=1; i<=batchSize/2; i++){
  if (reminder[i] == 0 || reminder[batchSize-i] == 0 ) continue;
  int m = (i == batchSize-i) ? 
  reminder[i]/2 :
  min(reminder[i], reminder[batchSize-i]);
  reminder[i] -= m;
  reminder[batchSize-i] -= m;
  result += m;
  }
  map<vector<int>, int> cache;
  //DFS for the rest groups
  result += dfs(reminder, batchSize, 0, cache);
  return result;
  }
  int dfs(vector<int>& reminder, int batchSize, int sum, map<vector<int>, int>& cache) {
  if (cache.find(reminder) != cache.end()) return cache[reminder];
  int ret = 0; 
  int bonus = sum == 0 ? 1: 0;
  for(int i=1; i<batchSize; i++) {
  if (reminder[i] <= 0) continue;
  reminder[i]--;
  ret = max(ret, bonus + dfs(reminder, batchSize, (sum + i) % batchSize, cache));
  reminder[i]++;
  }
  cache[reminder] = ret;
  return ret;
  }
 };"
244,244,"class Solution {
 public:
  int maximumPopulation(vector<vector<int>>& logs) {
  vector<vector<int>> year;
  for(auto& log : logs) {
  year.push_back({log[0], 1});
  year.push_back({log[1], -1});
  }
  sort(year.begin(), year.end());
  int x = year[0][0];
  int cnt = 0, max_cnt = 0;
  for(int i=0; i< year.size(); i++) {
  cnt += year[i][1];
  if (max_cnt < cnt) {
  max_cnt = cnt;
  x = year[i][0];
  }
  }
  return x;
  }
 };"
245,245,"class Solution {
 public:
  int maxProduct(vector<int>& nums) {
  int max1=max(nums[0], nums[1]);
  int max2=min(nums[0], nums[1]);
  for (int i=2; i< nums.size(); i++) {
  if (nums[i] > max1) {
  max2 = max1;
  max1 = nums[i];
  continue;
  }else if (nums[i] > max2) {
  max2 = nums[i];
  }
  }
  return (max1-1)*(max2-1);
  }
 };"
246,246,"class Solution {
 public:
  //
  // there are two algorithms:
  //
  // 1) compare two words is same or not 
  // - we can use bit-mask to solve that. 
  // - we need be careful about one word is subset of another one, such as: ""abc"" is subset of ""abcabc""
  //
  // 2) find out the max product - that needs O(N^2) time complexity algorithm.
  //
  int maxProduct(vector<string>& words) {
  //Key is the word's bitmask, and the value the max length of that bit mask
  unordered_map<int, int> maxLens;
  //constructing the bitmask.
  for(auto& w: words) {
  int mask = 0;
  for (auto& c: w) {
  mask = mask | ( 1 << (c-'a') );
  }
  if ( maxLens.find(mask) == maxLens.end() || maxLens[mask] < w.size() ) {
  maxLens[mask] = w.size();
  }
  }
  //find out the max product
  int result = 0;
  for (auto a : maxLens) {
  for (auto b: maxLens) {
  // if `a` and `b` is same, then just simply continue
  if (a.first & b.first) continue; // there are common letters
  result = max( result, a.second * b.second );
  }
  }
  return result;
  }
 };"
247,247,"#include <iostream>
 #include <algorithm>
 using namespace std;
 int max(int x, int y) {
  return x>y?x:y;
 }
 int min(int x, int y){
  return x<y?x:y;
 }
 int max(int x, int y, int z) {
  return max(x, max(y,z));
 }
 int min(int x, int y, int z) {
  return min(x, min(y, z));
 }
 // The idea is similar with ""Find the subarray wich has the largest sum""
 // (See: http://en.wikipedia.org/wiki/Maximum_subarray_problem)
 // 
 // The only thing to note here is, maximum product can also be obtained by minimum (negative) product 
 // ending with the previous element multiplied by this element. For example, in array {12, 2, -3, -5, -6, -2}, 
 // when we are at element -2, the maximum product is multiplication of, minimum product ending with -6 and -2.
 //
 int maxProduct(int A[], int n) {
  // To remember the max/min product for previous position
  int maxPrev = A[0], minPrev = A[0];
  // To remember the max/min product for current position
  int maxHere = A[0], minHere = A[0];
  // Overall maximum product
  int maxProd = A[0];
  for (int i=1; i<n; i++){
  maxHere = max( maxPrev * A[i], minPrev * A[i], A[i] );
  minHere = min( maxPrev * A[i], minPrev * A[i], A[i] );
  //Keep tracking the overall maximum product
  maxProd = max(maxHere, maxProd);
  //Shift the current max/min product to previous variables
  maxPrev = maxHere;
  minPrev = minHere;
  }
  return maxProd; 
 }
 #define TEST(a) cout << maxProduct( a, sizeof(a)/sizeof(int)) << endl
 int main()
 {
  int o[] = {2,3,-2,4};
  TEST(o);
  int a[] = {-4,-3};
  TEST(a);
  int b[] = {-1, -1};
  TEST(b);
  int c[] = {-1, 0, -2};
  TEST(c);
 }"
248,248,"const int MAX_SIZE = 1000;
 class Solution {
 private:
  int cache[MAX_SIZE][MAX_SIZE]; // num of left picked, num of right picked.
  int m, n;
 public:
  int maximumScore(vector<int>& nums, vector<int>& multipliers) {
  memset(cache, -1, sizeof(cache));
  n = nums.size();
  m = multipliers.size();
  return maximumScoreDFS(nums, 0, n-1, multipliers, 0 );
  }
  int maximumScoreDFS(vector<int>& nums, int left, int right, 
  vector<int>& multipliers, int midx) {
  if(midx >= m ) return 0;
  int nLeft = left; // num of left nums[] picked.
  int nRight = (n-1)-right; // num of right nums[] picked.
  if (cache[nLeft][nRight]!=-1) return cache[nLeft][nRight];
  int pickLeft = maximumScoreDFS(nums, left+1, right, multipliers, midx+1) +
  multipliers[midx] * nums[left];
  int pickRight = maximumScoreDFS(nums, left, right-1, multipliers, midx+1) +
  multipliers[midx] * nums[right];
  cache[nLeft][nRight] = max(pickLeft, pickRight);
  return cache[nLeft][nRight];
  }
 };"
249,249,"class Solution {
 private:
  bool can_move(int a, int b, int c) {
  int cnt = 0 ;
  if ( a > 0 ) cnt++;
  if ( b > 0 ) cnt++;
  if ( c > 0 ) cnt++;
  return cnt >= 2;
  }
  void swap(int& x, int& y){
  int t = x;
  x = y;
  y = t;
  }
  void sort(int& a, int& b, int& c) {
  if (a < b) swap(a, b);
  if (b < c) swap(b, c);
  if (a < b) swap(a, b);
  }
 public:
  int maximumScore(int a, int b, int c) {
  return maximumScore_math(a, b, c); //0
  return maximumScore_loop(a, b, c); //20ms
  }
  int maximumScore_loop(int a, int b, int c) {
  //the optimal way it always remove one stone from the biggest 2 piles
  int score = 0;
  while ( can_move(a, b ,c) ) {
  score++;
  sort(a, b ,c);
  a--; b--;
  }
  return score;
  }
  int maximumScore_math(int a, int b, int c) {
  // sort a > b > c
  sort(a, b, c);
  // if `a` is large enough which always has stone for `b` and `c`
  if ( b+c <= a ) return b+c;
  //if b+c > a, which means we always can find two stones, so the score is (a+b+c)/2
  return (a+b+c)/2;
  }
 };"
250,250,"class Solution {
 public:
  int maximumGain(string s, int x, int y) {
  char key[] =""ab"";
  if (y > x) { key[0] = 'b'; key[1]='a';}
  int high = max(x,y);
  int low = min(x,y);
  //greedy for high score
  int score = 0;
  stack<char> left_stack;
  for (int i=0; i<s.size(); i++) {
  char c = s[i];
  if ( left_stack.empty() || //stack is empty, just push directly
  ( c != key[0] && c != key[1] ) ) { // not the score char, just tpush cirectory
  left_stack.push(c);
  continue;
  }
  // if we meet the high score pattern
  if ( c == key[1] && left_stack.top() == key[0]){
  //cout << key << endl;
  left_stack.pop();
  score += high;
  continue;
  }
  left_stack.push(c);
  }
  //process the low score
  stack<char> right_stack;
  while(!left_stack.empty()) {
  char c = left_stack.top(); left_stack.pop();
  if (right_stack.empty() || c != key[0] && c != key[1]) {
  right_stack.push(c);
  continue;
  }
  // if we meet the low score pattern
  if ( c == key[1] && right_stack.top() == key[0]){
  right_stack.pop();
  score += low;
  continue;
  }
  right_stack.push(c);
  }
  return score;
  }
 };"
251,251,"class Solution {
 public:
  int maximumScore(vector<int>& nums, int k) {
  int score = nums[k];
  int m = score;
  int left = k, right = k;
  int l = left, r = right;
  while (left>0 || right < nums.size()-1){
  if ( left > 0 && right < nums.size()-1 ) {
  if (nums[left-1] > nums[right+1]) {
  left--;
  } else if (nums[left-1] < nums[right+1]) {
  right++;
  } else {
  left--;right++;
  }
  }else if ( left <= 0 ) {
  right++;
  }else if ( right >= nums.size() -1 ) { 
  left--;
  }else {
  break;
  }
  m = min(m, min( nums[left], nums[right]));
  int s = m * (right - left + 1);
  if ( s > score) {
  score = s;
  l = left; r = right;
  }
  }
  //cout << ""["" << l << "","" << r << ""] = "" << score << endl;
  return score;
  }
 };"
252,252,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #define INT_MIN (-2147483647 - 1)
 int maxSubArray1(int A[], int n);
 int maxSubArray2(int A[], int n); 
 int max(int x, int y){
  return x>y?x:y;
 }
 int maxSubArray(int A[], int n) {
  if (random()%2){
  return maxSubArray1(A, n);
  }
  return maxSubArray2(A, n);
 }
 int maxSubArray1(int A[], int n) {
  int *sum = new int[n];
  sum[0] = A[0];
  int m = A[0]; 
  for (int i=1; i<n; i++){
  sum[i] = max(A[i], A[i] + sum[i-1]);
  m = max(m, sum[i]);
  }
  delete[] sum;
  return m;
 }
 int maxSubArray2(int A[], int n) {
  int m=INT_MIN;
  int sum=0;
  for (int i=0; i<n; i++){
  sum += A[i];
  m = max(sum, m);
  if (sum<0){
  sum = 0;
  }
  }
  return m;
 }
 int main()
 {
  srand(time(NULL));
  int a[]= {-2,1,-3,4,-1,2,1,-5,4};
  printf(""%d\n"", maxSubArray(a, sizeof(a)/sizeof(int)));
  printf(""%d\n"", maxSubArray(a, sizeof(a)/sizeof(int)));
  return 0;
 }"
253,253,"class Solution {
 public:
  int maxSumMinProduct(vector<int>& nums) {
  nums.push_back(0); //edge case
  //prefix sum
  vector<long> sums(nums.size(), 0);
  // sums[i] = sum (num[0], num[1], num[2], ... num[n-1])
  // sums[m] - sums[n] = sum (num[n], sum[n+1] .... nums[m-1]); m > n
  for(int i=0; i<nums.size()-1; i++) {
  sums[i+1] = sums[i] + nums[i];
  }
  stack<int> s;
  long m = 0;
  for(int i=0; i<nums.size(); i++) {
  while( !s.empty() && nums[s.top()] > nums[i]) {
  int min = nums[s.top()]; s.pop();
  int start = s.empty() ? 0 : s.top() + 1;
  int end = i;
  m = max(m , min * (sums[end] - sums[start]));
  // cout << ""["";
  // for(int k = start; k < end-1; k++) {
  // cout << nums[k] << "","";
  // }
  // cout << nums[end-1] << ""], "" << min << ""*"" << (sums[end] - sums[start]) 
  // << ""="" << min * (sums[end] - sums[start]) << endl;
  }
  // if the num is increasing, then push into stack
  s.push(i);
  }
  //cout << endl;
  return m % 1000000007;
  }
 };"
254,254,"class Solution {
 private:
  void print(vector<vector<int>>& boxes) {
  cout << ""{ "";
  for(int i=0; i<boxes.size()-1; i++){
  cout << ""["" << boxes[i][0] << "",""<< boxes[i][1] << ""], "";
  }
  int i=boxes.size()-1;
  cout << ""["" << boxes[i][0] << "", ""<< boxes[i][1] << ""] } ""<< endl;
  }
 public:
  int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {
  sort(boxTypes.begin(), boxTypes.end(), 
  [&](vector<int>& lhs, vector<int>& rhs){return lhs[1] > rhs[1]; });
  //print(boxTypes);
  int units = 0;
  for(auto& box : boxTypes) {
  if (truckSize >= box[0]) {
  units += box[0] * box[1];
  }else{
  units += truckSize * box[1];
  }
  truckSize -= box[0];
  if (truckSize <= 0 ) break;
  }
  return units;
  }
 };"
255,255,"class Solution {
 public:
  string maxValue(string n, int x) {
  bool neg = false;
  if (n[0] == '-') neg = true;
  int i;
  for( i=neg?1:0; i<n.size(); i++){
  if (neg == true) {
  if ( n[i]-'0' > x) break;
  }else{ 
  if (n[i]-'0' < x) break; 
  }
  }
  n.insert(n.begin()+i, x+'0');
  return n;
  }
 };"
256,256,"/*
 This problem can be treat as a pyramid which shaped by 1, it looks like below:
  1
  1 1 1
  1 1 1 1 1
  1 1 1 1 1 1 1
 So, from the top, for each layer, we need the 1,3,5,7,9.... 2*n-1 ONE(s).
 But we need to deal with the edge case - it could be out of the array boundary
 For example: index=2, lenght=3, maxSum=18
  1) at first, we put `1 1 1` on bottom layer - Array[2] = 1
  2) then we start from the top 
  1 <-- the top first layer
  1 1 1 <-- bottom 
  now, we have Array[2] is 2
  3) we keep doing tthe 2nd layer - Array[2] = 3
  1 <-- the 1st layer
  1 1 [1] <-- the 2nd layer, which has 1 out of the boundary
  1 1 1 <-- bottom 
  now, we have Array[2] is 3
  4) the 3rd layer - Array[2] = 4 
  1 <-- the 1st layer
  1 1 [1] <-- the 2nd layer, which has 1 out of the boundary
  1 1 1 [1] [1] <-- the 3rd layer, which has 2 out of the boundary
  1 1 1 <-- bottom 
  now, we have Array[2] is 4
  5) Now, the rest layers no need to be cacluated, they all are `3`.
  Since 4), we spent 9 of `1`, we still have 18 - 9 = 9 of `1`
  So, we can have 9/3 = 3 layer.
  6) Finally, the maximum of Array[2] = 4 + 3 = 7
 */
 class Solution {
 public:
  int maxValue(int n, int index, int maxSum) {
  // at least, put the bottom layer
  int maxValue = 1;
  maxSum -= n;
  int layer = 1;
  int points;
  while ( maxSum > 0 ) {
  // how many 1 we need
  points = (2 * layer - 1);
  // how many 1 exceed the right bound
  int right = (index + layer-1) - (n-1);
  if (right > 0) points -= right;
  // how many 1 exceed the left bound
  int left = (layer - index - 1);
  if (left > 0) points -= left;
  // points >= n - we just need `n` for the rest layers 
  // maxSum < points - if we haven't enough points 
  if (points >= n || maxSum < points) break;
  maxSum -= points;
  layer++;
  maxValue++;
  }
  // maxSum/n - we just need `n` for the rest layers
  return maxValue += (maxSum/n);
  }
 };"
257,257,"class Solution {
 public:
  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
  const int size = nums.size();
  const int max = (1 << maximumBit) - 1;
  int all = 0;
  vector<int> result(size);
  for(int i = 0; i < size; i++) {
  all ^= nums[i];
  result[size-i-1] = all ^ max;
  }
  return result;
  }
  vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
  int all = 0;
  for(auto& n : nums) {
  all ^= n;
  }
  int max = (1 << maximumBit) - 1; 
  vector<int> result;
  for(int i = nums.size()-1; i>=0; i--) {
  result.push_back(all ^ max);
  all ^= nums[i];
  }
  return result;
  }
 };"
258,258,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <map>
 using namespace std;
 struct Point {
  int x;
  int y;
  Point() : x(0), y(0) {}
  Point(int a, int b) : x(a), y(b) {}
 };
 // O(n^2) time complexity solution
 int maxPoints(vector<Point> &points) {
  #define INT_MAX 2147483647
  #define INT_MIN (-INT_MAX - 1)
  if (points.size()<=0) return 0;
  if (points.size()<=2) return points.size();
  int maxnum = 0;
  //using a map to find the same slope line
  map<double, int> slopeMap;
  //The algorithm here is quite straight forward.
  // take each point in array to caculate with others
  //
  //Actually the algorithm here can be optimized.
  // there are many duplicated calculation. 
  // considering two points A and B, (A,B) is same with (B,A), here re-calculated.
  for(int i=0; i<points.size(); i++) {
  //reset teh slope map.
  slopeMap.clear();
  slopeMap[INT_MIN] = 0;
  int samePointCnt = 1;
  for (int j=0; j<points.size(); j++) {
  if (i==j) continue; //skip the same point
  //Caculate the slope of two points
  int delta_x = points[i].x - points[j].x;
  int delta_y = points[i].y - points[j].y;
  //Special case: two points are exactly at same place
  if (delta_y == 0 && delta_x == 0){
  samePointCnt++;
  continue;
  }
  //Special case: delta_x == 0
  double slope = INT_MAX;
  if (delta_x!=0) {
  slope = 1.0*delta_y / delta_x;
  }
  //Count the points is same line.
  slopeMap[slope]++;
  }
  //find the max number of points located at same line with points[i]
  map<double, int>::iterator it;
  for (it = slopeMap.begin(); it != slopeMap.end(); it++) {
  if (maxnum < it->second + samePointCnt) {
  maxnum = it->second + samePointCnt;
  }
  }
  }
  return maxnum;
 }
 void generatePoints(vector<Point> &points, int n) {
  srand(time(0));
  Point p;
  for(int i=0; i<n; i++) {
  p.x = rand() % 1;
  p.y = rand() % 1;
  points.push_back(p);
  }
 }
 void printPoints(vector<Point> &points) {
  for(int i=0; i<points.size(); i++) {
  cout << ""("" << points[i].x << "","" << points[i].y << "") "";
  }
  cout << endl;
 }
 int main(int argc, char** argv) 
 {
  int n = 20;
  if ( argc > 1) {
  n = atoi(argv[1]);
  }
  vector<Point> points;
  generatePoints(points, n);
  printPoints(points);
  cout << maxPoints(points) << endl;
  return 0;
 }"
259,259,"#include <stdio.h>
 // Classical binary search algorithm, but slightly different
 // if cannot find the key, return the position where can insert the key 
 int binarySearch(int A[], int low, int high, int key){
  while(low<=high){
  int mid = low + (high - low)/2;
  if (key == A[mid]) return mid;
  if (key > A[mid]){
  low = mid + 1;
  }else {
  high = mid -1;
  }
  }
  return low;
 }
 //Notes:
 // I feel the following methods is quite complicated, it should have a better high clear and readable solution
 double findMedianSortedArrayHelper(int A[], int m, int B[], int n, int lowA, int highA, int lowB, int highB) {
  // Take the A[middle], search its position in B array
  int mid = lowA + (highA - lowA)/2;
  int pos = binarySearch(B, lowB, highB, A[mid]);
  int num = mid + pos;
  // If the A[middle] in B is B's middle place, then we can have the result
  if (num == (m+n)/2){
  // If two arrays total length is odd, just simply return the A[mid]
  // Why not return the B[pos] instead ? 
  // suppose A={ 1,3,5 } B={ 2,4 }, then mid=1, pos=1
  // suppose A={ 3,5 } B={1,2,4}, then mid=0, pos=2
  // suppose A={ 1,3,4,5 } B={2}, then mid=1, pos=1
  // You can see, the `pos` is the place A[mid] can be inserted, so return A[mid]
  if ((m+n)%2==1){
  return A[mid];
  }
  // If tow arrys total length is even, then we have to find the next one.
  int next;
  // If both `mid` and `pos` are not the first postion.
  // Then, find max(A[mid-1], B[pos-1]). 
  // Because the `mid` is the second middle number, we need to find the first middle number
  // Be careful about the edge case
  if (mid>0 && pos>0){ 
  next = A[mid-1]>B[pos-1] ? A[mid-1] : B[pos-1];
  }else if(pos>0){
  next = B[pos-1];
  }else if(mid>0){
  next = A[mid-1];
  }
  return (A[mid] + next)/2.0;
  }
  // if A[mid] is in the left middle place of the whole two arrays
  //
  // A(len=16) B(len=10)
  // [................] [...........]
  // ^ ^
  // mid=7 pos=1
  //
  // move the `low` pointer to the ""middle"" position, do next iteration.
  if (num < (m+n)/2){
  lowA = mid + 1;
  lowB = pos; 
  if ( highA - lowA > highB - lowB ) {
  return findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB);
  }
  return findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA);
  }
  // if A[mid] is in the right middle place of the whole two arrays
  if (num > (m+n)/2) {
  highA = mid - 1;
  highB = pos-1;
  if ( highA - lowA > highB - lowB ) {
  return findMedianSortedArrayHelper(A, m, B, n, lowA, highA, lowB, highB);
  }
  return findMedianSortedArrayHelper(B, n, A, m, lowB, highB, lowA, highA);
  }
 }
 double findMedianSortedArrays(int A[], int m, int B[], int n) {
  //checking the edge cases
  if ( m==0 && n==0 ) return 0.0;
  //if the length of array is odd, return the middle one
  //if the length of array is even, return the average of the middle two numbers
  if ( m==0 ) return n%2==1 ? B[n/2] : (B[n/2-1] + B[n/2])/2.0;
  if ( n==0 ) return m%2==1 ? A[m/2] : (A[m/2-1] + A[m/2])/2.0;
  //let the longer array be A, and the shoter array be B
  if ( m > n ){
  return findMedianSortedArrayHelper(A, m, B, n, 0, m-1, 0, n-1);
  }
  return findMedianSortedArrayHelper(B, n, A, m, 0, n-1, 0, m-1);
 }
 int main()
 {
  int r1[] = {1};
  int r2[] = {2};
  int n1 = sizeof(r1)/sizeof(r1[0]);
  int n2 = sizeof(r2)/sizeof(r2[0]);
  printf(""Median is 1.5 = %f\n"", findMedianSortedArrays(r1, n1, r2, n2));
  int ar1[] = {1, 12, 15, 26, 38};
  int ar2[] = {2, 13, 17, 30, 45, 50};
  n1 = sizeof(ar1)/sizeof(ar1[0]);
  n2 = sizeof(ar2)/sizeof(ar2[0]);
  printf(""Median is 17 = %f\n"", findMedianSortedArrays(ar1, n1, ar2, n2));
  int ar11[] = {1, 12, 15, 26, 38};
  int ar21[] = {2, 13, 17, 30, 45 };
  n1 = sizeof(ar11)/sizeof(ar11[0]);
  n2 = sizeof(ar21)/sizeof(ar21[0]);
  printf(""Median is 16 = %f\n"", findMedianSortedArrays(ar11, n1, ar21, n2));
  int a1[] = {1, 2, 5, 6, 8 };
  int a2[] = {13, 17, 30, 45, 50};
  n1 = sizeof(a1)/sizeof(a1[0]);
  n2 = sizeof(a2)/sizeof(a2[0]);
  printf(""Median is 10.5 = %f\n"", findMedianSortedArrays(a1, n1, a2, n2));
  int a10[] = {1, 2, 5, 6, 8, 9, 10 };
  int a20[] = {13, 17, 30, 45, 50};
  n1 = sizeof(a10)/sizeof(a10[0]);
  n2 = sizeof(a20)/sizeof(a20[0]);
  printf(""Median is 9.5 = %f\n"", findMedianSortedArrays(a10, n1, a20, n2));
  int a11[] = {1, 2, 5, 6, 8, 9 };
  int a21[] = {13, 17, 30, 45, 50};
  n1 = sizeof(a11)/sizeof(a11[0]);
  n2 = sizeof(a21)/sizeof(a21[0]);
  printf(""Median is 9 = %f\n"", findMedianSortedArrays(a11, n1, a21, n2));
  int a12[] = {1, 2, 5, 6, 8 };
  int a22[] = {11, 13, 17, 30, 45, 50};
  n1 = sizeof(a12)/sizeof(a12[0]);
  n2 = sizeof(a22)/sizeof(a22[0]);
  printf(""Median is 11 = %f\n"", findMedianSortedArrays(a12, n1, a22, n2));
  int b1[] = {1 };
  int b2[] = {2,3,4};
  n1 = sizeof(b1)/sizeof(b1[0]);
  n2 = sizeof(b2)/sizeof(b2[0]);
  printf(""Median is 2.5 = %f\n"", findMedianSortedArrays(b1, n1, b2, n2));
  return 0;
 }"
260,260,"#include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 struct Interval {
  int start;
  int end;
  Interval() : start(0), end(0) {}
  Interval(int s, int e) : start(s), end(e) {}
 };
 //Two factos sorting [start:end]
 bool compare(const Interval& lhs, const Interval& rhs){
  return (lhs.start==rhs.start) ? lhs.end < rhs.end : lhs.start < rhs.start;
 }
 vector<Interval> merge(vector<Interval> &intervals) {
  vector<Interval> result;
  if (intervals.size() <= 0) return result;
  //sort the inervals. Note: using the customized comparing function.
  sort(intervals.begin(), intervals.end(), compare);
  for(int i=0; i<intervals.size(); i++) { 
  int size = result.size();
  // if the current intervals[i] is overlapped with previous interval.
  // merge them together
  if( size>0 && result[size-1].end >= intervals[i].start) {
  result[size-1].end = max(result[size-1].end, intervals[i].end); 
  }else{
  result.push_back(intervals[i]);
  }
  }
  return result;
 }
 int main(int argc, char**argv)
 {
  Interval i1(1,4);
  Interval i2(0,2);
  Interval i3(3,5);
  Interval i4(15,18);
  vector<Interval> intervals;
  intervals.push_back(i1);
  intervals.push_back(i2);
  intervals.push_back(i3);
  intervals.push_back(i4);
  vector<Interval> r = merge(intervals);
  for(int i=0; i<r.size(); i++){
  cout << ""[ "" << r[i].start << "", "" << r[i].end << "" ] "";
  }
  cout <<endl;
  return 0;
 }"
261,261,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *mergeTwoLists(ListNode* head1, ListNode* head2);
 ListNode *mergeTwoLists01(ListNode* head1, ListNode* head2);
 ListNode *mergeTwoLists02(ListNode* head1, ListNode* head2);
 ListNode *mergeKLists(vector<ListNode *> &lists) {
  ListNode *p, *p1, *p2;
  while(lists.size()>1){
  p1 = lists.back(); 
  lists.pop_back();
  p2 = lists.back(); 
  lists.pop_back();
  p = mergeTwoLists(p1, p2);
  lists.insert(lists.begin(), p);
  }
  return lists.size()==1 ? lists[0] : NULL;
  /* the following method is not fast enough! */
  /*
  ListNode* pHead = NULL;
  for (int i=0; i<lists.size(); i++){
  pHead = mergeTwoLists(pHead, lists[i]);
  }
  return pHead;
  */
 }
 static int n=0;
 ListNode *mergeTwoLists(ListNode* head1, ListNode* head2){
  if (n){
  //cout << ""------ method 01 ------"" <<endl;
  return mergeTwoLists01(head1, head2);
  }
  //cout << ""------ method 02 ------"" <<endl;
  return mergeTwoLists02(head1, head2);
 }
 /*======================================================================*/
 /* Method One */
 /*======================================================================*/
 //#define INT_MAX 2147483647
 //#define INT_MIN (-INT_MAX - 1)
 ListNode *mergeTwoLists01(ListNode* head1, ListNode* head2){
  ListNode *p1 = head1, *p2=head2;
  static ListNode dummy(0);
  dummy.next = p1;
  ListNode *prev = &dummy;
  while(p1 && p2){
  if(p1->val < p2->val){
  prev = p1;
  p1 = p1->next;
  }else{
  prev->next = p2;
  p2 = p2->next;
  prev = prev->next;
  prev->next = p1;
  }
  }
  if (p2){
  prev->next = p2;
  }
  return dummy.next;
 }
 /*======================================================================*/
 /* Method Two */
 /*======================================================================*/
 void TakeOutNode(ListNode*& head, ListNode*& tail, ListNode*& p);
 ListNode *mergeTwoLists02(ListNode* head1, ListNode* head2) {
  ListNode *p1 = head1, *p2=head2;
  ListNode *pHead = NULL, *pTail=NULL;
  while(p1 && p2){
  if(p1->val < p2->val){
  TakeOutNode(pHead, pTail, p1);
  }else{
  TakeOutNode(pHead, pTail, p2);
  }
  }
  ListNode *p=NULL;
  if (p1){
  p = p1;
  }else if (p2){
  p = p2;
  }
  if (pHead==NULL){
  return p;
  }
  pTail->next = p;
  return pHead;
 }
 void TakeOutNode(ListNode*& head, ListNode*& tail, ListNode*& p){
  ListNode *pNext = p->next;
  if (head==NULL){
  head = tail = p;
  }else{
  tail->next = p;
  tail = p;
  }
  p->next = NULL;
  p = pNext;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main(int argc, char**argv)
 {
  srand(time(0));
  if (argc>1){
  n = atoi(argv[1]) % 2;
  }
  int a[] = {1,3,5,6,7,10};
  int b[] = {0,4,6,8,9,11,20,30,40};
  ListNode* p1 = createList(a, sizeof(a)/sizeof(int));
  ListNode* p2 = createList(b, sizeof(b)/sizeof(int));
  printList( mergeTwoLists(p1,p2) );
  //mergeTwoLists(p1,p2) ;
  vector<ListNode*> v;
  for(int i=0; i<10240; i++) {
  v.push_back(new ListNode(random()%100));
  }
  printList( mergeKLists(v) );
  //mergeKLists(v);
  cout << ""method "" << n+1 << endl;
  return 0;
 }"
262,262,"class Solution {
 public:
  string mergeAlternately(string word1, string word2) {
  int len1 = word1.size();
  int len2 = word2.size();
  int len = min(len1, len2);
  string result;
  for (int i=0; i<len; i++) {
  result += word1[i];
  result += word2[i];
  }
  if (len1 > len) result += word1.substr(len, len1 - len );
  if (len2 > len) result += word2.substr(len, len2 - len );
  return result;
  }
 };"
263,263,"#include <stdio.h>
 void merge(int A[], int m, int B[], int n) {
  int ia = m-1 ;
  int ib = n-1 ;
  int i = m + n - 1;
  for (int i=m+n-1; i>=0; i--){
  if (ia>=0 && ib<0){
  break;
  }
  if (ia<0 && ib>=0){
  A[i] = B[ib--];
  continue;
  } 
  if (ia>=0 && ib>=0){
  if (A[ia] > B[ib]){
  A[i] = A[ia--];
  }else{
  A[i] = B[ib--];
  }
  }
  }
 }
 void printArray(int A[], int n) {
  printf(""{"");
  for(int i=0; i<n; i++) {
  printf(""%d, "", A[i]);
  }
  printf(""}\n"");
 }
 int main()
 {
  int a[]={2,4,6,8,10,0,0,0};
  int b[]={1,3,5};
  merge(a, 5, b, 3 );
  printArray(a, sizeof(a)/sizeof(int));
  int a1[]={2,4,0,0,0};
  int b1[]={3,5,7};
  merge(a1, 2, b1, 3 );
  printArray(a1, sizeof(a1)/sizeof(int));
  int a2[]={12,14,16,18,20,0,0,0};
  int b2[]={1,3,5};
  merge(a2, 5, b2, 3 );
  printArray(a2, sizeof(a2)/sizeof(int));
  int a3[]={2,0};
  int b3[]={3,};
  merge(a3, 1, b3, 1 );
  printArray(a3, sizeof(a3)/sizeof(int));
  int a4[]={0,0,0};
  int b4[]={1,3,5};
  merge(a4, 0, b4, 3 );
  printArray(a4, sizeof(a4)/sizeof(int));
  int a5[]={2,4,6,8,10,0,0,0};
  int b5[]={11,13,15};
  merge(a5, 5, b5, 3 );
  printArray(a5, sizeof(a5)/sizeof(int));
  int a6[]={2,4,0,0,0,0,0,0};
  int b6[]={1,3,5,7,9,11};
  merge(a6, 2, b6, 6 );
  printArray(a6, sizeof(a6)/sizeof(int));
  return 0;
 }"
264,264,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
  switch (random()%3){
  case 0:
  return mergeTwoLists01(l1, l2);
  case 1:
  return mergeTwoLists02(l1, l2);
  default:
  return mergeTwoLists03(l1, l2);
  }
  }
  /* merge the 2nd list into 1st list*/
  ListNode *mergeTwoLists01(ListNode* head1, ListNode* head2){
  ListNode *p1 = head1, *p2=head2;
  static ListNode dummy(0);
  dummy.next = p1;
  ListNode *prev = &dummy;
  while(p1 && p2){
  if(p1->val < p2->val){
  prev = p1;
  p1 = p1->next;
  }else{
  prev->next = p2;
  p2 = p2->next;
  prev = prev->next;
  prev->next = p1;
  }
  }
  if (p2){
  prev->next = p2;
  }
  return dummy.next;
  }
  /* merge two lists to the new list */
  ListNode *mergeTwoLists02(ListNode *l1, ListNode *l2) {
  ListNode *l=NULL, *p=NULL;
  while (l1!=NULL && l2!=NULL ){
  ListNode *n=NULL;
  if (l1->val < l2-> val){
  n = l1;
  l1=l1->next;
  }else{
  n = l2;
  l2=l2->next;
  }
  if (l==NULL){
  l = p = n;
  }else{
  p->next = n;
  p = p->next;
  }
  }
  ListNode* rest = l1 ? l1 :l2;
  l = mergeTheRest(rest, l, p);
  return l;
  }
  ListNode* mergeTheRest(ListNode* l, ListNode*head, ListNode* tail){
  if (l){
  if (head && tail ){
  tail->next = l;
  }else{
  head = l;
  }
  }
  return head;
  }
  /* 
  * You can see the 2nd slution's code is quite complicated, 
  * because it need to check the (head==NULL) situation.
  * We can use the ""pointer to pointer"" to make the code more clean
  * however, this would be bad for performance.
  */
  ListNode *mergeTwoLists03(ListNode *l1, ListNode *l2) {
  ListNode *head = NULL;
  ListNode **pTail = &head;
  while (l1 != NULL && l2 != NULL) {
  if (l1->val < l2->val) {
  *pTail = l1;
  l1 = l1->next;
  } else {
  *pTail = l2;
  l2 = l2->next;
  }
  pTail = &(*pTail)->next;
  }
  *pTail = (l1 != NULL ? l1 : l2);
  return head;
  }
 };"
265,265,"class Solution {
  public:
  int minCostClimbingStairs(vector<int>& cost) {
  return minCostClimbingStairs02(cost); 
  return minCostClimbingStairs01(cost); 
  }
  int minCostClimbingStairs01(vector<int>& cost) {
  vector<int> dp(cost.size() , 0);
  dp[0] = cost[0];
  dp[1] = cost[1];
  for (int i=2; i<cost.size(); i++) {
  dp[i] = min( dp[i-1], dp[i-2] ) + cost[i];
  }
  return min(dp[dp.size()-1], dp[dp.size()-2]);
  }
  int minCostClimbingStairs02(vector<int>& cost) {
  int dp1 = cost[0], dp2 = cost[1];
  for (int i=2; i<cost.size(); i++) {
  int dp = min( dp1, dp2 ) + cost[i];
  dp1 = dp2;
  dp2 = dp;
  }
  return min (dp1, dp2);
  }
 };"
266,266,"class Solution {
 public:
  int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
  int max=0, idx=0;
  long sum=0;
  int len = nums1.size();
  for (int i=0; i<len; i++) {
  int m = abs(nums1[i] - nums2[i]);
  if (max < m) {
  max = m; 
  idx = i;
  }
  sum += m ;
  }
  int min = max;
  for (int i=0; i<len; i++) {
  int m = abs(nums1[i] - nums2[idx]);
  if (m < min) {
  min = m;
  }
  }
  sum -= (max - min);
  return sum % 1000000007 ;
  }
 };"
267,267,"class Solution {
 private:
  // Refer to:
  // https://leetcode.com/problems/next-permutation/solution/
  void nextPermutation(string& num) {
  int i = num.size() - 2;
  while (i >= 0 && num[i + 1] <= num[i]) {
  i--;
  }
  if (i >= 0) {
  int j = num.size() - 1;
  while (j >= 0 && num[j] <= num[i]) {
  j--;
  }
  swap(num[i], num[j]);
  }
  reverse(num, i + 1);
  }
  void reverse(string& num, int start) {
  int i = start, j = num.size() - 1;
  while (i < j) {
  swap(num[i], num[j]);
  i++;
  j--;
  }
  }
 public:
  int getMinSwaps(string num, int k) {
  string pnum = num;
  while(k--) {
  nextPermutation(pnum);
  }
  //cout << num << endl << pnum << endl;
  int result = 0;
  for(int i = 0; i < num.size(); i++) {
  if (num[i] == pnum[i]) continue;
  for(int j = i + 1; j < num.size(); j++) {
  if(num[i] != pnum[j]) continue;
  //cout << ""j="" << j << "", i="" << i << endl;
  result += j - i;
  //shift the string
  char c = pnum[j];
  for (int k = j; k > i; k--) {
  pnum[k] = pnum[k-1];
  }
  pnum[i] = c;
  //cout << pnum << endl;
  break;
  }
  }
  //cout << endl;
  return result;
  }
 };"
268,268,"class Solution {
 public:
  int minimumDeleteSum(string s1, string s2) {
  // Dynamic Programm - simlar with : Edit Distance
  vector < vector <int> > dp ( s1.size()+1, vector<int>( s2.size()+1, 0) );
  // s1 is row, s2 is column
  for (int i=1; i<=s2.size(); i++) dp[0][i] = dp[0][i-1] + s2[i-1];
  for (int i=1; i<=s1.size(); i++) dp[i][0] = dp[i-1][0] + s1[i-1];
  for (int i=1; i<=s1.size(); i++){
  for (int j=1; j<=s2.size(); j++) {
  if ( s1[i-1] == s2[j-1] ) {
  dp[i][j] = dp[i-1][j-1];
  }else{
  dp[i][j] = min(dp[i-1][j] + s1[i-1], dp[i][j-1] + s2[j-1]);
  }
  }
  }
  return dp[s1.size()][s2.size()];
  }
 };"
269,269,"class Solution {
 public:
  int minOperations(string s) {
  int start_with_zero = 0;
  int start_with_one = 0;
  for (int i=0; i<s.size(); i++){
  if (i % 2 == 0) {
  s[i] == '1' ? start_with_zero++ : start_with_one++;
  }else{
  s[i] == '0' ? start_with_zero++ : start_with_one++;
  }
  }
  return std::min(start_with_zero, start_with_one);
  }
 };"
270,270,"class Solution {
 private:
  int min(int x, int y){
  return x < y ? x : y;
  }
  int min(int x, int y, int z) {
  return min(min(x, y), z);
  }
 public:
  int mincostTickets(vector<int>& days, vector<int>& costs) {
  // Dynamic Programming
  vector<int> dp(days.size()+1, INT_MAX);
  // dp[i] is the minimal cost from Days[0] to Days[i]
  dp[0] = 0;
  dp[1] = min(costs[0], costs[1], costs[2]);
  for (int i = 2; i<= days.size(); i ++) {
  // the currnet day need at least min(1-day, 7days, 30days) from previous.
  int m = dp[i-1] + min(costs[0], costs[1], costs[2]);
  // Seprating the array to two parts.
  // days[0] -> days[j] -> day[i]
  //
  // calculate the day[i] - day[j] whether can use 7-day pass or 30-day pass
  //
  // Traking the minimal costs, then can have dp[i] minimal cost
  int SevenDays = INT_MAX, ThrityDays = INT_MAX;
  for (int j=i-1; j>0; j--){
  int gaps = days[i-1] - days[j-1];
  if ( gaps < 7 ) {
  // can use 7-days or 30-days ticket
  SevenDays = dp[j-1] + min(costs[1], costs[2]);
  } else if (gaps < 30 ) {
  //can use 30-days tickets
  ThrityDays = dp[j-1] + costs[2];
  } else {
  break;
  }
  m = min(m, SevenDays, ThrityDays);
  }
  if ( dp[i] > m ) dp[i] = m;
  }
  return dp[dp.size()-1]; 
  }
 };"
271,271,"class Solution {
 private:
  vector<vector<bool>>* edge_matrix;
  vector<int>* node_edge_num;
  bool has_edge(int x, int y) {
  return (*edge_matrix)[x][y];
  }
  int node_edges(int x){
  return (*node_edge_num)[x];
  }
  int degree(int x, int y, int z) {
  if (has_edge(x,y) && has_edge(y,z) && has_edge(x,z)) {
  return node_edges(x) + node_edges(y) + node_edges(z) - 6; 
  }
  return -1;
  }
 public:
  int minTrioDegree(int n, vector<vector<int>>& edges) {
  vector<vector<bool>> edge_matrix(n+1, vector<bool>(n+1, false));
  vector<int> node_edge_num(n+1, 0);
  this->edge_matrix = &edge_matrix;
  this->node_edge_num = &node_edge_num;
  for (auto& edge : edges) {
  edge_matrix[edge[0]][edge[1]] = true;
  edge_matrix[edge[1]][edge[0]] = true;
  node_edge_num[edge[0]]++;
  node_edge_num[edge[1]]++;
  }
  int result = -1;
  for(int i=1; i<=n; i++) {
  if (node_edge_num[i] < 2) continue;
  for(int j=i+1; j<=n; j++) {
  if (!has_edge(i, j)) continue;
  for(int k=j+1; k<=n; k++) {
  if (!has_edge(j, k)) continue;
  int d = degree(i, j, k);
  if ( d >= 0 ) {
  result = result < 0 ? d : min(result, d);
  }
  }
  }
  }
  return result;
  }
 };"
272,272,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  int minDepth(TreeNode *root) {
  if (root==NULL){
  return 0;
  }
  if (root->left==NULL && root->right==NULL){
  return 1;
  }
  int left=INT_MAX;
  if (root->left){
  left = minDepth(root->left) + 1 ;
  }
  int right=INT_MAX;
  if (root->right){
  right = minDepth(root->right) + 1;
  }
  return left<right ? left : right;
  }
 };"
273,273,"class Solution {
 public:
  int getMinDistance(vector<int>& nums, int target, int start) {
  int minDist = nums.size();
  for(int i=start; i < nums.size(); i++){
  if ( target == nums[i] ) {
  minDist = i - start;
  break;
  } 
  }
  for (int i=start; i>=0; i--) {
  if ( target == nums[i] && start - i <= minDist) {
  minDist = start - i;
  break;
  }
  }
  return minDist;
  }
 };"
274,274,"class Solution {
 public:
  long sum(vector<int>& nums) {
  long s = 0;
  for (auto n : nums) {
  s += n;
  }
  return s;
  }
  int minElements(vector<int>& nums, int limit, int goal) {
  long s = sum(nums);
  return (abs(goal - s) + limit -1) / limit;
  }
 };"
275,275,"class Solution {
 private:
  int min(int x, int y) {
  return x < y ? x: y;
  }
  int min( int x, int y, int z) {
  return min(min(x, y),z);
  }
 public:
  int minFallingPathSum(vector<vector<int>>& A) {
  int m = INT_MAX;
  for (int i=0; i<A.size(); i++) {
  for (int j=0; j<A[i].size(); j++){
  //find the minimal item in previous row, and add it into the current item
  if (i > 0) {
  if (j == 0 ){
  A[i][j] += min( A[i-1][j], A[i-1][j+1]); 
  } else if ( j + 1 == A[i].size()) {
  A[i][j] += min( A[i-1][j], A[i-1][j-1]); 
  }else {
  A[i][j] += min( A[i-1][j], A[i-1][j-1], A[i-1][j+1]);
  }
  }
  if ( i + 1 == A.size() ) {
  m = min(m, A[i][j]);
  }
  }
  }
  return m;
  }
 };"
276,276,"class Solution {
 public:
  int minInsertions(string s) {
  vector<char> stack;
  int cnt = 0;
  int len = s.size();
  for (int i=0; i<len; i++) {
  if ( s[i] == '(' ) {
  stack.push_back( s[i] );
  continue;
  }
  // if s[i] is ')'
  if (stack.size() > 0) {
  stack.pop_back();
  } else {
  cnt++; // missed the '('
  }
  // if s[i+1] is ')', need to skip
  if ( i < len -1 && s[i+1] == ')' ) {
  i++;
  }else{
  cnt++; //missed the ')'
  }
  }
  // if the stack still has '(', which means need double of ')'
  return cnt + stack.size()*2;
  }
 };"
277,277,"class Solution {
 public:
  vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
  set<vector<int>> s;
  vector<vector<int>> iQueries;
  for(int i=0; i < queries.size(); i++) {
  iQueries.push_back({queries[i], i});
  }
  sort(intervals.begin(), intervals.end());
  sort(iQueries.begin(), iQueries.end());
  vector<int> result(queries.size(), -1);
  int i = 0, len = intervals.size();
  for(auto& iq: iQueries) {
  int q = iq[0];
  int idx = iq[1];
  while( i < len && intervals[i][0] <= q) {
  s.insert({intervals[i][1] - intervals[i][0] + 1, intervals[i][1]});
  i++;
  }
  while( !s.empty() ) {
  auto it = s.begin();
  if ( (*it)[1] >= q ) break;
  s.erase(s.begin());
  }
  if ( !s.empty() ) {
  auto it = s.begin();
  result[idx] = (*it)[0];
  }
  }
  return result;
  }
 };"
278,278,"class Solution {
 public:
  int minimumLength(string s) {
  char ch; 
  int left=0, right=s.size()-1;
  while(left < right) {
  ch = s[left];
  if (s[right] != ch) break;
  while (s[left] == ch) left++;
  if (left >= right ) return 0;
  while (s[right] == ch) right--;
  }
  return right - left + 1;
  }
 };"
279,279,"class Solution {
 public:
  int minimumSize(vector<int>& nums, int maxOperations) {
  //find the theoretical min/max of penalty
  int max_penalty = 0;
  long long sum = 0;
  for (auto& n: nums){
  max_penalty = max(max_penalty, n);
  sum += n;
  }
  //the max of bags is nums.size() + maxOperations
  //the average of the ball is the theoretical min penalty
  int min_penalty = sum / (nums.size() + maxOperations);
  min_penalty = max(1, min_penalty); // in case of min_penalty is zero
  //binary search the real min penalty
  while (min_penalty < max_penalty) {
  int mid = min_penalty + (max_penalty - min_penalty) / 2;
  //if the penalty is `mid`, then how many operation we need
  int ops = 0;
  for (auto& n : nums){
  if (n <= mid) continue; //no need seperation
  ops += (n-1) / mid;
  }
  //if the operation we need is beyoned the limitation, 
  //then we find in the large part, else find in the small part.
  if (ops > maxOperations) {
  min_penalty = mid + 1;
  }else{
  max_penalty = mid;
  }
  }
  return min_penalty;
  }
 };"
280,280,"class Solution {
 public:
  vector<int> minOperations(string boxes) {
  vector<int> result(boxes.size());
  //minOperations01(boxes, result); //128ms
  minOperations02(boxes, result); //4s
  return result;
  }
  void minOperations01(string& boxes, vector<int>& result ) {
  vector<int> balls;
  for(int i=0; i<boxes.size(); i++) {
  if(boxes[i] == '1') balls.push_back(i);
  }
  for (int i=0; i<boxes.size(); i++) {
  int steps = 0;
  for (int j=0; j<balls.size(); j++) {
  steps += abs(balls[j] - i);
  }
  result[i] = steps;
  }
  }
  void minOperations02(string& boxes, vector<int>& result ) {
  //from left to right
  for(int i=0, ops=0, balls=0; i< boxes.size(); i++) {
  result[i] += ops;
  balls += (boxes[i] == '1' ? 1 : 0);
  ops += balls;
  }
  //from right to left
  for(int i=boxes.size()-1, ops=0, balls=0; i>=0; i--) {
  result[i] += ops;
  balls += (boxes[i] == '1' ? 1 : 0);
  ops += balls;
  }
  }
 };"
281,281,"class Solution {
 private: 
  bool check(vector<int>& a) {
  for(int i=0; i<a.size(); i++) {
  if (a[i] != i) return false;
  }
  return true;
  }
 public:
  int reinitializePermutation(int n) {
  vector<int> perm(n);
  vector<int> arr(n);
  for(int i=0; i<n; i++) {
  perm[i] = i;
  }
  int cnt = 0;
  while(1){
  cnt++;
  for(int i=0; i<n; i++) {
  if (i%2==0) arr[i] = perm[i / 2];
  else arr[i] = perm[n / 2 + (i - 1) / 2];
  }
  if (check(arr)) break;
  perm = arr;
  }
  return cnt;
  }
 };"
282,282,"class Solution {
 public:
  bool hasLang(vector<int>& langlist, int lang){
  for(auto& l : langlist) {
  if (l == lang) return true;
  }
  return false;
  }
  bool canComm(int u, int v, int n, vector<vector<bool>>& langs) {
  for (int l=0; l<n; l++) {
  if (langs[u][l] && langs[v][l]) return true;
  }
  return false;
  }
  int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
  int persons = languages.size();
  //use to check a person know a langauge or not
  vector<vector<bool>> langs(persons, vector<bool>(n, false));
  for (int p=0; p<persons; p++) {
  for(int l=0; l<languages[p].size(); l++) {
  langs[p][languages[p][l]-1] = true;
  }
  } 
  int result = persons;
  vector<vector<bool>> langToTeach(n, vector<bool>(persons, false));
  for (int l=0; l <n; l++) {
  int cnt = 0;
  vector<bool> teach(persons, false);
  for (auto& fs : friendships) {
  int u = fs[0] - 1;
  int v = fs[1] - 1;
  if (canComm(u, v, n, langs)) continue;
  if (langs[u][l]==false && teach[u]==false) {
  teach[u] = true; cnt++;
  }
  if (langs[v][l]==false && teach[v]==false) {
  teach[v] = true; cnt++;
  }
  }
  result = min(result, cnt);
  }
  return result;
  }
 };"
283,283,"class Solution {
 public:
  int minOperations(int n) {
  // the sum of odd number is : n*n
  // the sum of even number is: n*n+n
  /* int sum = n*n; */
  //calculate the average
  /* int average = sum / n; //actually it is n */
  //calculate the different between n and all of the odd number which less than `average`
  // (n - 1) + (n - 3) + (n - 5) + (n - 7) ...
  // = m*n - (1+3+5+7+...m) where m = n/2
  // = m*n - m*m
  // = (n/2)*n - (n/2)*(n/2)
  // = n*n/2 - n*n/4
  // = n*n/4
  return n*n/4;
  }
 };"
284,284,"class Solution {
 public:
  int minOperations(vector<int>& nums) {
  int ins = 0;
  int top = nums[0];
  for(int i = 1; i < nums.size(); i++) {
  if (nums[i] > top){
  top = nums[i];
  }else{
  ins += (top - nums[i] + 1);
  top++;
  }
  }
  return ins;
  }
 };"
285,285,"#include <limits.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 int minPathSum(vector<vector<int>>& grid) {
  for (int i=0; i<grid.size(); i++) {
  for (int j=0; j<grid[0].size(); j++) {
  if (i==0 && j==0) continue;
  else if (i==0) grid[0][j] += grid[0][j-1];
  else if (j==0) grid[i][0] += grid[i-1][j];
  else grid[i][j] += min( grid[i-1][j], grid[i][j-1]);
  }
  }
  return grid[grid.size()-1][grid[0].size()-1];
 }
 int main()
 {
  int a[6][2]={{7,2},{6,6},{8,6},{8,7},{5,0},{6,0}};
  vector< vector<int> > grid;
  for(int i=0; i<6; i++){
  vector<int> v;
  for(int j=0; j<2; j++){
  v.push_back(a[i][j]);
  }
  grid.push_back(v);
  }
  cout << ""minPathSum="" << minPathSum(grid) << endl;
  return 0;
 }"
286,286,"class Solution {
 private:
  int min (int x, int y) {
  return x < y ? x : y;
  }
  int min(int x, int y, int z) {
  return min(x, min(y,z));
  }
  void print(vector<vector<int>>& matrix) {
  int n = matrix.size();
  int m = matrix[0].size();
  for(int i=0; i<m; i++) {
  for (int j=0; j<n-1; j++){
  if (matrix[j][i] == n) {
  cout << setw(2) << ""X""<<"","";
  } else {
  cout << setw(2) <<matrix[j][i] << "","";
  }
  }
  cout << matrix[n-1][i] << endl;
  }
  }
 public:
  int minSideJumps(vector<int>& obstacles) {
  int n = obstacles.size();
  vector<vector<int>> dp(n, vector(3,0));
  dp[0][0] = dp[0][2] = 1;
  for(int i = 1; i < n; i++){
  dp[i][0] = dp[i-1][0];
  dp[i][1] = dp[i-1][1];
  dp[i][2] = dp[i-1][2];
  if (obstacles[i] > 0 ) dp[i][obstacles[i]-1] = n;
  if (obstacles[i]-1 != 0 ) dp[i][0] = min(dp[i-1][0], dp[i][1]+1, dp[i][2]+1); 
  if (obstacles[i]-1 != 1 ) dp[i][1] = min(dp[i][0]+1, dp[i-1][1], dp[i][2]+1);
  if (obstacles[i]-1 != 2 ) dp[i][2] = min(dp[i][0]+1, dp[i][1]+1, dp[i-1][2]);
  }
  //print(dp);
  //cout << endl;
  return min(dp[n-1][0], dp[n-1][1], dp[n-1][2]);
  }
 };"
287,287,"class Solution {
 public:
  int minSubArrayLen(int s, vector<int>& nums) {
  int min = nums.size();
  int begin=0, end=0;
  int sum = 0;
  bool has = false;
  for (int i=0; i<nums.size(); i++, end++){
  sum += nums[i];
  while (sum >= s && begin <= end) {
  //the 1 is minial length, just return
  if (begin == end) return 1;
  if (end-begin+1 < min) {
  min = end - begin + 1;
  has = true;
  }
  //move the begin
  sum -= nums[begin++];
  }
  }
  return has ? min : 0; 
  }
 };"
288,288,"class Solution {
 public:
  bool verify(vector<int>& dist, double hour, int speed) {
  double t = 0;
  int n = dist.size();
  for (int i=0; i<n-1; i++){
  t += (dist[i] + speed -1) / speed;
  }
  t += (double)dist[n-1]/speed;
  return t <= hour;
  }
  int minSpeedOnTime(vector<int>& dist, double hour) {
  int n = dist.size();
  if (hour <= n-1) return -1;
  int low = 1, high = 1e7;
  while (low < high) {
  int mid = low + (high - low) / 2;
  if (verify(dist, hour, mid)) {
  high = mid;
  } else {
  low = mid + 1;
  }
  }
  return high;
  }
 };"
289,289,"#include <string.h>
 #include <iostream>
 #include <string>
 using namespace std;
 #define INT_MAX 2147483647
 string minWindow(string s, string t) {
  string win;
  if (s.size()<=0 || t.size()<=0 || t.size() > s.size()) return win;
  /*
  * Declare two ""hash map"" for ASCII chars
  * window[]: represents the char found in string S
  * dict[]: stores the chars in string T
  */ 
  const int MAX_CHARS = 256;
  int window[MAX_CHARS], dict[MAX_CHARS];
  const int NOT_EXISTED = -1;
  const int NOT_FOUND = 0;
  memset(dict, NOT_EXISTED, sizeof(dict));
  memset(window, NOT_EXISTED, sizeof(window));
  /* 
  * Go through the T, and inital the dict[] and window[] 
  * Notes: a same char can be appeared multiple times.
  */
  for(int i=0; i<t.size(); i++) {
  dict[t[i]]==NOT_EXISTED ? dict[t[i]]=1 : dict[t[i]]++ ; 
  window[t[i]] = NOT_FOUND; 
  }
  int start =-1;
  int winSize = INT_MAX;
  int letterFound = 0;
  int left = 0;
  for(int right=0; right<s.size(); right++) {
  if ( dict[s[right]] == NOT_EXISTED ){
  continue;
  }
  /* if s[i] is existed in `t` */ 
  char chr = s[right];
  window[chr]++;
  /* if one char has been found enough times, then do not do letterFound++ */
  if (window[chr] <= dict[chr]) {
  letterFound++;
  }
  if ( letterFound >= t.size() ) {
  /* 
  * Find the left of the window - try to make the window smaller
  * 1) windows[S[left]] == NOT_EXISTED ===> the char at the `left` is not in T
  * 2) window[S[left]] > dict[S[left]] ===> a same char appeared more than excepted.
  */
  char chl = s[left];
  while ( window[chl] == NOT_EXISTED || window[chl] > dict[chl] ) { 
  if (dict[chl] != NOT_EXISTED ) {
  //move the left of window
  window[chl]--; 
  // reduce the number of letters found
  if (window[chl] < dict[chl] ) letterFound--;
  }
  chl = s[++left];
  }
  /* Calculate the minimized window size */
  if(winSize > right - left + 1){
  start = left;
  winSize = right - left + 1;
  }
  }
  }
  if (start>=0 && winSize>0) {
  win = s.substr(start, winSize);
  }
  return win;
 }
 int main(int argc, char**argv)
 {
  string S = ""ADOBECODEBANC"";
  string T = ""ABC"";
  if (argc>2){
  S = argv[1];
  T = argv[2];
  }
  cout << ""S = \"""" << S << ""\"" T=\"""" << T << ""\"""" <<endl;
  cout << minWindow(S, T) << endl;
  return 0;
 }"
290,290,"/**
  * // This is the interface that allows for creating nested lists.
  * // You should not implement it, or speculate about its implementation
  * class NestedInteger {
  * public:
  * // Constructor initializes an empty nested list.
  * NestedInteger();
  *
  * // Constructor initializes a single integer.
  * NestedInteger(int value);
  *
  * // Return true if this NestedInteger holds a single integer, rather than a nested list.
  * bool isInteger() const;
  *
  * // Return the single integer that this NestedInteger holds, if it holds a single integer
  * // The result is undefined if this NestedInteger holds a nested list
  * int getInteger() const;
  *
  * // Set this NestedInteger to hold a single integer.
  * void setInteger(int value);
  *
  * // Set this NestedInteger to hold a nested list and adds a nested integer to it.
  * void add(const NestedInteger &ni);
  *
  * // Return the nested list that this NestedInteger holds, if it holds a nested list
  * // The result is undefined if this NestedInteger holds a single integer
  * const vector<NestedInteger> &getList() const;
  * };
  */
 class Solution {
 public:
  NestedInteger deserialize(string s) {
  if (s.size()==0) return NestedInteger();
  int pos = 0;
  if (s[pos]!='[') return atoni(s, pos);
  return helper(s, ++pos);
  }
 private:
  NestedInteger helper(string& s, int& pos) {
  NestedInteger ni;
  while ( s[pos] != ']' && pos < s.size() ) {
  if (s[pos]=='-' || isnum(s[pos])){
  ni.add(atoni(s, pos));
  }else if (s[pos] == '[') {
  pos++;
  ni.add(helper(s, pos));
  }else {
  pos++;
  }
  }
  pos++;
  return ni;
  }
  NestedInteger atoni(string& s, int& pos) {
  int sign = 1;
  int num = 0;
  if (s[pos]=='-') {
  sign = -1;
  pos++;
  }
  for (; pos < s.size(); pos++) {
  if (isnum(s[pos])) {
  num = num * 10 + s[pos] - '0';
  }else{
  break;
  }
  }
  return NestedInteger(sign * num);
  }
  bool isnum(char& c) {
  return (c >='0' && c <='9');
  }
 };"
291,291,"#include <stdlib.h>
 #include <iostream>
 using namespace std;
 //It seems C++ vector cause the Memory Limit Error, So, implement a simple one
 template <typename T>
 class Stack {
  private:
  T* _stack;
  int _capacity;
  int _top;
  public:
  Stack():_capacity(1),_top(-1){
  _stack = (T*)malloc(_capacity*sizeof(T));
  }
  ~Stack(){
  free(_stack);
  }
  void push(T x){
  _top++;
  if ( _top >= _capacity ){
  //if capacity is not enough, enlarge it 5 times.
  //Notes: why 5 times? because if you change to other(e.g. 2 times), 
  // LeetCode system will report Run-time Error! it sucks!
  _capacity*=5;
  _stack = (T*)realloc(_stack, _capacity*sizeof(T));
  }
  _stack[_top] = x;
  }
  T pop() {
  return top(true);
  }
  T& top(bool pop=false) {
  if (_top>=0){
  if (pop){
  return _stack[_top--];
  }
  return _stack[_top];
  }
  static T null;
  return null;
  }
  bool empty(){
  return (_top<0);
  }
  int size() {
  return _top+1;
  }
  void clear(){
  _top = -1;
  }
 };
 /*
  * Idea: 
  *
  * Using two stacks, 
  * 1) one stack is the real stack to store the data.
  * 2) another stack store the minimal number when it changes.
  *
  * For example:
  *
  * if we keep pushing the following numbers:
  * 5 1 1 2 3 2 
  * the minial number stack will be: 
  * 5 1 1 <-- only store the number which <= cureent minimal number
  * 
  * Then, when we pop up the stack.
  *
  * we need compare whether the current number is the current minial number.
  * if it is, then we need popup the number in minimal number stack.
  * 
  */
 class MinStack {
  private:
  //Using a minData struct to remove the duplication in minimal stack
  //which can save the memory.
  struct minData{
  int min;
  int cnt;
  minData():min(0), cnt(0) {}
  minData(int m, int c):min(m),cnt(c){}
  };
  Stack<int> stack; //real stack store the data
  Stack<minData> minStack; //minimal number stack store the number 
  int min; //current minial number
  public:
  void push(int x) {
  if(stack.empty()){
  min = x;
  minStack.push(minData(x,1));
  }else{
  if (min >= x ){
  min = x;
  //if current minial number already pushed, then just add the reference coount.
  if (minStack.top().min == x){
  minStack.top().cnt++;
  }else{
  minStack.push(minData(x,1));
  }
  }
  }
  stack.push(x);
  }
  void pop() {
  if (stack.empty()){
  return;
  }
  int x = stack.pop();
  if (x == minStack.top().min){
  //de-reference the count at first.
  if (minStack.top().cnt > 1){
  minStack.top().cnt--;
  }else{
  minStack.pop();
  min = minStack.top().min;
  }
  }
  }
  int top() {
  return stack.top();
  }
  int getMin() {
  return min;
  }
  void clear() {
  stack.clear();
  minStack.clear();
  }
 };
 int main()
 {
  cout << ""--- expected output [0, 0, 0, 2]"" << endl;
  MinStack ms;
  ms.push(2);
  ms.push(0);
  ms.push(3);
  ms.push(0);
  cout << ms.getMin() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  ms.clear();
  cout << ""--- expected output [2147483647 2147483646 2147483646 2147483647 2147483647 -2147483648 -2147483648 2147483647 "" << endl;
  ms.push(2147483646);
  ms.push(2147483646);
  ms.push(2147483647);
  cout << ms.top() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  ms.pop();
  ms.push(2147483647);
  cout << ms.top() << endl;
  cout << ms.getMin() << endl;
  ms.push(-2147483648);
  cout << ms.top() << endl;
  cout << ms.getMin() << endl;
  ms.pop();
  cout << ms.getMin() << endl;
  return 0;
 }"
292,292,"class Solution {
 public:
  // This problem can be converted to the classic problem --
  // `There is an array, all of numbers except one appears twice, and that one only appears once`
  // It means, we can combin two arrays together, one is [1..n], another one is `nums`.
  // Then, you know, we can use the XOR solve this problem.
  int missingNumber01(vector<int>& nums) {
  int result = 0;
  for(int i=0; i<nums.size(); i++){
  result ^= nums[i];
  }
  for(int i=1; i<=nums.size(); i++){
  result ^=(i);
  }
  return result;
  }
  // We can simplify the previous solution as below
  int missingNumber02(vector<int>& nums) {
  int result = 0;
  for(int i=0; i<nums.size(); i++){
  result = result ^ (i+1) ^ nums[i];
  }
  return result;
  }
  int missingNumber(vector<int>& nums) {
  //By Leetcode running result, they all are same performance
  return missingNumber02(nums); //36ms
  return missingNumber01(nums); //36ms
  }
 };"
293,293,"#include <stdlib.h>
 #include <iostream>
 #include <sstream>
 #include <string>
 #include <vector>
 #include <algorithm>
 #include <iterator>
 using namespace std;
 string& makeRange(int lo, int hi){
  static string result;
  result="""";
  stringstream ss;
  if (lo != hi){
  ss << lo << ""->"" << hi;
  }else{
  ss << lo;
  }
  ss >> result;
  return result;
 }
 vector<string> findMissingRanges(int A[], int n, int lower, int upper) {
  vector<string> result;
  if ( n<=0 ) {
  result.push_back(makeRange(lower, upper));
  return result;
  }
  if (lower < A[0]){
  result.push_back(makeRange(lower, A[0]-1 < upper ? A[0]-1 : upper));
  }
  for(int i=0; i<n-1; i++){
  if ( A[i] + 1 == A[i+1] ) {
  continue;
  }
  result.push_back(makeRange(A[i]+1, A[i+1]-1));
  }
  if (upper > A[n-1]){
  result.push_back(makeRange(A[n-1]+1, upper));
  }
  return result;
 }
 void printVector(vector<string> v){
  cout << ""["";
  int i=0;
  for(; i<v.size(); i++){
  cout << ""\"""" << v[i] << ""\"""" << (i==v.size()-1 ? """":"", "" );
  }
  cout << ""]"" <<endl;
 }
 vector<int> string2Array(string s){
  vector<string> strarr;
  istringstream iss(s);
  copy(istream_iterator<string>(iss),
  istream_iterator<string>(),
  back_inserter(strarr));
  vector<int> result;
  for (int i=0; i<strarr.size(); i++){
  result.push_back(atoi(strarr[i].c_str()));
  }
  return result;
 }
 int main(int argc, char**argv)
 {
  int A[] = {0, 1, 3, 50, 75};
  int lo = 0;
  int hi = 99;
  vector<string> result = findMissingRanges(A, sizeof(A)/sizeof(A[0]), lo ,hi);
  printVector(result); 
  //usage: ./missingRanges 0 9 ""3 5 7""
  if (argc>3){
  lo = atoi(argv[1]);
  hi = atoi(argv[2]);
  vector<int> a;
  a = string2Array(argv[3]);
  int *pA = &a[0];
  result = findMissingRanges(pA, a.size(), lo, hi);
  printVector(result); 
  }
  return 0;
 }"
294,294,"class Solution {
 private:
  bool isLetter(char c) {
  return c >= 'a' && c <= 'z';
  }
 public:
  string mostCommonWord(string paragraph, vector<string>& banned) {
  unordered_map<string, int> banned_map, words_map;
  for (auto w:banned) {
  banned_map[w]++;
  }
  //conert the string to lower case.
  transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);
  //transfer the symbols to space.
  for (int i=0; i<paragraph.size(); i++) {
  if ( !isLetter(paragraph[i]) ){
  paragraph[i] = ' ';
  }
  }
  string word;
  for(auto c:paragraph) {
  if (isLetter(c)) { 
  word += c;
  }else{
  if ( word.size()>0 ) {
  words_map[word]++;
  }
  word="""";
  }
  }
  if ( word.size()>0 ) words_map[word]++;
  string result;
  int max_cnt=0;
  // go through the words_map
  for (auto const& w : words_map) {
  if ( banned_map.find(w.first) != banned_map.end() ) {
  continue;
  }
  if (max_cnt < w.second) {
  result = w.first;
  max_cnt = w.second;
  }
  }
  return result;
  }
 };"
295,295,"class Solution {
 public:
  /* 
  * Solution (Calinescu Valentin)
  * ==============================
  *
  * One solution would be to store the position of the next non-zero element of the array.
  * Every position of the array, starting with position 0, must store this next non-zero
  * element until we can no more do that, case in which we need to add the remaining zeros
  * that we skipped.
  * 
  * 
  * Time Complexity: O(N)
  * Space Complexity: O(1)
  * 
  */
  void moveZeroes(vector<int>& nums) {
  int i = 0, poz = 0;
  for(i = 0; i < nums.size() && poz < nums.size(); i++)
  {
  while(poz < nums.size() && nums[poz] == 0)
  poz++;
  if(poz < nums.size())
  nums[i] = nums[poz];
  else
  i--; // we need 0 on position i, but i is increasing one last time
  poz++;
  }
  for(; i < nums.size(); i++)
  nums[i] = 0;
  }
  /*
  * Another implemtation which is easy to understand (Hao Chen)
  * ===========================================================
  *
  * We have two pointers to travel the array, assume they named `p1` and `p2`.
  * 
  * 1) `p1` points the tail of current arrays without any ZEROs.
  * 2) `p2` points the head of the rest array which skips the ZEROs.
  * 
  * Then we can just simply move the item from `p2` to `p1`.
  *
  */
  void moveZeroes(vector<int>& nums) {
  int p1=0, p2=0;
  // Find the first ZERO, where is the tail of the array.
  // (Notes: we can simply remove this!)
  for (; p1<nums.size() && nums[p1]!=0; p1++);
  // copy the item from p2 to p1, and skip the ZERO
  for (p2=p1; p2<nums.size(); p2++) {
  if ( nums[p2] == 0 ) continue;
  nums[p1++] = nums[p2]; 
  } 
  //set ZERO for rest items 
  while ( p1<nums.size() ) nums[p1++] = 0;
  }
 };"
296,296,"#include <iostream>
 #include <string>
 using namespace std;
 string multiply(string& num, char ch){
  int n = ch - '0';
  string s;
  int carry = 0;
  int x;
  for(int i=num.size()-1; i>=0; i--){
  x = (num[i]-'0') * n + carry;
  carry = x/10;
  s.insert(s.begin(), x%10+'0'); 
  }
  if (carry>0) {
  s.insert(s.begin(), carry+'0');
  }
  return s;
 }
 string strPlus(string& num1, string& num2) {
  string s;
  int carry=0;
  int x;
  int n1 = num1.size(); 
  int n2 = num2.size(); 
  int i, j;
  for(i=n1-1, j=n2-1; i>=0 || j>=0; i--, j--){
  int x1 = i>=0 ? num1[i]-'0' : 0;
  int x2 = j>=0 ? num2[j]-'0' : 0;
  x = x1 + x2 + carry; 
  carry = x/10;
  s.insert(s.begin(), x%10+'0');
  }
  if (carry>0) {
  s.insert(s.begin(), carry+'0');
  }
  return s;
 }
 string multiply(string num1, string num2) {
  if (num1.size()<=0 || num2.size()<=0) return """";
  int shift=0;
  string result=""0"";
  for (int i=num1.size()-1; i>=0; i--) {
  string s = multiply(num2, num1[i]); 
  for(int j=0; j<shift; j++){
  s.insert(s.end(), '0');
  }
  result = strPlus(result, s);
  shift++;
  }
  //check if it is zero
  if (result[0]=='0') return ""0"";
  return result;
 }
 /********************************************************************************** 
  * Another implementation
  **********************************************************************************/
 class Solution {
  public:
  string strPlus(string& num1, string& num2) {
  if (num1.size()==0) return num2;
  if (num2.size()==0) return num1;
  if ( num1.size() < num2.size() ) {
  swap(num1, num2);
  }
  string s;
  int carry=0;
  int x;
  for (int i=num1.size()-1, j=num2.size()-1; i>=0; i--, j--) {
  x = num1[i]-'0' + carry;
  if(j>=0){
  x += num2[j]-'0';
  }
  s.insert(s.begin(), x%10+'0');
  carry = x/10;
  }
  if (carry>0) {
  s.insert(s.begin(), carry+'0');
  }
  return s;
  }
  string multiply(string num1, string num2) {
  if (num1.size()<=0 || num2.size()<=0) return """";
  string result;
  for ( int i=num1.size()-1; i>=0; i--) {
  int carry = 0;
  string val;
  for( int j=num2.size()-1; j>=0; j--) {
  int v = (num2[j]-'0') * (num1[i]-'0') + carry;
  val.insert(val.begin(), v%10+'0');
  carry = v/10;
  }
  if (carry) val.insert(val.begin(), carry+'0');
  for (unsigned int j=i; j<num1.size()-1; j++) {
  val.push_back('0');
  }
  result = strPlus(result, val);
  }
  //check if it is zero
  if (result[0]=='0') return ""0"";
  return result;
  }
 };
 int main(int argc, char**argv)
 {
  string s1=""20"";
  string s2=""25"";
  if (argc>2){
  s1 = argv[1];
  s2 = argv[2];
  }
  cout << s1 << "" * "" << s2 << "" = "" << multiply(s1, s2) << endl;
  return 0;
 }"
297,297,"/*
  * Take a look the following continuous permutation, can you find the patern?
  *
  * 1 2 3 4
  * 1 2 4 3
  * 1 3 2 4
  * 1 3 4 2
  * 1 4 2 3
  * 1 4 3 2
  * 2 1 3 4
  * ...
  *
  * The pattern can be descripted as below:
  *
  * 1) from n-1 to 0, find the first place [i-1] which num[i-1] < num[i]
  * 2) from n-1 to i, find the first number from n-1 to i which >= num[i-1]
  * 3) swap the 2) num with the num[i-1]
  * 4) sort the sub-array [i, n) //actuall sort is fine as well
  * 
  * For example:
  * 
  * 1 4 3 2 <-- 1) find the first place which num[i-1] < num[i]
  * ^
  * 
  * 1 4 3 2 <-- 2) find the first number from n-1 to i which >= num[i-1]
  * ^ ^ 
  * 
  * 2 4 3 1 <-- 3) swap them
  * ^ ^
  * 
  * 2 4 3 1 <-- 4) sort
  * ^ ^
  *
  * 2 1 3 4 
  * 
  * Edge Case:
  *
  * 4 3 2 1, the next permutation is 1 2 3 4
  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void nextPermutation(vector<int> &num) {
  if(num.size()<=1) return;
  for(int i=num.size()-1; i>0; i--) {
  if (num[i-1] < num[i]){
  int j = num.size()-1;
  while( num[i-1] >= num[j]) {
  //pass;
  j--;
  }
  int tmp = num[j];
  num[j] = num[i-1];
  num[i-1] = tmp;
  //sort works as well
  //sort(num.begin()+i, num.end()); 
  reverse(num.begin()+i, num.end()); 
  return; 
  }
  //edge case: 4 3 2 1
  if (i == 1 ){
  //sort works as well
  //sort(num.begin(), num.end());
  reverse(num.begin(), num.end());
  return;
  }
  }
 }
 void printVector(vector<int> &num) {
  for(int i=0; i<num.size(); i++) {
  cout << num[i] << "" "";
  } 
  cout <<endl;
 }
 bool isBeginVector(vector<int> &num) {
  for(int i=0; i<num.size(); i++) {
  if(num[i] != i+1) {
  return false;
  }
  } 
  return true;
 }
 int main(int argc, char** argv)
 {
  int n = 4;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector<int> num;
  for(int i=1; i<=n; i++){
  num.push_back(i);
  }
  while(true){
  printVector(num);
  nextPermutation(num);
  if(isBeginVector(num)){
  break;
  }
  }
  return 0;
 }"
298,298,"/* 
  * Solutions
  * =========
  *
  * Let's look at the example:
  * 
  * 0 stones - false
  * 1 stone - true
  * 2 stones - true
  * 3 stones - true
  * 4 stones - false
  * 
  * We notice that all we need for a position to be true is to get the opponent in a position 
  * that is false. With 1, 2 and 3 you can take 1, 2 and 3 stones respectively to force your 
  * opponent into having 0 stones, a position where he cannot win. No matter how many stones 
  * we take from 4 we cannot 
  *
  * force the opponent into a losing positon, so position 4 becomes a losing position. 
  * Let's take a look at the next 4 positions:
  * 
  * 5 stones - true
  * 6 stones - true
  * 7 stones - true
  * 8 stones - false
  * 
  * With 5, 6 and 7 stones we can take 1, 2 and 3 stones respectively to force the opponent into 
  * position 4. Position 8 is a losing one because we can only force the opponent into winning 
  * positions. We notice that this group of 4 positions can repeat itself indefinitely, because 
  * we only need the previous 3 positions to judge whether a position is winning or losing. 
  *
  * Thus we can see the pattern:
  * 
  * n % 4 == 0 - false
  * n % 4 != 0 - true
  * 
  */
 class Solution {
 public:
  bool canWinNim(int n) {
  return !(n % 4 == 0);
  }
 };"
299,299,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 vector< vector<string> > solveNQueens(int n); 
 void solveNQueensRecursive(int n, int currentRow, vector<int>& solution, vector< vector<string> >& result); 
 bool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn); 
 vector< vector<string> > solveNQueens(int n) {
  vector< vector<string> > result;
  vector<int> solution(n);
  solveNQueensRecursive(n, 0, solution, result);
  return result; 
 }
 //The following recursion is easy to understand. Nothing's tricky.
 // 1) recursively find all of possible columns row by row.
 // 2) solution[] array only stores the columns index. `solution[row] = col;` 
 void solveNQueensRecursive(int n, int currentRow, vector<int>& solution, vector< vector<string> >& result) {
  //if no more row need to do, shape the result
  if (currentRow == n){
  vector<string> s;
  vector<string> s(n, string(n, '.'));
  for (int row = 0; row < n; row++) {
  s[row][solution[row]] = 'Q';
  }
  result.push_back(s);
  return;
  }
  //for each column
  for (int col = 0; col < n; col++) {
  //if the current column is valid
  if (isValid(col, currentRow, solution) ) {
  //place the Queue
  solution[currentRow] = col;
  //recursively put the Queen in next row
  solveNQueensRecursive(n, currentRow+1, solution, result);
  }
  } 
 }
 //Attempting to put the Queen into [row, col], check it is valid or not
 //Notes: 
 // 1) we just checking the Column not Row, because the row cannot be conflicted
 // 2) to check the diagonal, we just check |x'-x| == |y'-y|, (x',y') is a Queen will be placed
 bool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn) {
  for(int i=0; i<attemptedRow; i++) {
  if (attemptedColumn == queenInColumn[i] || 
  abs(attemptedColumn - queenInColumn[i]) == abs(attemptedRow - i)) {
  return false;
  } 
  }
  return true;
 }
 void printMatrix(vector< vector<string> >& matrix ){
  for (int i = 0; i < matrix.size(); i++) {
  cout << ""-----------"" << endl;
  for (int j = 0; j < matrix[i].size(); j++) {
  cout << matrix[i][j] << endl;
  }
  }
 }
 int main(int argc, char** argv)
 {
  int n = 8;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector< vector<string> > result = solveNQueens(n);
  printMatrix(result);
  return 0;
 }"
300,300,"#include <stdlib.h>
 #include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 int totalNQueens(int n); 
 void solveNQueensRecursive(int n, int currentRow, vector<int>& solution, int& result); 
 bool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn); 
 int totalNQueens(int n) {
  int result=0;
  vector<int> solution(n);
  solveNQueensRecursive(n, 0, solution, result);
  return result; 
 }
 // the solution is same as the ""N Queens"" problem.
 void solveNQueensRecursive(int n, int currentRow, vector<int>& solution, int& result) {
  for (int i = 0; i < n; i++) {
  if (isValid(i, currentRow, solution) ) {
  if (currentRow+1 == n){
  result++;
  continue;
  }
  solution[currentRow] = i;
  solveNQueensRecursive(n, currentRow+1, solution, result);
  }
  } 
 }
 bool isValid(int attemptedColumn, int attemptedRow, vector<int> &queenInColumn) {
  for(int i=0; i<attemptedRow; i++) {
  if (attemptedColumn == queenInColumn[i] || 
  abs(attemptedColumn - queenInColumn[i]) == abs(attemptedRow - i)) {
  return false;
  } 
  }
  return true;
 }
 int main(int argc, char** argv)
 {
  int n = 8;
  if (argc>1){
  n = atoi(argv[1]);
  }
  int result = totalNQueens(n);
  cout << n << "" Queens, total = "" << result << endl;
  return 0;
 }"
301,301,"class Solution {
 public:
  int repeatedNTimes(vector<int>& A) {
  map<int,int>myMap;
  for(int i=0;i<A.size();i++){
  myMap[A[i]]++;
  }
  for(auto x:myMap){
  if((x.second)==(A.size()/2)){
  return x.first;
  }
  }
  return 0;
  }
 };"
302,302,"#include <cmath>
 using namespace std;
 class Solution {
 public:
  int findNthDigit(int n) {
  // We can see the following pattern:
  //
  // 1, 2, .... 9 : there are 9 * 1 digits.
  // 10, 11, ..., 99: there are 90 * 2 digits. 
  // 101, 102, 103, ..., 999: there are 900 * 3.
  // ...
  //we can count the digits with the above pattern
  long digits_cnt = 0;
  long digits_cnt_prev = 0;
  int base = 0;
  for ( ; digits_cnt < n; base++) {
  digits_cnt_prev = digits_cnt;
  digits_cnt = digits_cnt + 9 * pow(10 , base) * ( base + 1 );
  }
  // Now, we got `digits_cnt_prev`, `digits_cnt` and `base`
  //
  // For examples: 
  // n = 20; digits_cnt_prev = 9, digits_cnt = 9+90*2 = 189, base = 2;
  // n = 500; digits_cnt_prev = 9+90*2 = 189, digits_cnt = 9+90*2+900*3 = 2889, base = 3;
  // n = 2000; digits_cnt_prev = 9+90*2 = 189, digits_cnt = 9+90*2+900*3 = 2889, base = 3;
  //
  // It means, we found the range where the number it is
  // n = 20, the number located in the range 10 -- 99
  // n = 500, the number located in the range 100 - 999
  //
  // and we can use `digits_cnt_prev` to know the previous rangs produce how many digits.
  // n = 20, the previous ranges produce 9 digits, so there needs 20-9 = 11 digits in [10 - 99]
  // n = 500, the previous ranges produce 189 digits, so there needs 500-189 = 311 digits in [100-999]
  // 
  // the `base` told us in current ranges, each number can have how many digits.
  // then we can locate the target number.
  // n = 20, 
  // (n - digits_cnt_prev) / base = (20 - 9 ) / 2 = 5, so, [10 - 14] produces 10 digits (ZERO-based),
  // now, we have 1 digits left, it is the first digit of the target number 15.
  //
  // n = 500, 
  // (n - digits_cnt_prev) / base = (500 - 189) / 3 = 103, so, [100 - 202] produces 309 digits(ZERO-based).
  // now, we have (500 - 189 - 309) = 2 digits left, it is the second digit of the target number 203.
  //
  // We can write the code now... 
  //
  int target = pow(10, base-1) + (n - digits_cnt_prev) / base - 1;
  int left = n - digits_cnt_prev - (n - digits_cnt_prev) / base * base;
  //cout << ""target = "" << target << "", left = "" << left << endl;
  //no digits left
  if ( left == 0 ) return (target) % 10;
  //still have some digits left, it should be in next number.
  target++;
  return int( target / pow(10, base - left) ) % 10;
  }
 };"
303,303,"class Solution {
 public:
  int hammingWeight(uint32_t n) {
  int cnt = 0;
  for(;n>0; n/=2){
  if (n & 0x1) cnt++;
  }
  return cnt;
  }
 };"
304,304,"class Solution {
 private:
  bool isNumber(char ch) {
  return (ch >='0' && ch <='9');
  }
 public:
  int numDifferentIntegers(string word) {
  word.push_back('z'); // add a char for edge case.
  bool intStart = false; // a stat for control 
  int start = 0, len = 0;
  unordered_map<string, bool> stat;
  for(int i=0; i<word.size(); i++) {
  if (!isNumber(word[i]) ) {
  if (intStart) {
  while(word[start]=='0') {
  start++, len--;
  }
  stat[word.substr(start, len)] = true;
  intStart=false; 
  }
  continue;
  }
  if (intStart == false) {
  intStart = true;
  start = i;
  len = 1;
  }else {
  len++;
  }
  }
  return stat.size(); 
  }
 };"
305,305,"class Solution {
 private:
  // Euclidean algorithm
  // https://en.wikipedia.org/wiki/Euclidean_algorithm
  int gcd(int a, int b) {
  while ( b != 0 ) {
  int t = b;
  b = a % b;
  a = t;
  }
  return a;
  }
 public:
  int countDifferentSubsequenceGCDs(vector<int>& nums) {
  int len = nums.size();
  vector<int> gcds(200001, 0);
  for(int i=0; i<len; i++) {
  int n = nums[i];
  int m = sqrt(n);
  for(int g=1; g<=m; g++){
  if (n % g != 0) continue;
  int x = g, y = n/g;
  if (x != y ){
  gcds[x] = gcd(n, gcds[x]);
  gcds[y] = gcd(n, gcds[y]);
  }else {
  gcds[x] = gcd(n, gcds[x]);
  }
  }
  }
  int cnt = 0;
  for(int i=1; i<gcds.size(); i++){
  if (gcds[i]==i) cnt++;
  }
  return cnt;
  }
 };"
306,306,"/*
  * The idea is:
  * 
  * 1) seprate the n to two parts. considering n is `abc` 
  * 
  * 2) at first, we seprate it to `ab` & `c`, then, 
  * c == 0, the # of `1` appears in uints is ""ab * 1""
  * c == 1, the # of `1` appears in units is ""ab * 1 + 0 + 1"" (0 means the number after `c`)
  * c > 1 , the # of `1` appears in units is ""(ab+1)*1""
  * 
  * 3) at second, we seprate it to `a` & `bc`, then,
  * b == 0, the # of `1` appears in tens is ""a * 10""
  * b == 1, the # of `1` appears in tens is ""a * 10 + c + 1"" (`c` means the number after `b`)
  * b > 1 , the # of `1` appears in tens is ""(a+1)*10""
  * 
  * 4) at thrid, we seprate it to `` & `abc`, then,
  * a == 0, the # of `1` appears in tens is ""0 * 100"" ( 0 menas the number before `a`)
  * a == 1, the # of `1` appears in tens is ""0 * 100 + bc + 1"" (`bc` means the number after `a`)
  * a > 1 , the # of `1` appears in tens is ""(0+1)*100"" 
  * 
  * 
  * For some examples: 
  * 0) n = 5, we have (0+1)*1 = 1 digit 1
  * 1) n = 53, we have (5+1)*1 + (0+1)*10 = 16 digit 1
  * 2) n = 20, we have (2*1) + (0+1)*10 = 12 digit 1 
  * 3) n = 21, we have (2*1+0+1) + (0+1)*10 = 13 digit 1
  * 4) n = 13, we have (1+1)*1 + (0*10+3+1) = 6 digit 1
  * 5) n = 109, we have (10+1)*1 + (1*10) + (0*100 + 09 + 1) = 31 digit 1 
  * 
  * Converting the ideas to code as below:
  * 
  */
 class Solution {
 public:
  int countDigitOne(int n) {
  long long base=1, left=n, right=0, currDigit=0;
  int numOfOne = 0;
  while(left>0) {
  currDigit = left % 10;
  left = left/ 10;
  if (currDigit == 0) {
  numOfOne += (left * base);
  }else if (currDigit == 1) {
  numOfOne += (left * base + right + 1);
  }else {
  numOfOne += ((left+1)*base);
  }
  right = right + currDigit * base;
  base *= 10;
  }
  return numOfOne;
  }
 };"
307,307,"class Solution {
 public:
  int numSplits(string s) {
  //just walk through the string from left side and right side, 
  //calculate the diffrent letters from both side.
  // `ldict` & `rdict` remember the letter occurs or not
  //vector bool is bit data structure
  const int max_chars= 256;
  vector<bool> ldict(max_chars, false), rdict(max_chars, false);
  // `lstat` & `rstat` are used to record the different letters.
  // `lstat` is used from left side walk through
  // `rstat` is used from right side walk through 
  int len = s.size();
  vector<int> lstat(len, 0), rstat(len, 0);
  int lcnt=0, rcnt=0;
  for (int i=0; i<len; i++) {
  char lc = s[i];
  char rc = s[len-i-1];
  if (ldict[lc] == false) {
  lcnt++;
  ldict[lc] = true;
  }
  if (rdict[rc] == false) {
  rcnt++;
  rdict[rc] = true;
  }
  lstat[i] = lcnt;
  rstat[len-i-1] = rcnt;
  }
  int cnt = 0;
  for (int i=1; i<len; i++){
  if (lstat[i-1] == rstat[i]) {
  cnt++;
  }
  }
  return cnt;
  }
 };"
308,308,"#include <iostream>
 #include <vector>
 using namespace std;
 void mark(vector<vector<char> >& grid, int r, int c){
  if ( r<0 || r>=grid.size() ||
  c<0 || c>=grid[0].size() ||
  grid[r][c] != '1' ) {
  return;
  }
  grid[r][c] = 'M';
  mark(grid, r, c+1); //left
  mark(grid, r, c-1); //right
  mark(grid, r-1, c); //up
  mark(grid, r+1, c); //down
 }
 int numIslands(vector<vector<char> >& grid) {
  int result = 0;
  for (int r=0; r<grid.size(); r++) {
  for (int c=0; c<grid[r].size(); c++) {
  if (grid[r][c] == '1') {
  result++;
  mark(grid, r, c);
  }
  }
  }
  return result;
 }
 void initGrid( string g[], int len, vector<vector<char> >& grid )
 {
  for (int i=0; i<len; i++){
  grid.push_back(vector<char>(g[i].begin(), g[i].end())); 
  }
 }
 int main(void)
 {
  vector< vector<char> > grid;
  grid.push_back( vector<char>(1, '1') );
  cout << numIslands(grid) << endl;
  grid.clear();
  string g1[] = { ""11110"",
  ""11010"", 
  ""11000"", 
  ""00000"" };
  initGrid(g1, 4, grid);
  cout << numIslands(grid) << endl;
  grid.clear();
  string g2[] = { ""11000"",
  ""11000"",
  ""00100"",
  ""00011"" };
  initGrid(g2, 4, grid);
  cout << numIslands(grid) << endl;
  return 0;
 }"
309,309,"class Order {
 public:
  int price;
  int amount;
 };
 enum COMP { GREATER, LESS };
 template <COMP op>
 class OrderComp {
 public:
  bool operator() (const Order& lhs, const Order& rhs) {
  if (op == GREATER) {
  return lhs.price > rhs.price;
  }
  return lhs.price < rhs.price;
  }
 };
 class Solution {
 private:
  template<typename T1, typename T2>
  void processOrder(T1& q1, T2& q2, COMP op, int price, int amount, string n1=""q1"", string n2=""q2"") {
  if (q2.size() == 0) {
  q1.push(Order{price, amount});
  return;
  }
  while(!q2.empty() && amount > 0 ){
  Order order = q2.top(); 
  if (op == GREATER && order.price > price ) break;
  if (op == LESS && order.price < price) break;
  q2.pop();
  //cout << ""=> deQueue(""<< n2 << ""): "" << order.price << "", ""<< order.amount << endl;
  int amt = min(order.amount, amount);
  order.amount -= amt;
  amount -= amt;
  if (order.amount > 0) {
  //cout << ""<= enQueue(""<< n2 <<""): "" << order.price << "", ""<< order.amount << endl;
  q2.push(order);
  }
  }
  if (amount > 0) {
  //cout << ""<= enQueue(""<< n1 <<""): "" << price << "", ""<< amount << endl;
  q1.push(Order{price, amount});
  }
  }
  template<typename T>
  void countQ(T& q, int& amount){
  while(!q.empty()) {
  amount = (amount + q.top().amount) % 1000000007;
  q.pop();
  }
  }
 public:
  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {
  priority_queue<Order, vector<Order>, OrderComp<GREATER>> sell;
  priority_queue<Order, vector<Order>, OrderComp<LESS>> buy;
  for (auto& order : orders) {
  int& price = order[0];
  int& amount = order[1];
  if (order[2] == 0) { //buy order
  processOrder(buy, sell, GREATER, price, amount, ""buy"", ""sell"");
  }else { // sell order
  processOrder(sell, buy, LESS, price, amount, ""sell"", ""buy"");
  }
  }
  int amount = 0;
  countQ(sell, amount);
  countQ(buy, amount);
  return amount ;
  }
 };"
310,310,"class RecentCounter {
 public:
  RecentCounter() {
  }
  int ping(int t) {
  req.push_back(t);
  return req.size() - binary_search(t-3000);
  }
 private:
  vector<int> req;
  int binary_search(int x) {
  int low=0, high=req.size()-1;
  while(low < high) {
  int mid = low + (high -low) / 2;
  if ( req[mid] == x ) return mid;
  if ( req[mid] < x ) low = mid + 1;
  else high = mid - 1;
  }
  cout << ""x="" << x << ""\tlow="" << low << endl;
  return x > req[low] ? low+1 : low ;
  }
 };
 /**
  * Your RecentCounter object will be instantiated and called as such:
  * RecentCounter* obj = new RecentCounter();
  * int param_1 = obj->ping(t);
  */"
311,311,"class Solution {
 public:
  int countGoodRectangles(vector<vector<int>>& rectangles) {
  return countGoodRectangles2(rectangles);
  return countGoodRectangles1(rectangles); 
  }
  int countGoodRectangles1(vector<vector<int>>& rectangles) {
  int maxLen = 0;
  for(auto& rect : rectangles) {
  int len = min(rect[0], rect[1]);
  maxLen = max(maxLen, len);
  }
  int cnt = 0;
  for(auto& rect : rectangles) {
  if (maxLen <= rect[0] && maxLen <= rect[1]) cnt++;
  }
  return cnt;
  }
  int countGoodRectangles2(vector<vector<int>>& rectangles) {
  int maxLen = 0;
  int cnt = 0;
  for(auto& rect : rectangles) {
  int len = min(rect[0], rect[1]);
  if (len > maxLen ) {
  cnt = 1;
  maxLen = len;
  }else if (len == maxLen ) {
  cnt++;
  }
  }
  return cnt;
  }
 };"
312,312,"class Solution {
  void printVector(vector<int>& v) {
  cout << ""["";
  for (int i = 0; i< v.size() -1 ; i ++) {
  cout << v[i] << "", "";
  }
  cout << v[v.size()-1] << ""]"" << endl;
  }
 public:
  int countRestrictedPaths(int n, vector<vector<int>>& edges) {
  // re-orginanize the graph map
  vector<unordered_map<int, int>> graph(n);
  for(auto e : edges) {
  int x = e[0]-1;
  int y = e[1]-1;
  int d = e[2];
  graph[x][y] = graph[y][x] = d; 
  }
  //Dijkstra Algorithm
  vector<int> distance(n, INT_MAX);
  distance[n-1] = 0;
  auto cmp = [&](const int& lhs, const int& rhs) {return distance[lhs] > distance[rhs]; };
  priority_queue<int, vector<int>, decltype(cmp)> nodes(cmp);
  nodes.push(n-1);
  while( !nodes.empty() ) {
  int x = nodes.top(); nodes.pop();
  for(const auto & [ y, d ] : graph[x]) { 
  if ( distance[y] > d + distance[x] ) {
  distance[y] = d + distance[x];
  // if the node's distance is updated, 
  // it's neighbor must be recaluated 
  nodes.push(y); 
  }
  }
  }
  //printVector(distance);
  //Dynamic Programming for restric paths
  vector<bool> visited(n, false);
  vector<long> restriced_path(n, 0);
  nodes.push(n-1);
  restriced_path[n-1] = 1;
  visited[n-1] = true;
  while( !nodes.empty() ) {
  int x = nodes.top(); nodes.pop();
  //cout << x+1 << "":"";
  for(const auto & [ y, d ] : graph[x]) { 
  if ( distance[y] > distance[x]) {
  restriced_path[y] += restriced_path[x];
  restriced_path[y] %= 1000000007;
  }
  if (!visited[y]) {
  //cout << y+1 << "","";
  nodes.push(y);
  visited[y] = true;
  }
  }
  //cout<<endl;
  //printVector(restriced_path);
  }
  //cout << ""-------"" <<endl;
  //printVector(restriced_path);
  return restriced_path[0];
  }
 };"
313,313,"class Solution {
 public:
  int countStudents(vector<int>& students, vector<int>& sandwiches) {
  int st[2] = {0};
  for(auto s: students) {
  st[s]++;
  }
  int cnt = 0;
  for(auto& san : sandwiches){
  if (st[san] == 0) break;
  st[san]--;
  cnt++;
  }
  return students.size() - cnt;
  }
 };"
314,314,"class Solution {
 public:
  int numOfSubarrays(vector<int>& arr) {
  //Walk through the array, and calculate the current sum
  //if current sum is odd, then all of the sum are evil previously are valid sub-array
  //if current sum is evil, then all of the sum are odd previously are valid sub-array
  int odd_sum_cnt=0, evil_sum_cnt=0;
  int sum = 0;
  long long result=0;
  for (auto a : arr) {
  sum += a;
  if (sum % 2 == 0) {
  evil_sum_cnt++;
  result += odd_sum_cnt;
  }else {
  odd_sum_cnt++;
  result += evil_sum_cnt + 1;
  }
  }
  return result % 1000000007;
  }
 };"
315,315,"class Solution {
 public:
  // 11 - 1+2
  // 111 - 1+2+3
  // 1111 - 1+2+3+4
  // 11111 - 1+2+3+4+5
  // so, we just simply find the length of continuous '1',
  // then, the answer it len*(len+1)/2
  int numSub(string s) {
  long long len=0;
  long long result=0;
  for (auto c : s) {
  if (c=='1') {
  len++;
  continue;
  }
  if (len > 0){
  result += len*(len+1)/2;
  len = 0;
  }
  }
  result += len*(len+1)/2;
  return result % 1000000007 ;
  }
 };"
316,316,"// solution->
 // time O(n) space O(n)
 #define mod (long long)(1e9+7)
 #define ll long long
 class Solution {
 public:
  int numWays(string s) {
  int n = s.size();
  vector<int> pre(n),suf(n),last(n);
  int count=0;
  for(int i=0;i<n;i++){
  if(s[i]=='1'){
  count++;
  }
  pre[i]=count;
  }
  // check if it can't be divided into three parts
  if(count%3!=0)
  return 0;
  int k = count/3;
  count=0;
  int t=0;
  for(int i=n-1;i>=0;i--){
  if(s[i]=='1')
  count++;
  suf[i]=count;
  }
  count=0;
  for(int i=n-1;i>=0;i--){
  if(suf[i]==k)
  count++;
  last[i]=count;
  }
  ll res=0;
  for(int i=0;i<n-1;i++){
  if(pre[i]==k){
  if(k!=0)
  res= (res+last[i+1])%mod;
  else
  res=(res+last[i+1]-1)%mod;
  }
  }
  return res;
  }
 };"
317,317,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode* oddEvenList(ListNode* head) {
  if (!head) return head;
  ListNode* pOdd = head;
  ListNode* p = head->next;
  ListNode* pNext = NULL;
  while(p && (pNext=p->next)) {
  p->next = pNext->next;
  pNext->next = pOdd->next;
  pOdd->next = pNext;
  p = p->next;
  pOdd = pOdd->next;
  }
  return head;
  }
 };"
318,318,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode* findMiddle(ListNode* head) {
  ListNode *p1=head, *p2=head;
  while(p2 && p2->next){
  p1 = p1->next;
  p2 = p2->next->next;
  }
  return p1;
  }
  ListNode* reverseLink(ListNode* head) {
  ListNode* p=NULL;
  while (head) {
  ListNode* q = head->next;
  head->next = p;
  p = head;
  head = q;
  }
  return p;
  }
  bool isPalindrome(ListNode* head) {
  ListNode* pMid = findMiddle(head);
  ListNode* pRev = reverseLink(pMid); 
  for(;head!=pMid; head=head->next, pRev=pRev->next) {
  if (head->val != pRev->val) {
  return false;
  }
  }
  return true;
  }
 };"
319,319,"#include <stdio.h>
 class Solution {
 public:
  bool isPalindrome(int x) { 
  return isPalindrome1(x);
  return isPalindrome2(x);
  }
  bool isPalindrome1(int x) {
  if (x<0) {
  return false;
  }
  int len=1;
  for (len=1; (x/len) >= 10; len*=10 );
  while (x != 0 ) {
  int left = x / len;
  int right = x % 10;
  if(left!=right){
  return false;
  }
  x = (x%len) / 10;
  len /= 100;
  }
  return true;
  }
  bool isPalindrome2(int x) {
  return (x>=0 && x == reverse(x));
  }
 private: 
  int reverse(int x) {
  int y=0;
  int n;
  while( x!=0 ){
  n = x%10;
  //check if y is overflowed or not. 
  //if it is, then it's not palindrome
  if ( y > INT_MAX/10 - n) return x-1;
  y = y*10 + n;
  x /= 10;
  }
  return y;
  }
 };
 int main()
 {
  Solution s;
  printf(""%d is %d\n"", 0, s.isPalindrome(0) );
  printf(""%d is %d\n"", -101, s.isPalindrome(-101) );
  printf(""%d is %d\n"", 1001, s.isPalindrome(1001) );
  printf(""%d is %d\n"", 1234321, s.isPalindrome(1234321) );
  printf(""%d is %d\n"", 2147447412, s.isPalindrome(2147447412) );
  printf(""%d is %d\n"", 2142, s.isPalindrome(2142) );
 }"
320,320,"class Solution {
 public:
  bool isPalindrome(string& str) {
  int left = 0, right = str.size() - 1;
  while( left < right) {
  if (str[left++] != str[right--]) return false;
  }
  return true;
  }
  vector<vector<int>> palindromePairs(vector<string>& words) {
  unordered_map<string, int> dict;
  for(int i=0; i<words.size(); i++){
  string w = words[i];
  reverse(w.begin(), w.end());
  dict[w] = i;
  }
  vector<vector<int>> result;
  //egde case: deal with empty string 
  if ( dict.find("""") != dict.end() ) {
  for(int i=0; i<words.size(); i++) {
  if ( isPalindrome(words[i]) && dict[""""] != i ) {
  result.push_back( { dict[""""], i } );
  }
  }
  }
  for(int i=0; i<words.size(); i++) {
  for (int j=0; j<words[i].size(); j++) {
  //split the word to 2 parts
  string left = words[i].substr(0, j);
  string right = words[i].substr(j, words[i].size() - j);
  // if the `left` is found, which means there is a words has reversed sequence with it.
  // then we can check the `right` part is Palindrome or not. 
  if ( dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i ) {
  result.push_back( { i, dict[left] } );
  }
  if (dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i ) {
  result.push_back( { dict[right], i } );
  }
  }
  }
  return result;
  }
 };"
321,321,"#include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 bool isPalindrome(string &s, int start, int end) { 
  while(start < end) 
  { 
  if(s[start] != s[end]) { 
  return false; 
  }
  start++; end--; 
  } 
  return true; 
 } 
 // DFS - Deepth First Search
 // 
 // For example: ""aaba""
 // 
 // +------+ 
 // +------| aaba |-----+ 
 // | +------+ | 
 // +-v-+ +-v--+ 
 // | a |aba | aa |ba
 // +---+---+--+ +--+-+ 
 // | | | 
 // +-v-+ +--v--+ +-v-+ 
 // | a |ba | aba |\0 | b |a 
 // +-+-+ +-----+ +-+-+ 
 // | a, aba | 
 // +-v-+ +-v-+ 
 // | b |a | a |\0
 // +-+-+ +---+ 
 // | aa, b, a
 // +-v-+ 
 // | a |\0 
 // +---+ 
 // a, a, b, a 
 //
 // You can see this algorithm still can be optimized, becasue there are some dupliation.
 // ( The optimization you can see the ""Palindrome Partitioning II"" )
 //
 void partitionHelper(string &s, int start, vector<string> &output, vector< vector<string> > &result) {
  if (start == s.size()) {
  result.push_back(output);
  return;
  }
  for(int i=start; i<s.size(); i++) {
  if ( isPalindrome(s, start, i) == true ) {
  //put the current palindrome substring into ouput
  output.push_back(s.substr(start, i-start+1) );
  //Recursively check the rest substring
  partitionHelper(s, i+1, output, result);
  //take out the current palindrome substring, in order to check longer substring.
  output.pop_back();
  }
  }
 }
 vector< vector<string> > partition(string s) {
  vector< vector<string> > result;
  vector<string> output;
  partitionHelper(s, 0, output, result);
  return result;
 }
 void printMatrix(vector< vector<string> > &matrix)
 {
  for(int i=0; i<matrix.size(); i++){
  cout << ""{ "";
  for(int j=0; j< matrix[i].size(); j++) {
  cout << matrix[i][j] << "", "";
  }
  cout << ""}"" << endl;
  }
  cout << endl;
 }
 int main(int argc, char** argv)
 {
  string s(""aab"");
  if ( argc > 1 ){
  s = argv[1];
  }
  vector< vector<string> > result = partition(s);
  printMatrix(result);
 }"
322,322,"#include <iostream>
 #include <string>
 #include <vector>
 #include <map>
 using namespace std;
 bool isPalindrome(string &s, int start, int end);
 void minCutHelper(string &s, int start, int steps, int& min );
 int minCutHelper(string &s, int steps, int& minSteps );
 int minCut_DP(string& s); 
 int minCut(string s) {
  #define INT_MAX 2147483647
  if(s.size()<=1) return 0;
  int min = INT_MAX;
  //minCutHelper(s, 0, 0, min);
  //return min-1;
  //int m = minCutHelper(s, 0, min);
  //return m-1;
  return minCut_DP(s);
 }
 /*
  * Dynamic Programming
  * -------------------
  *
  * Define res[i] = the minimum cut from 0 to i in the string.
  * The result eventually is res[s.size()-1].
  * We know res[0]=0. Next we are looking for the optimal solution function f.
  * 
  * For example, let s = ""leet"".
  * 
  * f(0) = 0; // minimum cut of str[0:0]=""l"", which is a palindrome, so not cut is needed.
  * f(1) = 1; // str[0:1]=""le"" How to get 1? 
  * f(1) might be: (1) f(0)+1=1, the minimum cut before plus the current char.
  * (2) 0, if str[0:1] is a palindrome (here ""le"" is not )
  * f(2) = 1; // str[0:2] = ""lee"" How to get 2?
  * f(2) might be: (1) f(1) + 1=2
  * (2) 0, if str[0:2] is a palindrome (here ""lee"" is not)
  * (3) f(0) + 1, if str[1:2] is a palindrome, yes! 
  * f(3) = 2; // str[0:3] = ""leet"" How to get 2?
  * f(3) might be: (1) f(2) + 1=2
  * (2) 0, if str[0:3] is a palindrome (here ""leet"" is not)
  * (3) f(0) + 1, if str[1:3] is a palindrome (here ""eet"" is not)
  * (4) f(1) + 1, if str[2:e] is a palindrome (here ""et"" is not)
  * OK, output f(3) =2 as the result.
  * 
  * So, the optimal function is:
  * 
  * f(i) = min [ f(j)+1, j=0..i-1 and str[j:i] is palindrome
  * 0, if str[0,i] is palindrome ]
  * 
  * The above algorithm works well for the smaller test cases, however for the big cases, it still cannot pass.
  * Why? The way we test the palindrome is time-consuming.
  * 
  * Also using the similar DP idea, we can construct the look-up table before the main part above, 
  * so that the palindrome testing becomes the looking up operation. The way we construct the table is also the idea of DP.
  *
  * e.g. mp[i][j]=true if str[i:j] is palindrome.
  * mp[i][i]=true; 
  * mp[i][j] = true if str[i]==str[j] and (mp[i+1][j-1]==true or j-i<2 ) j-i<2 ensures the array boundary. 
  */
 int minCut_DP(string& s) {
  //res[] is for minimal cut DP
  vector<int>res(s.size(),0);
  //mp[][] is for palindrome checking DP
  bool mp[s.size()][s.size()];
  //construct the pailndrome checking matrix
  // 1) matrix[i][j] = true; if (i==j) -- only one char
  // 2) matrix[i][j] = true; if (i==j+1) && s[i]==s[j] -- only two chars
  // 3) matrix[i][j] = matrix[i+1][j-1]; if s[i]==s[j] -- more than two chars
  //
  //note: 1) and 2) can be combined together
  for (int i=s.size()-1;i>=0;i--){
  for (int j=i;j<s.size();j++){
  if ((s[i]==s[j]) && (j-i<2 || mp[i+1][j-1])){
  mp[i][j]=true;
  }else{
  mp[i][j]=false;
  }
  }
  }
  //minimal cut dp
  for (int i=0;i<s.size();i++){
  //if s[0..i] is palindrome, then no need to cut
  if (mp[0][i] == true){
  res[i]=0;
  }else{
  // if s[0..i] isn't palindrome 
  // then, for each 0 to i, find a ""j"" which meets two conditions:
  // a) s[j+1..i] are palindrome.
  // b) res[j]+1 is minimal 
  int ms = s.size();
  for (int j=0; j<i; j++){
  if (mp[j+1][i] && ms>res[j]+1 ) {
  ms=res[j]+1;
  } 
  }
  res[i]=ms;
  }
  }
  return res[s.size()-1];
 }
 //More Optimized DFS - Time Limit Exceeded
 int minCutHelper(string &s, int steps, int& minSteps ) {
  // remove the steps if it's greater than minSteps 
  if (minSteps <= steps) {
  return -2;
  }
  // adding the cache to remove the duplicated calculation
  static map<string, int> cache;
  if ( cache.find(s)!=cache.end() ){
  if (s.size()>0)
  cout << s << "":"" << cache[s] << endl;
  return cache[s];
  }
  if (s.size()==0) {
  if (minSteps > steps){
  minSteps = steps;
  }
  cache[s] = 0;
  return 0;
  }
  int min = INT_MAX;
  string subs;
  int m; 
  for( int i=s.size()-1; i>=0; i-- ) {
  //remove the steps which greater than minSteps
  if ( i < s.size()-1 && minSteps - steps <= 1) {
  break;
  }
  if ( isPalindrome(s, 0, i) ){
  //if ( i == s.size()-1 ) {
  // m = 1;
  //}else{
  subs = s.substr(i+1, s.size()-i-1);
  m = minCutHelper(subs, steps+1, minSteps) + 1;
  //}
  if (m < 0) continue;
  cache[subs] = m-1;
  if (min > m ){
  min = m;
  }
  }
  }
  return min;
 }
 //Optimized DFS - Time Limit Exceeded
 void minCutHelper(string &s, int start, int steps, int& min ) {
  if (start == s.size()) {
  if (steps < min) {
  min = steps;
  return;
  }
  }
  //GREED: find the biggest palindrome first
  for(int i=s.size()-1; i>=start; i--){
  //cut unnecessary DFS 
  if ( min > steps && isPalindrome(s, start, i)) {
  minCutHelper(s, i+1, steps+1, min );
  }
  }
 }
 //traditional palindrome checking function.
 bool isPalindrome(string &s, int start, int end) { 
  while(start < end) { 
  if(s[start] != s[end]) { 
  return false; 
  }
  start++; end--; 
  } 
  return true; 
 } 
 //ababababababababababababcbabababababababababababa
 //fifgbeajcacehiicccfecbfhhgfiiecdcjjffbghdidbhbdbfbfjccgbbdcjheccfbhafehieabbdfeigbiaggchaeghaijfbjhi
 //aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 int main(int argc, char** argv)
 {
  string s(""aab"");
  if ( argc > 1 ){
  s = argv[1];
  }
  cout << s << "" : "" << minCut(s) << endl;
 }"
323,323,"class Solution {
 public:
  int countSubstrings(string s) {
  int len = s.size();
  if (len<=1) return len;
  vector< vector<bool> > dp(len, vector<bool>(len, false));
  int cnt = 0;
  for( int i=len-1; i>=0; i--) {
  for (int j=i; j<=len-1; j++) { 
  if ( i == j || ( s[i] == s[j] && ( j-i<2 || dp[i+1][j-1]) ) ) {
  dp[i][j] = true;
  cnt++;
  }
  }
  }
  return cnt; 
  }
 };"
324,324,"class Solution {
 public:
  //back tracking
  bool canPartitionRecrusion(vector<int>& nums, int half, int index) {
  for (int i=index; i<nums.size(); i++){
  int h = half - nums[i];
  if ( h < 0 ) return false; //cannot found the solution
  if ( h == 0 ) return true; //found the solution
  if ( canPartitionRecrusion(nums, h, i+1) == true ) return true;
  }
  return false;
  }
  bool canPartition(vector<int>& nums) {
  int sum = 0;
  for(auto n : nums) sum +=n;
  if ( sum & 1 ) return false; // sum % 2 != 1
  int half = sum / 2;
  //sort the array in descending order
  //so, the DFS could be very fast to find the answer because it's greedy.
  std::sort(nums.begin(), nums.end(), std::greater<int>()); 
  //go to find a path which sum is half
  return canPartitionRecrusion(nums, half, 0);
  }
 };"
325,325,"#include <stdio.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *partition(ListNode *head, int x) {
  ListNode fakeHead(0);
  fakeHead.next = head;
  head = &fakeHead;
  ListNode *pos = NULL;
  for(ListNode *p = head; p!=NULL && p->next!=NULL; ){
  if (!pos && p->next->val >= x){
  pos = p;
  p=p->next;
  continue;
  }
  if (pos && p->next->val < x){
  ListNode *pNext = p->next;
  p->next = pNext->next;
  pNext->next = pos->next;
  pos->next = pNext;
  pos = pNext;
  continue;
  }
  p=p->next;
  }
  return head->next;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main()
 {
  //int a[] = {1}; int x =2;
  //int a[] = {2,3,1}; int x=2;
  int a[] = {3,1,2}; int x=3;
  ListNode* p = createList(a, sizeof(a)/sizeof(int)); 
  printList(p);
  p = partition(p, x);
  printList(p);
  return 0;
 }"
326,326,"#include <stdlib.h>
 #include <vector>
 #include <iostream>
 using namespace std;
 vector<vector<int> > generate(int numRows) 
 {
  vector<vector<int> > pascalTriangle;
  for (int i=0; i<numRows; i++){
  vector<int> v;
  if (i==0){
  v.push_back(1);
  } else {
  v.push_back(1);
  for(int j=0; j<pascalTriangle[i-1].size()-1; j++){
  v.push_back(pascalTriangle[i-1][j] + pascalTriangle[i-1][j+1]);
  }
  v.push_back(1);
  }
  pascalTriangle.push_back(v); 
  }
  return pascalTriangle;
 }
 void printTriangle(vector< vector<int> > pt)
 {
 cout << ""["" << endl;
  for(int i=0; i<pt.size(); i++){
   for(int space=(pt.size()-i-1); space>=0; space--){
   cout << "" "";
   }
  cout << ""["";
  for(int j=0; j<pt[i].size(); j++){
  cout << pt[i][j];
  if(j<pt[i].size()-1){
   cout << "","";
  }
  }
  cout << ""]"";
  if(i<pt.size()-1){
   cout << "","";
  }
  cout << endl;
  }
  cout << ""]"" << endl;
 }
 int main(int argc, char** argv)
 {
  int n = 3;
  if (argc>1) {
  n = atoi(argv[1]);
  }
  printTriangle(generate(n)); 
 }"
327,327,"#include <stdlib.h>
 #include <vector>
 #include <iostream>
 using namespace std;
 vector<int> getRow(int rowIndex) {
  vector<int> v(rowIndex+1, 0);
  v[0]=1;
  for (int i=0; i<rowIndex; i++){
  for(int j=i+1; j>0; j--){
  v[j] += v[j-1];
  } 
  }
  return v;
 }
 void printVector( vector<int> pt)
 {
  cout << ""{ "";
  for(int j=0; j<pt.size(); j++){
  cout << pt[j] << "", "";
  }
  cout << ""} "" << endl;
 }
 int main(int argc, char** argv)
 {
  int n = 3;
  if (argc>1) { 
  n = atoi(argv[1]);
  }
  printVector(getRow(n)); 
 }"
328,328,"class Solution {
 public:
  int minPatches(vector<int>& nums, int n) {
  return minPatches_02(nums, n);
  return minPatches_01(nums, n);
  }
  // Greedy Algorithm
  // (Assume the array is sorted already)
  //
  // Let do some observation at first,
  //
  // 1) if we have [1,2] then we can cover 1, 2, 3
  // 2) if we have [1,2,3] then we can cover 1,2,3,4,5,6
  // So, it looks we can simply add all of nums together, then we can find out max number we can reach.
  //
  // 3) if we have [1,2,5], we can see 
  // 3.1) [1,2] can cover 1,2,3, but we cannot reach 4, 
  // 3.2) then we patch 4, then we have [1,2,4] which can cover 1,2,3(1+2),4,5(1+4),6(2+4), 7(1+2+4)
  // 3.3) we can see [1,2,4] can reach to 7 - sum all of them
  // 3.4) then [1,2,4,5], we can reach to 12 - 1,2,3,4,5,6,7,8(1+2+5),9(4+5),10(1+4+5), 11(2+4+5), 12(1+2+4+5)
  // 
  // So, we can have figure out our solution
  //
  // 0) considering the `n` we need to cover.
  // 1) maintain a variable we are trying to patch, suppose named `try_patch`
  // 2) if `try_patch` >= nums[i] then, we just keep add the current array item, 
  // and set the `try_patch` to the next patch candidate number - `sum+1`
  // 3) if `try_patch` < nums[i], which means we need to patch.
  //
  int minPatches_01(vector<int>& nums, int n) {
  long covered = 0; //avoid integer overflow
  int patch_cnt = 0;
  int i = 0;
  while (i<nums.size() ){
  // set the `try_patch` is the next number which we cannot cover
  int try_patch = covered + 1;
  // if the `try_patch` can cover the current item, then just sum it, 
  // then we can have the max number we can cover so far 
  if ( try_patch >= nums[i]) {
  covered += nums[i]; 
  i++;
  } else { // if the `try_patch` cannot cover the current item, then we find the number we need to patch
  patch_cnt++;
  //cout << ""patch "" << try_patch << endl;
  covered = covered + try_patch;
  } 
  if (covered >=n) break;
  }
  //for the case - [1], 7
  //the above while-loop just process all of the numbers in the array, 
  //but we might not reach the goal, so, we need keep patching.
  while (covered < n) {
  int try_patch = covered + 1;
  patch_cnt++;
  //cout << ""patch "" << try_patch << endl;
  covered = covered + try_patch;
  }
  return patch_cnt;
  }
  //The following solution just re-organizes the solution above, and make it shorter 
  int minPatches_02(vector<int>& nums, int n) {
  long covered = 0;
  int patch_cnt = 0;
  int i = 0;
  while ( covered < n){
  if (i<nums.size() && nums[i] <= covered + 1) {
  covered += nums[i++];
  }else{
  //cout << ""patch "" << covered + 1 << endl;
  covered = 2 * covered + 1;
  patch_cnt++;
  }
  }
  return patch_cnt;
  }
 };"
329,329,"#include <time.h>
 /**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  bool hasPathSum(TreeNode *root, int sum) {
  return hasPathSum3(root, sum, 0);
  return hasPathSum2(root, sum);
  return hasPathSum1(root, sum); 
  }
  bool hasPathSum3(TreeNode* root, int sum, int s) {
  if ( root == NULL) return false;
  s += root->val;
  if ( !root->left && !root->right) return s == sum;
  return (hasPathSum3(root->left, sum, s) || hasPathSum3(root->right, sum, s));
  }
  bool hasPathSum1(TreeNode *root, int sum) {
  if (root==NULL) return false;
  vector<TreeNode*> v;
  v.push_back(root);
  while(v.size()>0){
  TreeNode* node = v.back();
  v.pop_back();
  if (node->left==NULL && node->right==NULL){
  if (node->val == sum){
  return true;
  }
  }
  if (node->left){
  node->left->val += node->val;
  v.push_back(node->left);
  }
  if (node->right){
  node->right->val += node->val;
  v.push_back(node->right);
  }
  }
  return false;
  }
  bool hasPathSum2(TreeNode *root, int sum) {
  if (root==NULL) return false;
  if (root->left==NULL && root->right==NULL ){
  return (root->val==sum);
  }
  if (root->left){
  root->left->val += root->val;
  if (hasPathSum2(root->left, sum)){
  return true;
  }
  }
  if (root->right){
  root->right->val += root->val;
  if (hasPathSum2(root->right, sum)){
  return true;
  }
  }
  return false;
  }
 };"
330,330,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  vector<vector<int> > pathSum(TreeNode *root, int sum) {
  vector<vector<int> > result;
  vector<int> v;
  generatePathSum(root, sum, 0, v, result);
  return result;
  }
  void generatePathSum(TreeNode *root, int sum, int s, vector<int> v, vector<vector<int> >& result) {
  if (root==NULL) return ;
  s += root->val;
  v.push_back(root->val);
  if ( root->left==NULL && root->right==NULL) {
  if (s == sum) result.push_back(v);
  return;
  }
  generatePathSum(root->left, sum, s, v, result);
  generatePathSum(root->right, sum, s, v, result);
  }
 };"
331,331,"class Solution {
 public:
  int peakIndexInMountainArray(vector<int>& A) {
  // Put two dummy items at head and tail to avoid Out-of-Bound Error.
  #define INT_MAX 2147483647
  #define INT_MIN (-INT_MAX - 1)
  A.insert ( A.begin() , INT_MIN );
  A.push_back(INT_MIN);
  //binary search
  int len = A.size();
  int left = 1, right = len - 2;
  while(left <= right) {
  int mid = left + (right - left)/2; //avoid integer overflow
  if ( A[mid-1] < A[mid] && A[mid] > A[mid+1]) return mid-1;
  if ( A[mid-1] < A[mid] && A[mid] < A[mid+1]) left = mid + 1;
  if ( A[mid-1] > A[mid] && A[mid] > A[mid+1]) right = mid - 1;
  }
  return -1;
  }
 };"
332,332,"// Below is the interface for Iterator, which is already defined for you.
 // **DO NOT** modify the interface for Iterator.
 class Iterator {
  struct Data;
  Data* data;
 public:
  Iterator(const vector<int>& nums);
  Iterator(const Iterator& iter);
  virtual ~Iterator();
  // Returns the next element in the iteration.
  int next();
  // Returns true if the iteration has more elements.
  bool hasNext() const;
 };
 class PeekingIterator : public Iterator {
 private:
  bool m_hasNext;
  int m_next;
  void takeNext() {
  m_hasNext = Iterator::hasNext();
  if (m_hasNext) {
  m_next = Iterator::next();
  } 
  }
 public:
  PeekingIterator(const vector<int>& nums) : Iterator(nums) {
  // Initialize any member here.
  // **DO NOT** save a copy of nums and manipulate it directly.
  // You should only use the Iterator interface methods.
  takeNext();
  }
  // Returns the next element in the iteration without advancing the iterator.
  int peek() {
  return m_next;
  }
  // hasNext() and next() should behave the same as in the Iterator interface.
  // Override them if needed.
  int next() {
  int temp = m_next;
  takeNext();
  return temp;
  }
  bool hasNext() const {
  return m_hasNext;
  }
 };"
333,333,"class Solution {
 public:
  bool isRectangleCover(vector<vector<int>>& rectangles) {
  unordered_map<string,int> mp;
  string corners[4];
  for(auto v: rectangles)
  for(int i = 0; i<4; ++i){
  corners[i] = to_string(v[i/2*2]) + "","" + to_string(v[(i%2)*2+1]);
  if(mp[corners[i]] & int(pow(2,i))) return false;
  else mp[corners[i]] |= int(pow(2,i));
  }
  int corner = 0;
  for(auto i=mp.begin(); i!=mp.end(); ++i){
  int val = i->second;
  if(!(val & (val-1)) && (++corner >4)) return false;
  if((val & (val-1)) && !(val == 3 || val==12 || val==10 || val==5 || val==15)) return false;
  }
  return true; 
  }
 };"
334,334,"class Solution {
 public:
  int numSquares(int n) {
  return numSquares_dp_opt(n); //12ms
  return numSquares_dp(n); //232ms
  }
  /*
  * Dynamic Programming
  * ===================
  * dp[0] = 0 
  * dp[1] = dp[0]+1 = 1
  * dp[2] = dp[1]+1 = 2
  * dp[3] = dp[2]+1 = 3
  * dp[4] = min{ dp[4-1*1]+1, dp[4-2*2]+1 } 
  * = min{ dp[3]+1, dp[0]+1 } 
  * = 1 
  * dp[5] = min{ dp[5-1*1]+1, dp[5-2*2]+1 } 
  * = min{ dp[4]+1, dp[1]+1 } 
  * = 2
  * dp[6] = min{ dp[6-1*1]+1, dp[6-2*2]+1 } 
  * = min{ dp[5]+1, dp[2]+1 } 
  * = 3
  * dp[7] = min{ dp[7-1*1]+1, dp[7-2*2]+1 } 
  * = min{ dp[6]+1, dp[3]+1 } 
  * = 4
  * dp[8] = min{ dp[8-1*1]+1, dp[8-2*2]+1 } 
  * = min{ dp[7]+1, dp[4]+1 } 
  * = 2
  * dp[9] = min{ dp[9-1*1]+1, dp[9-2*2]+1, dp[9-3*3] } 
  * = min{ dp[8]+1, dp[5]+1, dp[0]+1 } 
  * = 1
  * dp[10] = min{ dp[10-1*1]+1, dp[10-2*2]+1, dp[10-3*3] } 
  * = min{ dp[9]+1, dp[6]+1, dp[1]+1 } 
  * = 2
  * ....
  *
  * So, the dynamic programm formula is
  * 
  * dp[n] = min{ dp[n - i*i] + 1 }, n - i*i >=0 && i >= 1
  *
  */
  int numSquares_dp(int n) {
  if ( n <=0 ) return 0;
  int *dp = new int[n+1];
  dp[0] = 0;
  for (int i=1; i<=n; i++ ) {
  int m = n;
  for (int j=1; i-j*j >= 0; j++) {
  m = min (m, dp[i-j*j] + 1);
  }
  dp[i] = m;
  }
  return dp[n];
  delete [] dp;
  }
  //using cache to optimize the dp algorithm
  int numSquares_dp_opt(int n) {
  if ( n <=0 ) return 0;
  static vector<int> dp(1, 0);
  if (dp.size() >= (n+1) ) return dp[n];
  for (int i=dp.size(); i<=n; i++ ) {
  int m = n;
  for (int j=1; i-j*j >= 0; j++) {
  m = min (m, dp[i-j*j] + 1);
  }
  dp.push_back(m);
  }
  return dp[n];
  }
 };"
335,335,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 /*
 { 1 2 3 }
 { 2 1 3 }
 { 3 2 1 }
 { 1 3 2 }
 { 2 3 1 }
 { 3 1 2 }
 */
 /*
  * The algroithm - Take each element in array to the first place.
  *
  * For example: 
  * 
  * 0) initalization 
  * 
  * pos = 0
  * [1, 2, 3] 
  *
  * 1) take each element into the first place, 
  *
  * pos = 1
  * [1, 2, 3] ==> [2, 1, 3] , [3, 1, 2] 
  *
  * then we have total 3 answers
  * [1, 2, 3], [2, 1, 3] , [3, 1, 2] 
  * 
  * 2) take each element into the ""first place"" -- pos 
  *
  * pos = 2
  * [1, 2, 3] ==> [1, 3, 2]
  * [2, 1, 3] ==> [2, 3, 1]
  * [3, 1, 2] ==> [3, 2, 1] 
  *
  * then we have total 6 answers
  * [1, 2, 3], [2, 1, 3] , [3, 1, 2], [1, 3, 2], [2, 3, 1], [3, 2, 1]
  *
  * 3) pos = 3 which greater than length of array, return.
  *
  */
 vector<vector<int> > permute(vector<int> &num) {
  vector<vector<int> > vv;
  vv.push_back(num);
  if (num.size() <2){
  return vv;
  }
  int pos=0;
  while(pos<num.size()-1){
  int size = vv.size();
  for(int i=0; i<size; i++){
  //take each number to the first place
  for (int j=pos+1; j<vv[i].size(); j++) {
  vector<int> v = vv[i];
  int t = v[j]; 
  v[j] = v[pos];
  v[pos] = t;
  vv.push_back(v);
  }
  }
  pos++;
  }
  return vv;
 }
 int main(int argc, char** argv)
 {
  int n = 3;
  if (argc>1){
  n = atoi(argv[1]); 
  }
  vector<int> v;
  for (int i=0; i<n; i++) {
  v.push_back(i+1);
  }
  vector<vector<int> > vv;
  vv = permute(v);
  for(int i=0; i<vv.size(); i++) {
  cout << ""{ "";
  for(int j=0; j<vv[i].size(); j++){
  cout << vv[i][j] << "" "";
  }
  cout << ""}"" <<endl;
  }
  return 0;
 }"
336,336,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 // To deal with the duplication number, we need do those modifications:
 // 1) sort the array [pos..n].
 // 2) skip the same number.
 vector<vector<int> > permute(vector<int> &num) {
  vector<vector<int> > vv;
  vv.push_back(num);
  if (num.size() <2){
  return vv;
  }
  int pos=0;
  while(pos<num.size()-1){
  int size = vv.size();
  for(int i=0; i<size; i++){
  //sort the array, so that the same number will be together
  sort(vv[i].begin()+pos, vv[i].end());
  //take each number to the first
  for (int j=pos+1; j<vv[i].size(); j++) {
  vector<int> v = vv[i];
  //skip the same number 
  if (j>0 && v[j]==v[j-1]){
  continue;
  }
  int t = v[j]; 
  v[j] = v[pos];
  v[pos] = t;
  vv.push_back(v);
  }
  }
  pos++;
  }
  return vv;
 }
 void printVector( vector<int>& pt)
 {
  cout << ""{ "";
  for(int j=0; j<pt.size(); j++){
  cout << pt[j] << "" "";
  }
  cout << ""} "" << endl;
 }
 int main(int argc, char** argv)
 {
  int n = 3;
  if (argc>1){
  n = atoi(argv[1]); 
  }
  srand(time(NULL));
  vector<int> v;
  for (int i=0; i<n; i++) {
  v.push_back(random()%n+1);
  }
  /*v[0] =0;
  v[1] =1;
  v[2] =0;
  v[3] =0;
  v[4] =9;*/
  printVector(v); 
  cout << ""-----------------"" << endl;
  vector<vector<int> > vv;
  vv = permute(v);
  for(int i=0; i<vv.size(); i++) {
  printVector(vv[i]);
  }
  return 0;
 }"
337,337,"#include <stdlib.h>
 #include <iostream>
 #include <sstream>
 #include <string>
 #include <vector>
 #include <algorithm>
 using namespace std;
 /*
 ""123""
 ""132""
 ""213""
 ""231""
 ""312""
 ""321""
 */
 void nextPermutation(vector<int>& num); 
 /* Extreamly Optimized */
 string getPermutation(int n, int k) {
  vector<int> num;
  int total = 1;
  for(int i=1; i<=n; i++){
  num.push_back(i);
  total *= i;
  }
  //invalid k;
  if( total < k ) {
  return """";
  }
  // Construct the k-th permutation with a list of n numbers
  // Idea: group all permutations according to their first number (so n groups, each of
  // (n-1)! numbers), find the group where the k-th permutation belongs, remove the common
  // first number from the list and append it to the resulting string, and iteratively
  // construct the (((k-1)%(n-1)!)+1)-th permutation with the remaining n-1 numbers
  int group = total;
  stringstream ss;
  while (n>0) {
  group = group / n;
  int idx = (k-1) / group;
  ss << num[idx];
  num.erase(num.begin()+idx);
  n--;
  //the next k also can be caculated like this: 
  // k = (k-1)%group + 1; 
  k -= group * idx;
  }
  return ss.str();
 }
 /* Optimization by determining the group */
 string getPermutation_0(int n, int k) {
  vector<int> num;
  int total = 1;
  for(int i=1; i<=n; i++){
  num.push_back(i);
  total *= i;
  }
  //invalid k;
  if( total < k ) {
  return """";
  }
  int group = total / n;
  int idx = (k-1) / group;
  int nn = num[idx];
  num.erase(num.begin()+idx);
  num.insert(num.begin(), nn);
  int offset = (k-1) % group;
  for(int i=0; i<offset; i++) {
  nextPermutation(num);
  }
  //string result;
  stringstream ss;
  for(int i=0; i<n; i++){
  ss << num[i];
  }
  return ss.str();
 }
 /* Time Limit Exceeded */
 string getPermutation_1(int n, int k) {
  vector<int> num;
  for(int i=1; i<=n; i++){
  num.push_back(i);
  }
  for(int i=1; i<k; i++) {
  nextPermutation(num);
  }
  //string result;
  stringstream ss;
  for(int i=0; i<n; i++){
  ss << num[i];
  }
  return ss.str();
 }
 void nextPermutation(vector<int>& num) {
  if (num.size()<=1) return;
  for (int i=num.size()-1; i>0; i-- ) {
  if (num[i-1] < num[i]) {
  int j = num.size() - 1;
  while( num[i-1] > num[j] ) {
  j--;
  }
  int temp = num[i-1];
  num[i-1] = num[j];
  num[j] = temp;
  reverse(num.begin()+i, num.end());
  return;
  }
  }
  reverse( num.begin(), num.end() );
 }
 int main(int argc, char**argv)
 {
  int n=3, k=6;
  if ( argc > 2 ) {
  n = atoi(argv[1]);
  k = atoi(argv[2]);
  }
  cout << ""n = "" << n << "", k = "" << k << "" : "" << getPermutation(n, k) << endl;
  return 0;
 }"
338,338,"#include <iostream>
 #include <vector>
 using namespace std;
 vector<int> plusOne(vector<int> &digits) {
  int carry=1;
  vector <int> v;
  while(digits.size()>0){
  int x = digits.back();
  digits.pop_back();
  x = x + carry;
  v.insert(v.begin(), x%10);
  carry = x/10;
  }
  if (carry>0){
  v.insert(v.begin(), carry);
  }
  return v;
 }
 void printVector(vector<int>& v)
 {
  cout << ""{ "";
  for(int i=0; i<v.size(); i++){
  cout << v[i] << "" "";
  }
  cout << ""} "" << endl;
 }
 int main()
 {
  int a[]={9,9,9};
  vector<int> d(&a[0], &a[0]+sizeof(a)/sizeof(int));
  vector<int> v = plusOne(d);
  printVector(v);
  return 0;
 }"
339,339,"#include <stdio.h>
 #include <vector>
 #include <queue>
 using namespace std;
 /**
  * Definition for binary tree with next pointer.
  */
 struct TreeLinkNode {
  int val;
  TreeLinkNode *left, *right, *next;
  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
  TreeLinkNode() : val(0), left(NULL), right(NULL), next(NULL) {}
 };
 void connect(TreeLinkNode *root) {
  if (root==NULL){
  return;
  }
  if (root->left && root->right){
  root->left->next = root->right;
  }
  if (root->next && root->right){
  root->right->next = root->next->left;
  }
  connect(root->left);
  connect(root->right);
 }
 void connect1(TreeLinkNode *root) {
  if (root==NULL){
  return;
  }
  vector<TreeLinkNode*> v; 
  v.push_back(root);
  int i = 0;
  while (i < v.size()){
  if (v[i]->left){
  v.push_back(v[i]->left);
  }
  if (v[i]->right) {
  v.push_back(v[i]->right);
  }
  i++;
  }
  i=1;
  while(i<v.size()){
  for (int j=i-1; j<2*(i-1); j++){
  v[j]->next = v[j+1]; 
  }
  i *= 2; 
  }
 }
 void connect2(TreeLinkNode *root) {
  if (root==NULL){
  return;
  }
  vector<TreeLinkNode*> v;
  v.push_back(root);
  while(v.size()>0){
  if (root->left && root->right && root->left->next == NULL ) {
  root->left->next = root->right;
  if (root->next){
  root->right->next = root->next->left;
  }
  v.push_back(root->right);
  v.push_back(root->left);
  }
  root=v.back();
  v.pop_back();
  }
 }
 void connect3(TreeLinkNode *root) {
  if(root == NULL) return;
  queue<TreeLinkNode*> q;
  TreeLinkNode *prev, *last;
  prev = last = root;
  q.push(root);
  while(!q.empty()) {
  TreeLinkNode* p = q.front();
  q.pop();
  prev->next = p;
  if(p->left ) q.push(p->left);
  if(p->right) q.push(p->right);
  if(p == last) { // meets last of current level
  // now, q contains all nodes of next level
  last = q.back();
  p->next = NULL; // cut down.
  prev = q.front();
  }
  else {
  prev = p;
  }
  }
 }
 // constant space
 // key point: we can use `next` pointer to represent
 // the buffering queue of level order traversal.
 void connect4(TreeLinkNode *root) {
  if(root == NULL) return;
  TreeLinkNode *head, *tail;
  TreeLinkNode *prev, *last;
  head = tail = NULL;
  prev = last = root;
 #define push(p) \
  if(head == NULL) { head = tail = p; } \
  else { tail->next = p; tail = p; }
  push(root);
  while(head != NULL) {
  TreeLinkNode* p = head;
  head = head->next; // pop
  prev->next = p;
  if(p->left ) push(p->left);
  if(p->right) push(p->right);
  if(p == last) {
  last = tail;
  p->next = NULL; // cut down.
  prev = head;
  }
  else {
  prev = p;
  }
  }
 #undef push
 }
 void printTree(TreeLinkNode *root){
  if (root == NULL){
  return;
  }
  printf(""[%d], left[%d], right[%d], next[%d]\n"", 
  root->val, 
  root->left ? root->left->val : -1, 
  root->right ? root->right->val : -1, 
  root->next?root->next->val : -1 ); 
  printTree(root->left);
  printTree(root->right);
 }
 int main()
 {
  const int cnt = 7; 
  TreeLinkNode a[cnt];
  for(int i=0; i<cnt; i++){
  a[i].val = i+1;
  } 
  for(int i=0, pos=0; pos < cnt-1; i++ ){
  a[i].left = &a[++pos];
  a[i].right = &a[++pos];
  }
  connect(&a[0]); 
  printTree(&a[0]);
  return 0;
 }"
340,340,"#include <stdio.h>
 #include <vector>
 #include <queue>
 using namespace std;
 /**
  * Definition for binary tree with next pointer.
  */
 struct TreeLinkNode {
  int val;
  TreeLinkNode *left, *right, *next;
  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
  TreeLinkNode() : val(0), left(NULL), right(NULL), next(NULL) {}
 };
 void connect(TreeLinkNode *root) {
  if (root==NULL) return;
  if (root->left && root->right){
  root->left->next = root->right;
  }
  if (root->next) {
  TreeLinkNode *left=NULL, *right=NULL;
  left = root->right ? root->right: root->left;
  for (TreeLinkNode *p = root->next; p!=NULL; p=p->next) {
  if (p->left){
  right = p->left;
  break;
  }
  if (p->right){
  right = p->right;
  break;
  }
  }
  if (left){
  left->next = right;
  } 
  }
  connect(root->right);
  connect(root->left);
 }
 void connect1(TreeLinkNode *root) {
  if (root==NULL){
  return;
  }
  vector<TreeLinkNode*> v;
  v.push_back(root);
  while(v.size()>0){
  if ( (root->left && root->left->next==NULL) || (root->right && root->right->next==NULL) ) {
  if (root->left && root->right){
  root->left->next = root->right;
  }
  if (root->next){
  TreeLinkNode *left=NULL, *right=NULL;
  left = root->right ? root->right: root->left;
  for (TreeLinkNode *p = root->next; p!=NULL; p=p->next) {
  if (p->left){
  right = p->left;
  break;
  }
  if (p->right){
  right = p->right;
  break;
  }
  }
  if (left){
  left->next = right;
  } 
  }
  if (root->left) {
  v.push_back(root->left);
  }
  if (root->right) {
  v.push_back(root->right);
  }
  }
  root = v.back();
  v.pop_back();
  }
 }
 void connect3(TreeLinkNode *root) {
  if(root == NULL) return;
  queue<TreeLinkNode*> q;
  TreeLinkNode *prev, *last;
  prev = last = root;
  q.push(root);
  while(!q.empty()) {
  TreeLinkNode* p = q.front();
  q.pop();
  prev->next = p;
  if(p->left ) q.push(p->left);
  if(p->right) q.push(p->right);
  if(p == last) { // meets last of current level
  // now, q contains all nodes of next level
  last = q.back();
  p->next = NULL; // cut down.
  prev = q.front();
  }
  else {
  prev = p;
  }
  }
 }
 // constant space
 // key point: we can use `next` pointer to represent
 // the buffering queue of level order traversal.
 void connect4(TreeLinkNode *root) {
  if(root == NULL) return;
  TreeLinkNode *head, *tail;
  TreeLinkNode *prev, *last;
  head = tail = NULL;
  prev = last = root;
 #define push(p) \
  if(head == NULL) { head = tail = p; } \
  else { tail->next = p; tail = p; }
  push(root);
  while(head != NULL) {
  TreeLinkNode* p = head;
  head = head->next; // pop
  prev->next = p;
  if(p->left ) push(p->left);
  if(p->right) push(p->right);
  if(p == last) {
  last = tail;
  p->next = NULL; // cut down.
  prev = head;
  }
  else {
  prev = p;
  }
  }
 #undef push
 }
 void printTree(TreeLinkNode *root){
  if (root == NULL){
  return;
  }
  printf(""[%2d] : left[%d], right[%d], next[%d]\n"",
  root->val,
  root->left ? root->left->val : -1,
  root->right ? root->right->val : -1,
  root->next?root->next->val : -1 );
  printTree(root->left);
  printTree(root->right);
 }
 int main()
 {
  const int cnt = 15; 
  TreeLinkNode a[cnt];
  for(int i=0; i<cnt; i++){
  a[i].val = i+1;
  } 
  for(int i=0, pos=0; pos<cnt-1; i++ ){
  a[i].left = &a[++pos];
  a[i].right = &a[++pos];
  }
  a[5].left = a[5].right = NULL;
  a[3].right = NULL;
  //a[1].right = NULL;
  //a[2].left = NULL;
  //a[3].left = &a[4];
  //a[6].right= &a[5];
  TreeLinkNode b(100), c(200);
  //a[3].left = &b;
  //a[6].right = &c;
  a[9].left = &b;
  connect(&a[0]); 
  printTree(&a[0]);
  return 0;
 }"
341,341,"#include <stdio.h>
 #include <stdlib.h>
 /*
  * Basically, most people think this is very easy as below:
  *
  * double result = 1.0;
  * for (int i=0; i<n; i++){
  * result *=x;
  * }
  * 
  * However, 
  *
  * 1) We need think about the `n` is negtive number.
  *
  * 2) We need more wisely deal with the following cases:
  *
  * pow(1, MAX_INT);
  * pow(-1,BIG_INT);
  * pow(2, BIG_INT);
  *
  * To deal with such kind case, we can use x = x*x to reduce the `n` more quickly
  *
  * so, if `n` is an even number, we can `x = x*x`, and `n = n>>1;`
  * if `n` is an odd number, we can just `result *= x;`
  *
  */
 double pow(double x, int n) {
  bool sign = false;
  unsigned int exp = n;
  if(n<0){
  exp = -n;
  sign = true;
  }
  double result = 1.0;
  while (exp) {
  if (exp & 1){
  result *= x;
  }
  exp >>= 1;
  x *= x;
  }
  return sign ? 1/result : result;
 }
 int main(int argc, char** argv){
  double x=2.0;
  int n = 3;
  if (argc==3){
  x = atof(argv[1]);
  n = atoi(argv[2]);
  }
  printf(""%f\n"", pow(x, n));
  return 0;
 }"
342,342,"class Solution {
 public:
  bool isPowerOfFour(int num) {
  static int mask = 0b01010101010101010101010101010101;
  //edge case
  if (num<=0) return false;
  // there are multiple bits are 1
  if ((num & num-1) != 0) return false;
  // check which one bit is zero, if the place is 1 or 3 or 5 or 7 or 9...,
  // then it is the power of 4
  if ((num & mask) != 0) return true;
  return false;
  }
 };"
343,343,"class Solution {
 public:
  bool isPowerOfThree(int n) {
  return isPowerOfThree03(n); //140ms
  return isPowerOfThree02(n);//130ms
  return isPowerOfThree01(n); //140ms
  return isPowerOfThree_loop(n); //136ms
  return isPowerOfThree_recursive(n); //168ms
  }
  bool isPowerOfThree03(int n) {
  double logRes = log10(n)/log10(3); 
  return (logRes - int(logRes) == 0);
  }
  bool isPowerOfThree02(int n) {
  return n>0 ? (1162261467%n==0) : false;
  }
  void init(unordered_map<int, bool>& power ){
  int p = 1;
  power[1]=true;
  while(1){
  p *= 3;
  power[p] = true;
  if (p > INT_MAX/3) break;
  }
  }
  bool isPowerOfThree01(int n) {
  static unordered_map<int, bool> power; 
  if (power.size()==0) init(power);
  return power.find(n) != power.end();
  }
  bool isPowerOfThree_loop(int n) {
  for(;n>0;n /= 3){
  if (n==1 || n==3) return true;
  if (n%3 != 0) return false;
  }
  return false;
  }
  bool isPowerOfThree_recursive(int n) {
  if ( n == 1 || n == 3) return true;
  if ( n==0 || n%3 != 0 ) return false;
  return isPowerOfThree_recursive(n/3);
  } 
 };"
344,344,"class Solution {
 public:
  // count the number fo bits 1, if it only has one, then return true
  bool isPowerOfTwo01(int n) {
  int cnt = 0; //num of bits 1
  for(; n>0; n>>=1){
  if ( n & 1 ) {
  cnt++;
  if (cnt>1) return false;
  }
  }
  return cnt==1;
  }
  //we notice: 2^n - 1 always be 1111111...
  //so, (2^n) & (2^n-1) always be zero
  bool isPowerOfTwo02(int n) {
  return n<=0 ? false : (n & (n-1)) == 0;
  }
  bool isPowerOfTwo(int n) {
  if (random()%2){
  return isPowerOfTwo02(n);
  }
  return isPowerOfTwo01(n);
  }
 };"
345,345,"class Solution {
 private:
  template<class T>
  void print(T q) {
  cout << ""["";
  while(!q.empty()) {
  auto& p = q.top(); 
  cout << ""["" << p.first << "",""<< p.second << ""]"";
  q.pop();
  }
  cout << ""]"" << endl;
  }
 public:
  vector<int> assignTasks(vector<int>& servers, vector<int>& tasks) {
  typedef pair<int,int> IntPair;
  typedef priority_queue<IntPair, vector<IntPair>, greater<IntPair>> PriorityQueue;
  // asc sorted by {weight, index}
  PriorityQueue idle;
  // asc sorted by {time, index}
  PriorityQueue busy;
  for(int i=0; i<servers.size(); i++){
  idle.push({servers[i], i});
  }
  //print(idle);
  int time = 0;
  vector<int> ans;
  for(int i=0; i<tasks.size(); i++) {
  time = max(i, time);
  //check the tasks finished
  while(true) { 
  while(!busy.empty()){
  auto& t = busy.top().first;
  auto& id = busy.top().second;
  if (t > time) break;
  idle.push({servers[id], id});
  busy.pop();
  }
  if (!idle.empty()) break;
  //set the time to the fisrt finish running task 
  time = busy.top().first;
  }
  //process the current task
  auto& id = idle.top().second;
  ans.push_back(id);
  busy.push({time + tasks[i], id});
  idle.pop();
  }
  return ans;
  }
 };"
346,346,"class Solution {
 public:
  vector<int> productExceptSelf(vector<int>& nums) {
  int len = nums.size();
  vector<int> result(len, 1);
  //from the left to right 
  for (int i=1; i<len; i++) {
  result[i] = result[i-1]*nums[i-1];
  }
  //from the right to left
  int factorial = 1;
  for (int i=len-2; i>=0; i--){
  factorial *= nums[i+1];
  result[i] *= factorial;
  }
  return result;
  }
 };"
347,347,"class Solution {
 private:
  //refer to: https://stackoverflow.com/a/7227057/13139221
  bool inCircle( vector<int>& point, vector<int>& circle ) {
  int x = point[0], y = point[1];
  int xo = circle[0], yo = circle[1], r = circle[2];
  int dx = abs(x-xo);
  if ( dx > r ) return false;
  int dy = abs(y-yo);
  if ( dy > r ) return false;
  if ( dx + dy <= r ) return true;
  return ( dx*dx + dy*dy <= r*r );
  }
 public:
  vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {
  vector<int> result;
  for(auto& c : queries) {
  int cnt = 0;
  for(auto& p : points) {
  if ( inCircle(p, c) ) cnt++;
  }
  result.push_back(cnt);
  }
  return result;
  }
 };"
348,348,"class Solution {
 public:
  vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {
  //sort function
  auto comp = [](const pair<int, int>& p1, const pair<int, int>& p2)
  { return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first; };
  //sort the people with their height with descending order
  // and if the height is same then sort by K with ascending order
  sort(people.begin(), people.end(), comp);
  // For example:
  // Original Queue: [7,0], [4,4], [7,1], [5,0], [6,1], [5,2]
  // Sorted Queue: [7,0], [7,1], [6,1], [5,0], [5,2], [4,4] 
  // Why do we need to sort like this?
  //
  // ** The position of shorter people is ZERO impacted with higher people. **
  // 
  // and, the shortest people has no impacts to all of people. we can simpley insert it to the Kth position
  //
  // So, we sorted the people from highest to the shortest, then when we insert the people to another array,
  //
  // we always can guarantee the people is going to be inserted has nothing to do with the people has been inserted.
  // 
  // Let's continue the about example above
  //
  // [7,0] => [] then [7,0]
  // [7,1] => [7,0] then [7,0], [7,1]
  // [6,1] => [7,0], [7,1] then [7,0], [6,1], [7,1]
  // [5,0] => [7,0], [6,1], [7,1] then [5,0], [7,0], [6,1], [7,1]
  // [5,2] => [5,0], [7,0], [6,1], [7,1] then [5,0], [7,0], [5,2], [6,1], [7,1]
  // [4,4] => [5,0], [7,0], [5,2], [6,1], [7,1] then [5,0], [7,0], [5,2], [6,1], [4,4], [7,1]
  //
  // We alway can see, the people is going to be inserted has NO IMPACT with the current people.
  // 
  // [6,1] => [7,0], [7,1] 
  // 
  // Whatever the people[6,1] placed, it has nothing to do with the people [7,0] [7,1],
  // So, we can just insert the people to the place he like - the `Kth` place. 
  //
  //
  vector<pair<int, int>> res;
  for (auto& p : people) {
  res.insert(res.begin() + p.second, p);
  }
  return res;
  }
 };"
349,349,"class Solution {
 private:
  vector<int> nums; 
 public:
  Solution(vector<int> nums) {
  srand(time(0));
  this->nums = nums;
  }
  int pick(int target) {
 // we just randomly pick a number from the array,
  // if the number is target just return the index.
  // otherwise, keep picking the number randomly.
  while(true) {
  int idx = rand() % nums.size();
  if ( target == nums[idx] ) {
  return idx;
  }
  }
  }
 };
 /**
  * Your Solution object will be instantiated and called as such:
  * Solution obj = new Solution(nums);
  * int param_1 = obj.pick(target);
  */"
350,350,"class Solution {
 public:
  //attributes
  vector<vector<int>> rects_b; //copy of the given 'rects' vector
  vector<int> points_until; //value of element 'e' = num of points in all rects before 'e', including it
  Solution(vector<vector<int>>& rects) {
  for (auto &e : rects) {
  int before = (points_until.size() == 0) ? 0 : points_until.back(); //points before 'e'
  points_until.push_back((e[2] - e[0] + 1) * (e[3] - e[1] + 1) + before);
  rects_b = rects;
  }
  }
  vector<int> pick() {
  int ind = rand() % points_until.back(); //randomly choose one of the points counted
  int rect = upper_bound(points_until.begin(), points_until.end(), ind) - points_until.begin();
  ind -= (rect == 0) ? 0 : points_until[rect - 1];
  int row = rects_b[rect][3] - rects_b[rect][1] + 1;
  return {ind/row + rects_b[rect][0], ind%row + rects_b[rect][1]};
  }
 };"
351,351,"class NumArray {
 /* 
  * Solution
  * =========
  *
  * The sum of all the elements starting from position 0 to position i is stored in
  * sums[i]. This way we can reconstruct the sum from position i to position j by
  * subtracting sums[i - 1] from sums[j], leaving us with the sum of the desired elements.
  *
  * Note: we can add a dummy sum at then beginning to simplify the code
  * 
  */
 private:
  int size;
  vector <long long> sums;
 public:
  NumArray(vector<int> &nums): size(nums.size()), sums(size+1, 0) {
  for(int i=0; i<size; i++) {
  sums[i+1] = sums[i] + nums[i];
  } 
  }
  int sumRange(int i, int j) {
  return sums[j+1] - sums[i];
  }
 };
 // Your NumArray object will be instantiated and called as such:
 // NumArray numArray(nums);
 // numArray.sumRange(0, 1);
 // numArray.sumRange(1, 2);"
352,352,"/*
  * 
  * Construct a 2D array `sums[row+1][col+1]`
  * 
  * (**notice**: we add additional blank row `sums[0][col+1]={0}` and blank column `sums[row+1][0]={0}` 
  * to remove the edge case checking), so, we can have the following definition 
  * 
  * `sums[i+1][j+1]` represents the sum of area from `matrix[0][0]` to `matrix[i][j]`
  * 
  * To calculate sums, the ideas as below
  * 
  * +-----+-+-------+ +--------+-----+ +-----+---------+ +-----+--------+
  * | | | | | | | | | | | | |
  * | | | | | | | | | | | | |
  * +-----+-+ | +--------+ | | | | +-----+ |
  * | | | | = | | + | | | - | |
  * +-----+-+ | | | +-----+ | | |
  * | | | | | | | |
  * | | | | | | | |
  * +---------------+ +--------------+ +---------------+ +--------------+
  * 
  * sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + 
  * 
  * matrix[i-1][j-1]
  * 
  * So, we use the same idea to find the specific area's sum.
  * 
  * 
  * 
  * +---------------+ +--------------+ +---------------+ +--------------+ +--------------+
  * | | | | | | | | | | | | | |
  * | (r1,c1) | | | | | | | | | | | | |
  * | +------+ | | | | | | | +---------+ | +---+ |
  * | | | | = | | | - | | | - | (r1,c2) | + | (r1,c1) |
  * | | | | | | | | | | | | | |
  * | +------+ | +---------+ | +---+ | | | | |
  * | (r2,c2)| | (r2,c2)| | (r2,c1) | | | | |
  * +---------------+ +--------------+ +---------------+ +--------------+ +--------------+
  * 
  * 
  */
 class NumMatrix {
 private:
  int row, col;
  vector<vector<int>> sums;
 public:
  NumMatrix(vector<vector<int>> &matrix) {
  row = matrix.size();
  col = row>0 ? matrix[0].size() : 0;
  sums = vector<vector<int>>(row+1, vector<int>(col+1, 0));
  for(int i=1; i<=row; i++) {
  for(int j=1; j<=col; j++) {
  sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + matrix[i-1][j-1];
  }
  }
  }
  int sumRegion(int row1, int col1, int row2, int col2) {
  return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1];
  }
 };
 // Your NumMatrix object will be instantiated and called as such:
 // NumMatrix numMatrix(matrix);
 // numMatrix.sumRegion(0, 1, 2, 3);
 // numMatrix.sumRegion(1, 2, 3, 4);"
353,353,"class Solution {
 public:
  bool canConstruct(string ransomNote, string magazine) {
  unordered_map<char, int> m;
  for(int i=0; i<magazine.size(); i++) {
  m[magazine[i]]++;
  }
  for (int i=0; i<ransomNote.size(); i++) {
  char c = ransomNote[i];
  if (m[c] <=0 ) return false;
  m[c]--;
  }
  return true;
  }
 };"
354,354,"// Forward declaration of the read4 API.
 int read4(char *buf);
 class Solution {
  public:
  /**
  * @param buf Destination buffer
  * @param n Maximum number of characters to read
  * @return The number of characters read
  */
  int read(char *buf, int n) {
  srand(time(0));
  if (rand()%2){
  return read1(buf, n);
  }
  return read2(buf, n);
  }
  //read the data in-place. potential out-of-boundary issue
  int read1(char *buf, int n) {
  int len = 0;
  int size = 0;
  // `buf` could be accessed out-of-boundary 
  while(len <=n && (size = read4(buf))>0){
  size = len + size > n ? n - len : size;
  len += size;
  buf += size;
  }
  return len;
  }
  //using a temp-buffer to avoid peotential out-of-boundary issue
  int read2(char *buf, int n) {
  char _buf[4]; // the buffer for read4()
  int _n = 0; // the return for read4()
  int len = 0; // total buffer read from read4()
  int size = 0; // how many bytes need be copied from `_buf` to `buf`
  while((_n = read4(_buf)) > 0){
  //check the space of `buf` whether full or not
  size = len + _n > n ? n-len : _n;
  strncpy(buf+len, _buf, size);
  len += size;
  //buffer is full
  if (len>=n){
  break;
  }
  }
  return len;
  }
 };"
355,355,"/*
  This problem's description really confuse me.
  for examples:
  1) [[""JFK"", ""PEK""], [""JFK"", ""SHA""], [""SHA"", ""JFK""]], which has two itineraries: 
  a) JFK -> PEK, 
  b) JFK -> SHA -> JFK -> PEK
  The a) is smaller than b), because PEK < SHA, however the b) is correct answer.
  So, it means we need use all of tickets.
  2) [[""JFK"", ""PEK""], [""JFK"", ""SHA""]], which also has two itineraries:
  a) JFK -> PEK
  b) JFK -> SHA
  for my understanding, the JFK -> SHA is the correct one, 
  however, the correct answer is JFK -> SHA -> PEK.
  I don't understand, why the correct answer is not JFK -> PEK -> SHA
  That really does not make sense to me.
  All right, we need assume all of the tickets can be connected in one itinerary.
  Then, it's easy to have a DFS algorithm.
 */
 class Solution {
 public:
  //DFS
  void travel(string& start, unordered_map<string, multiset<string>>& map, vector<string>& result) {
  while (map[start].size() > 0 ) {
  string next = *(map[start].begin());
  map[start].erase(map[start].begin());
  travel(next, map, result);
  }
  result.insert(result.begin(), start);
  }
  vector<string> findItinerary(vector<pair<string, string>> tickets) {
  unordered_map<string, multiset<string>> map;
  for(auto t : tickets) {
  map[t.first].insert(t.second);
  }
  vector<string> result;
  string start = ""JFK"";
  travel(start, map, result);
  return result;
  }
 };"
356,356,"/* Definition for a binary tree node.
  struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
 */ 
 class Solution {
 public:
  TreeNode* recoverFromPreorder(string S) {
  vector<int>values,depth;
  int cur_val = 0 , cur_depth = 0;
  bool dash = false;
  for(char s : S){
  if(s == '-'){
  if(!dash){
  values.push_back(cur_val);
  depth.push_back(cur_depth);
  cur_depth = 0;
  cur_val = 0;
  }
  dash = true;
  cur_depth++;
  }
  else{
  dash = false;
  cur_val *= 10;
  cur_val += s-'0';
  }
  }
  values.push_back(cur_val);
  depth.push_back(cur_depth);
  unordered_map<TreeNode*,int>depths;
  int ptr = 1;
  TreeNode *root = new TreeNode(values[0]);
  depths[root] = 0;
  stack<TreeNode*>st;
  st.push(root);
  while(ptr < (int)values.size()){
  TreeNode *cur = st.top();
  if(depth[ptr] == depths[cur]+1 && (cur->left == NULL || cur->right == NULL)){
  TreeNode *t = new TreeNode(values[ptr++]);
  depths[t] = depths[cur]+1;
  if(cur->left == NULL){
  cur->left = t;
  }
  else{
  cur->right = t;
  }
  st.push(t);
  }
  else{
  st.pop();
  }
  }
  return root;
  }
 };"
357,357,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 //
 // We can convert the BST to a sorted array, then we can find the two nodes which missed the order.
 //
 // To cover the BST to sorted array, we needn't use an extra array, we just traverse the tree in order.
 // 
 // 8
 // _______/ \_______
 // / \
 // 4 12
 // __/ \__ __/ \__
 // / \ / \
 // 2 6 10 14
 // / \ / \ / \ / \
 // 1 3 5 7 9 11 13 15
 // 
 // 
 class Solution {
 public:
  void recoverTreeHelper(TreeNode *root) {
  if (root == NULL) return;
  recoverTreeHelper(root->left);
  if (prev) {
  if (prev->val > root->val){
  if (n1==NULL) {
  n1 = prev;
  }
  n2 = root;
  }
  }
  prev = root;
  recoverTreeHelper(root->right);
  }
  void recoverTree(TreeNode *root) {
  n1 = n2 = prev = NULL;
  recoverTreeHelper(root);
  if (n1 && n2) {
  swap(n1->val, n2->val);
  }
  }
 private:
  TreeNode *n1, *n2, *prev;
 };"
358,358,"#include <iostream>
 using namespace std;
 namespace leetcode 
 {
  class Point {
  public:
  Point(int _x, int _y):x(_x),y(_y) {}
  int x, y;
  };
  class Rectangle {
  public:
  Rectangle(int a, int b, int c, int d):topLeft(a,d), bottomRight(c,b) { }
  int Area(){
  return (bottomRight.x - topLeft.x)*(topLeft.y - bottomRight.y); 
  }
  int InclusiveArea (Rectangle &r){
  // I include it
  if (r.topLeft.x >= topLeft.x && r.bottomRight.x <= bottomRight.x &&
  r.topLeft.y <= topLeft.y && r.bottomRight.y >= bottomRight.y ) {
  return this->Area();
  }
  // it includes me
  if (r.topLeft.x <= topLeft.x && r.bottomRight.x >= bottomRight.x &&
  r.topLeft.y >= topLeft.y && r.bottomRight.y <= bottomRight.y ) {
  return r.Area();
  }
  // 0 - no inclusive
  return 0;
  }
  int OverlappedArea(Rectangle &r) {
  int overlap_x = max(0, min(r.bottomRight.x, bottomRight.x) - max(r.topLeft.x, topLeft.x));
  int overlap_y = max(0, min(r.topLeft.y, topLeft.y) - max(r.bottomRight.y, bottomRight.y));
  return overlap_x * overlap_y;
  }
  Point topLeft;
  Point bottomRight;
  };
 };
 int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
  using namespace leetcode;
  Rectangle r1(A,B,C,D);
  Rectangle r2(E,F,G,H);
  int area = r1.InclusiveArea(r2);
  if (area > 0) return area;
  return r1.Area() + r2.Area() - r1.OverlappedArea(r2);
 }
 int main() 
 {
  //16
  cout << ""16 : "" << computeArea(-1, -1, 1, 1, -2, -2, 2, 2) << endl;
  //16
  cout << ""16 : "" << computeArea(-2, -2, 2, 2, -1, -1, 1, 1) << endl;
  //17
  cout << ""17 : "" << computeArea(-2, -2, 2, 2, -4, 3, -3, 4) << endl;
  //45
  cout << ""45 : "" << computeArea(-3, -0, 3, 4, 0, -1, 9, 2) << endl;
  //24
  cout << ""24 : "" << computeArea(-2, -2, 2, 2, -3, -3, 3, -1) << endl;
  return 0;
 }"
359,359,"class Solution {
 public:
  string reformatNumber(string number) {
  string result;
  for(int i=0, cnt=0; i<number.size(); i++){
  if(number[i] == ' ' or number[i] == '-') continue;
  result += number[i] ;
  cnt++;
  if (cnt % 3 == 0) result += '-';
  }
  int end = result.size()-1;
  if (result[end] == '-') result.erase(end, 1);
  if (result[end-1] == '-') swap(result[end-2] , result[end-1]);
  return result;
  }
 };"
360,360,"#include <stdio.h>
 #include <string.h>
 #include <iostream>
 using namespace std;
 bool isMatch(const char *s, const char *p) {
  if (*p=='\0') {
  return *s == '\0';
  }
  //p's length 1 is special case 
  if (*(p+1) == '\0' || *(p+1) !='*' ) {
  if (*s=='\0' || ( *p !='.' && *s != *p )) {
  return false;
  }
  return isMatch(s+1, p+1);
  }
  int len = strlen(s);
  int i = -1;
  while (i < len && (i <0 || *p=='.' || *p==*(s+i)) ){
  if (isMatch(s+i+1, p+2)) {
  return true;
  }
  i++;
  }
  return false;
 }
 int main(int argc, char** argv)
 {
  const char* s = ""aaa"";
  const char* p = ""a.*"";
  if (argc>2) {
  s = argv[1];
  p = argv[2];
  }
  cout << s << "", "" << p << "" : "" << isMatch(s,p) << endl;
 }"
361,361,"class Solution {
 public:
  string removeDuplicateLetters(string s) {
  const int ASCII_LEN = 256;
  int counter[ASCII_LEN] = {0};
  bool visited[ASCII_LEN] = {false};
  for (char ch : s) {
  counter[ch]++;
  }
  string result;
  for (char ch : s) {
  counter[ch]--;
  // if the current `ch` has already put into the result.
  if (visited[ch]) continue;
  // if the current `ch` is smaller than the last one char in result.
  // and we still have duplicated last-one char behind, so we can remove the current one.
  while ( !result.empty() && ch < result.back() && counter[result.back()] ) {
  visited[result.back()] = false;
  result.pop_back();
  }
  result.push_back(ch);
  visited[ch] = true;
  }
  return result;
  }
 };"
362,362,"class Solution {
 public:
  int removeDuplicates(int A[], int n) {
  if (n<=1) return n;
  int pos=0;
  for(int i=0; i<n-1; i++){
  if (A[i]!=A[i+1]){
  A[++pos] = A[i+1];
  }
  }
  return pos+1;
  }
 };"
363,363,"#include <stdio.h>
 int removeDuplicates(int A[], int n) {
  if (n<=2) return n;
  int pos=0;
  int cnt=1;
  for (int i=1; i<n; i++){
  if (A[i] == A[pos]){
  cnt++;
  if (cnt==2){
  A[++pos] = A[i];
  }
  }else{
  cnt=1;
  A[++pos] = A[i];
  }
  } 
  return pos+1;
 }
 void printfArray(int A[], int n) {
  printf(""{ "");
  for (int i=0; i<n; i++){
  printf(""%d "", A[i]);
  }
  printf(""}\n"");
 }
 void testSuite(int a[], int n){
  printfArray(a, n);
  n = removeDuplicates(a, n);
  printfArray(a, n);
  printf(""------------------\n"");
 }
 #define TEST(a) testSuite(a, sizeof(a)/sizeof(int))
 int main()
 {
  int a0[] = {1, 2, 3, 4, 5};
  TEST(a0);
  int a1[] = {1, 1, 1};
  TEST(a1);
  int a2[] = {1, 2, 2};
  TEST(a2);
  int a3[] = {1, 1, 2};
  TEST(a3);
  int a4[] = {1, 1, 1, 1};
  TEST(a4);
  int a5[] = {1, 1, 1, 2};
  TEST(a5);
  int a6[] = {1, 2, 2, 2};
  TEST(a6);
  int a7[] = {1, 2, 2, 2, 3 };
  TEST(a7);
  int a8[] = {1, 2, 2, 2, 3, 3};
  TEST(a8);
  int a9[] = {1,1,1,2,2,3};
  TEST(a9);
  int a10[] = {1,1,1,2,2,2};
  TEST(a10);
  int a11[] = {1,1,1,1,3,3};
  TEST(a11);
  return 0;
 }"
364,364,"#include <stdio.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *deleteDuplicates(ListNode *head) {
  for(ListNode *p=head; p && p->next; ){
  if (p->val == p->next->val){
  p->next = p->next->next;
  continue;
  }
  p=p->next;
  }
  return head;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main()
 {
  int a[]={1,1,2,3,3};
  int b[]={1,1,1};
  printList(deleteDuplicates(createList(a, sizeof(a)/sizeof(int))));
  printList(deleteDuplicates(createList(b, sizeof(b)/sizeof(int))));
  return 0;
 }"
365,365,"#include <stdio.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *deleteDuplicates(ListNode *head) {
  ListNode fake(-1);
  fake.next = head;
  head = &fake;
  ListNode *tail=head;
  bool dup = false;
  for(ListNode *p=head->next; p && p->next; p=p->next){
  if (dup==false && p->val == p->next->val){
  dup = true; 
  continue;
  }
  if (dup==true && p->val != p->next->val){
  dup = false;
  tail->next = p->next;
  continue;
  }
  if (dup==false){
  tail = p;
  }
  }
  if (dup==true){
  tail->next = NULL;
  }
  return head->next;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main()
 {
  int a[]={1,1,2,3,3};
  int b[]={1,1,1};
  int c[]={1,2,3};
  int d[]={3};
  printList(deleteDuplicates(createList(a, sizeof(a)/sizeof(int))));
  printList(deleteDuplicates(createList(b, sizeof(b)/sizeof(int))));
  printList(deleteDuplicates(createList(c, sizeof(c)/sizeof(int))));
  printList(deleteDuplicates(createList(d, sizeof(d)/sizeof(int))));
  return 0;
 }"
366,366,"class Solution {
 public:
  int removeElement(vector<int>& nums, int val) {
  int pos = 0;
  for (int i=0; i<nums.size(); i++){
  if (nums[i] != val){
  nums[pos++] = nums[i]; 
  }
  }
  return pos;
  }
  int removeElement(int A[], int n, int elem) {
  int tail = n-1;
  int i = 0;
  while ( i<=tail ){
  if (A[i]==elem){
  A[i] = A[tail--];
  continue;
  }
  i++;
  }
  return tail+1;
  }
 };"
367,367,"#include <iostream>
 #include <vector>
 #include <string>
 #include <unordered_set>
 using namespace std;
 //DFS 
 void removeInvalidParenthesesHelper(string& s, int index, int pair,
  int remove_left, int remove_right, 
  string solution, unordered_set<string>& result) {
  char ch = s[index];
  //recusive ending 
  if ( ch == '\0' ) {
  if (pair==0 && remove_left==0 && remove_right==0 ) {
  result.insert(solution);
  }
  return;
  }
  //other char, move to next one
  if ( ch != '(' && ch != ')' ) {
  removeInvalidParenthesesHelper(s, index+1, pair, remove_left, remove_right, solution+ch, result);
  return;
  }
  //if we meet left one, and we need remove left one, 
  //then we have two choices : remove it, OR keep it.
  if ( ch == '(' ) {
  //revmoe it
  if (remove_left > 0 ) { 
  removeInvalidParenthesesHelper(s, index+1, pair, remove_left-1, remove_right, solution, result);
  }
  //keep it
  removeInvalidParenthesesHelper(s, index+1, pair+1, remove_left, remove_right, solution+ch, result);
  }
  //if we meet right one, and we need to remove right one,
  //then we have two choices as well: remove it, or keep it if there are some left already.
  if ( ch == ')' ) {
  if (remove_right > 0 ) {
  removeInvalidParenthesesHelper(s, index+1, pair, remove_left, remove_right-1, solution, result);
  }
  if (pair > 0){
  removeInvalidParenthesesHelper(s, index+1, pair-1, remove_left, remove_right, solution+ch, result);
  }
  }
 }
 vector<string> removeInvalidParentheses(string s) {
  //Calculating how many left/right parentheses need be removed!
  int remove_left = 0, remove_right = 0;
  for(auto c : s) {
  if ( c == '(' ) {
  remove_left++;
  }else if ( c == ')' ){
  if (remove_left > 0) {
  remove_left--; // if we matched
  }else{
  remove_right++;
  }
  }
  }
  unordered_set<string> result;
  removeInvalidParenthesesHelper(s, 0, 0, remove_left, remove_right, """", result);
  return vector<string>( result.begin(), result.end() );
 }
 void printVector(vector<string> result) {
  for( int i=0; i<result.size(); i++) {
  cout << i << "") "" << result[i] << endl;
  }
 }
 int main(int argc, char** argv) {
  string s = ""()())()"";
  if (argc>1) {
  s = argv[1];
  }
  cout << s << endl;
  printVector( removeInvalidParentheses(s) );
  return 0;
 }"
368,368,"class Solution {
 public:
  string removeKdigits_pick(string& num, int k) {
  int len = num.size();
  string result;
  int idx = 0;
  for (int i=0; i < len - k; i++) {
  int min_idx = idx;
  for (int j=min_idx; j<=i+k; j++) {
  if (num[min_idx] > num[j]) min_idx = j;
  }
  //don't put zero at the beginning
  if ( !(result.empty() && num[min_idx]=='0') ){
  result.push_back(num[min_idx]);
  }
  //select the number started from next one, to make the order correctness.
  idx = min_idx + 1;
  }
  if (result.empty()) result = ""0"";
  return result;
  }
  string removeKdigits_remove(string& num, int k) {
  if ( num.size() <= k ) return ""0"";
  int left_len = num.size() - k;
  int idx = 0;
  for (int i=0; i<k ;i++){
  int len = num.size();
  for (int j=0; j<num.size()-1; j++) {
  //if the current is bigger than next one, then revmoe the current one.
  //In other word, we always pick the smaller one number.
  if ( num[j] > num[j+1] ) {
  num.erase(j, 1);
  idx = j;
  break;
  }
  }
  }
  //remove all of ZEROs at the beginning.
  for (int i=0; i<= num.size(); i++) {
  if (num[i] != '0' || i == num.size()) {
  num.erase(0, i);
  break;
  }
  }
  // if the digits in the array are sorted, 
  // then, we need remove the digits at the ends.
  if (num.size() > left_len ) {
  num.erase(num.begin() + left_len, num.end());
  }
  if (num.empty()) num = ""0"";
  return num;
  }
  string removeKdigits(string num, int k) {
  srand(time(0));
  if (rand() % 2 ) {
  return removeKdigits_pick(num, k);
  } else {
  return removeKdigits_remove(num, k);
  }
  }
 };"
369,369,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode* removeElements(ListNode* head, int val) {
  static ListNode dummy(-1);
  dummy.next = head;
  ListNode *p = &dummy;
  while( p->next) {
  if (p->next->val == val) {
  p->next = p->next->next;
  }else{
  p = p->next;
  }
  }
  return dummy.next;
  }
 };"
370,370,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode *removeNthFromEnd(ListNode *head, int n) {
  if (head==NULL || n<=0){
  return NULL;
  }
  ListNode fakeHead(0);
  fakeHead.next=head;
  head=&fakeHead;
  ListNode *p1, *p2;
  p1=p2=head;
  for(int i=0; i<n; i++){
  if (p2==NULL) return NULL;
  p2=p2->next;
  }
  while (p2->next!=NULL){
  p2=p2->next;
  p1=p1->next;
  }
  p1->next = p1->next->next;
  return head->next;
  }
 };"
371,371,"#include <stdio.h>
 #include <stdlib.h>
 /**
  * Definition for singly-linked list.
  */
 class ListNode {
 public:
  int val;
  ListNode *next;
  ListNode():val(0), next(NULL) {}
  ListNode(int x) : val(x), next(NULL) {}
 };
 class Solution {
 public:
  void reorderList(ListNode *head) {
  ListNode *pMid = findMidPos(head);
  pMid = reverseList(pMid);
  head = Merge(head, pMid);
  }
 private:
  ListNode* findMidPos(ListNode *head){
  ListNode *p1, *p2, *p=NULL;
  p1 = p2 = head;
  while(p1!=NULL && p2!=NULL && p2->next!=NULL){
  p = p1;
  p1 = p1->next;
  p2 = p2->next->next;
  }
  if(p!=NULL){
  p->next = NULL;
  }
  return p1;
  }
  ListNode* reverseList(ListNode *head){
  ListNode* h = NULL;
  ListNode *p;
  while (head!=NULL){
  p = head;
  head = head->next;
  p->next = h;
  h = p;
  }
  return h;
  }
  ListNode* Merge(ListNode *h1, ListNode* h2) {
  ListNode *p1=h1, *p2=h2, *p1nxt, *p2nxt;
  while(p1!=NULL && p2!=NULL){
  p1nxt = p1->next;
  p2nxt = p2->next;
  p1->next = p2;
  p2->next = p1nxt;
  if (p1nxt==NULL){
  p2->next = p2nxt;
  break;
  }
  p1=p1nxt;
  p2=p2nxt;
  }
  }
 };
 void printList(ListNode *h){
  while(h!=NULL){
  printf(""%d->"", h->val);
  h = h->next;
  }
  printf(""nil\n"");
 }
 int main(int argc, char** argv)
 {
  int size = atoi(argv[1]);
  ListNode* n = new ListNode[size] ;
  for(int i=0; i<size; i++){
  n[i].val = i;
  if( i+1 < size) {
  n[i].next = &n[i+1];
  }
  }
  Solution s;
  s.reorderList(&n[0]);
  printList(&n[0]);
  return 0;
 }"
372,372,"#include <stdlib.h>
 #include <iostream>
 #include <string>
 #include <vector>
 #include <functional>
 #include <unordered_map>
 using namespace std;
 const int MAX_LEN = 10;
 int ACGT2Int(char ch){
  switch(ch){
  case 'A': return 0;
  case 'C': return 1;
  case 'G': return 2;
  case 'T': return 3;
  }
  return -1;
 }
 int DNASeqs2Int(string &s, int begin){
  int result=0;
  for(int i=0; i<MAX_LEN; i++){
  result = result*4 + ACGT2Int(s[i+begin]);
  }
  return result;
 }
 vector<string> findRepeatedDnaSequences_01(string s) {
  unordered_map<int, int> stat;
  vector<string> result;
  for( int i=0; i+MAX_LEN<=s.size(); i++ ){
  int hash_code = DNASeqs2Int(s, i);
  stat[hash_code]++;
  if (stat[hash_code]==2){
  result.push_back(s.substr(i, MAX_LEN));
  }
  }
  return result; 
 }
 vector<string> findRepeatedDnaSequences_02(string s) {
  unordered_map<size_t, int> stat;
  hash<string> hash_func;
  vector<string> result;
  for( int i=0; i+MAX_LEN<=s.size(); i++ ){
  string word = s.substr(i, MAX_LEN);
  size_t hash_code = hash_func(word);
  stat[hash_code]++;
  if (stat[hash_code]==2){
  result.push_back(word);
  }
  }
  return result;
 }
 vector<string> findRepeatedDnaSequences(string s) {
  srand(time(0));
  if (random()%2){
  return findRepeatedDnaSequences_01(s);
  }
  return findRepeatedDnaSequences_02(s);
 }
 void printVector( vector<string> v ) {
  cout << ""[ "" ;
  for(int i=0; i<v.size(); i++ ){
  cout << v[i] << (i<v.size()-1 ? "", "" : """");
  }
  cout << "" ]"" << endl;
 }
 int main(int argc, char** argv)
 {
  string s = ""GAGAGAGAGAGAG"" ;
  if (argc > 1){
  s = argv[1];
  }
  printVector(findRepeatedDnaSequences(s));
 }"
373,373,"class Solution {
 public:
  string replaceDigits(string s) {
  for(int i=0; i<s.size(); i+=2) {
  s[i+1] = s[i] + s[i+1] - '0';
  }
  return s;
  }
 };"
374,374,"#include <stdlib.h>
 #include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 void restoreIpAddressesHelper(string& s, int start, int partNum, string ip, vector<string>& result);
 vector<string> restoreIpAddresses(string s) {
  vector<string> result;
  string ip;
  restoreIpAddressesHelper(s, 0, 0, ip, result);
  return result;
 }
 void restoreIpAddressesHelper(string& s, int start, int partNum, string ip, vector<string>& result) {
  int len = s.size();
  if ( len - start < 4-partNum || len - start > (4-partNum)*3 ) {
  return;
  }
  if (partNum == 4 && start == len){
  ip.erase(ip.end()-1, ip.end());
  result.push_back(ip);
  return;
  }
  int num = 0;
  for (int i=start; i<start+3; i++){
  num = num*10 + s[i]-'0';
  if (num<256){
  ip+=s[i];
  restoreIpAddressesHelper(s, i+1, partNum+1, ip+'.', result);
  } 
  //0.0.0.0 valid, but 0.1.010.01 is not
  if (num == 0) {
  break;
  }
  }
 }
 int main(int argc, char**argv)
 {
  string s = ""25525511135"";
  if (argc>1){
  s = argv[1];
  }
  vector<string> result = restoreIpAddresses(s);
  cout << s << endl;
  for(int i=0; i<result.size(); i++){
  cout << '\t' << result[i] << endl;
  }
  return 0;
 }"
375,375,"class Solution {
 public:
  vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
  // only two numbers have one neighbour
  // start from one of them to travel all number.
  unordered_map<int, vector<int>> dict;
  for(auto& pair : adjacentPairs) {
  dict[pair[0]].push_back(pair[1]);
  dict[pair[1]].push_back(pair[0]);
  }
  int end[2]; int i=0;
  for (auto& [key, pair] : dict) {
  if(pair.size()==1) end[i++] = key;
  if (i>1) break;
  }
  //cout << ""start="" << end[0] <<"", end="" << end[1] << endl;
  vector<int> result(1, end[0]);
  int start = end[0];
  int prev = -1;
  while ( start != end[1] ) {
  auto& v = dict[start];
  for(int i= 0; i< v.size(); i++) {
  if (v[i] == prev) continue;
  result.push_back(v[i]);
  prev = start;
  start = v[i];
  break;
  }
  }
  return result;
  }
 };"
376,376,"class Solution {
 public:
  uint32_t reverseBits(uint32_t n) {
  uint32_t ret=0;
  for(int i=0; i<32; i++) {
  ret = (ret*2) + (n & 0x1);
  n /=2 ;
  }
  return ret;
  }
 };"
377,377,"#include <stdio.h>
 #include <stdlib.h>
 //Why need the INT_MIN be defined like that?
 //Please take a look: 
 // http://stackoverflow.com/questions/14695118/2147483648-0-returns-true-in-c
 #define INT_MAX 2147483647
 #define INT_MIN (-INT_MAX - 1)
 int reverse(int x) {
  int y=0;
  int n;
  while( x != 0){
  n = x%10;
  //Checking the over/underflow.
  //Actually, it should be y>(INT_MAX-n)/10, but n/10 is 0, so omit it.
  if (y > INT_MAX/10 || y < INT_MIN/10){
  return 0;
  }
  y = y*10 + n;
  x /= 10;
  }
  return y;
 }
 #define TEST(n, e) printf(""%12d => %-12d %s!\n"", n, reverse(n), e == reverse(n)?""passed"":""failed"")
 int main(int argc, char**argv)
 {
  //basic cases
  TEST( 123, 321);
  TEST( -123, -321);
  TEST( -100, -1);
  TEST( 1002, 2001);
  //big integer
  TEST( 1463847412, 2147483641);
  TEST(-2147447412, -2147447412);
  TEST( 2147447412, 2147447412);
  //overflow
  TEST( 1000000003, 0);
  TEST( 2147483647, 0);
  TEST(-2147483648, 0);
  //customized cases
  if (argc<2){
  return 0;
  }
  printf(""\n"");
  for (int i=1; i<argc; i++) {
  int n = atoi(argv[i]); 
  printf(""%12d => %-12d %s!\n"", n, reverse(n), reverse(reverse(n))==n ? ""passed"":""failed"");
  }
  return 0;
 }"
378,378,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode* reverseList_iteratively(ListNode* head) {
  ListNode *h=NULL, *p=NULL;
  while (head){
  p = head->next;
  head->next = h;
  h = head;
  head = p;
  }
  return h;
  }
  ListNode* reverseList_recursively(ListNode* head) {
  if (head==NULL || head->next==NULL) return head;
  ListNode *h = reverseList_recursively(head->next);
  head->next->next = head;
  head->next = NULL;
  return h;
  }
  ListNode* reverseList(ListNode* head) {
  return reverseList_iteratively(head);
  return reverseList_recursively(head);
  }
 };"
379,379,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *reverseBetween(ListNode *head, int m, int n) {
  if (head==NULL || m>=n) return head;
  ListNode fake(0);
  fake.next = head;
  ListNode *pBegin=&fake, *pEnd=&fake;
  int distance = n - m ;
  while(pEnd && distance>0){
  pEnd = pEnd->next;
  distance--;
  } 
  while(pBegin && pEnd && m-1>0) {
  pBegin = pBegin->next;
  pEnd = pEnd->next;
  m--;
  }
  if (pBegin==NULL || pEnd==NULL || pEnd->next == NULL){
  return head;
  }
  ListNode *p = pBegin->next;
  ListNode *q = pEnd->next->next;
  ListNode *pHead = q;
  while(p != q){
  ListNode* node = p->next;
  p->next = pHead;
  pHead = p;
  p = node;
  }
  pBegin->next = pHead;
  return fake.next;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int *a, int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 ListNode* createList(int len) {
  int *a = new int[len];
  for(int i=0; i<len; i++){
  a[i] = i+1;
  }
  ListNode* h = createList(a, len);
  delete[] a;
  return h;
 }
 int main(int argc, char** argv)
 {
  int l=5;
  int m=2, n=4;
  if (argc>1){
  l = atoi(argv[1]);
  }
  if (argc>2) {
  m = atoi(argv[2]);
  }
  if (argc>3) {
  n = atoi(argv[3]);
  }
  ListNode* h = createList(l);
  printList( h );
  printList( reverseBetween(h , m, n) );
 }"
380,380,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 using namespace std;
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *reverseList(ListNode *&head, int k);
 ListNode *reverseKGroup(ListNode *head, int k) {
  if (k<=0) return head;
  ListNode fake(0);
  fake.next = head;
  ListNode* p = &fake;
  while(p){
  p->next = reverseList(p->next, k);
  for(int i=0; p && i<k; i++){
  p = p->next;
  }
  }
  return fake.next;
 }
 ListNode *reverseList(ListNode *&head, int k){
  ListNode* pEnd=head;
  while (pEnd && k>0){
  pEnd = pEnd->next;
  k--;
  }
  if (k>0) return head;
  ListNode *pHead=pEnd, *p=head;
  while(p != pEnd){
  ListNode *q = p->next;
  p->next = pHead;
  pHead = p;
  p = q;
  }
  return pHead;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main(int argc, char** argv)
 {
  int a[] = {1,2,3,4,5,6,7,8,9,10};
  ListNode* pList = createList(a, sizeof(a)/sizeof(int));
  int k =2;
  if (argc>1){
  k = atoi(argv[1]);
  }
  pList = reverseKGroup(pList, k);
  printList(pList);
  return 0;
 }"
381,381,"class Solution {
 public:
  string reverseString(string s) {
  int len = s.size();
  for (int i=0; i<len/2; i++) {
  char ch = s[i];
  s[i] = s[len-i-1];
  s[len-i-1] = ch;
  } 
  return s;
  }
 };"
382,382,"//Author: Calinescu Valentin
 class Solution {
 public:
  string reverseVowels(string s) {
  list <char> vowels;
  set <char> vows;
  vows.insert('a');
  vows.insert('A');
  vows.insert('e');
  vows.insert('E');
  vows.insert('i');
  vows.insert('I');
  vows.insert('o');
  vows.insert('O');
  vows.insert('u');
  vows.insert('U');
  string result;
  for(int i = 0; i < s.size(); i++)
  {
  if(vows.find(s[i]) != vows.end())
  vowels.push_back(s[i]);
  }
  for(int i = 0; i < s.size(); i++)
  {
  if(vows.find(s[i]) != vows.end())
  {
  result.push_back(vowels.back());
  vowels.pop_back();
  }
  else
  result.push_back(s[i]);
  }
  return result;
  }
 };
 // Author: Hao Chen
 // 1) preset a dictionary table to look up vowels
 // 2) we have two pointer, the `left` one search vowels from the beginning to then end, the `right` one search from the end to the beginning.
 // 3) swap the left one and the right one until left >= right.
 class Solution {
 private:
  bool vowelsTable[256];
 public:
  Solution(){
  memset(vowelsTable, 0, sizeof(vowelsTable));
  vowelsTable['a']=true;
  vowelsTable['e']=true;
  vowelsTable['i']=true;
  vowelsTable['o']=true;
  vowelsTable['u']=true;
  vowelsTable['A']=true;
  vowelsTable['E']=true;
  vowelsTable['I']=true;
  vowelsTable['O']=true;
  vowelsTable['U']=true;
  }
  bool isVowels(char ch) {
  return vowelsTable[ch];
  }
  string reverseVowels(string s) {
  int left=0, right=s.size()-1;
  while ( left < right ) {
  while( !isVowels( s[left]) ) left++;
  while( !isVowels( s[right] ) ) right--;
  if (left >= right) break;
  swap(s[left], s[right]);
  left++; right--;
  }
  return s;
  }
 };"
383,383,"#include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <iostream>
 #include <string>
 #include <vector>
 #include <algorithm> // for std::reverse
 using namespace std;
 void reverseWords(string &s) {
  bool wordStart = false;
  vector<string> v;
  const char *pHead =s.c_str();
  const char *pStr, *pBegin, *pEnd;
  for (pStr=pHead; *pStr!='\0'; pStr++) {
  if (!isspace(*pStr) && wordStart == false){
  wordStart = true;
  pBegin = pStr;
  continue;
  }
  if(isspace(*pStr) && wordStart==true){
  wordStart=false;
  pEnd = pStr;
  v.insert(v.begin(), s.substr(pBegin-pHead, pEnd-pBegin) );
  }
  }
  if (wordStart==true){
  pEnd = pStr;
  v.insert(v.begin(), s.substr(pBegin-pHead, pEnd-pBegin) );
  }
  if (v.size()>0){
  s.clear();
  char space=' ';
  vector<string>::iterator it;
  for (it=v.begin(); it!=v.end(); ++it) {
  s = s + *it;
  s.push_back(space);
  }
  s.erase(s.end()-1);
  }else{
  s.clear();
  }
  cout << ""["" << s << ""]"" <<endl;
 }
 // inspired from <Programming Pearls> -- Handwaving
 void reverseWords2(string &s) {
  if (s.length() == 0) return;
  string result = """";
  if (s[s.length()-1] == ' ') {
  int last = s.find_last_not_of(' ') + 1;
  s.erase(last, s.length() - last);
  }
  int first = s.find_first_not_of(' ', 0);
  while (first != string::npos) {
  int wend = s.find(' ', first); // word end
  if (wend == string::npos) wend = s.length();
  string word = s.substr(first, wend - first);
  reverse(word.begin(), word.end());
  result += word;
  first = s.find_first_not_of(' ', wend); // next word
  if (first == string::npos) break;
  result += ' ';
  }
  reverse(result.begin(), result.end());
  s.swap(result);
 }
 // C solution in O(1) space
 void reverse(char *b, char *e) {
  for (--e; e - b > 0; b++, e--) {
  char t = *b;
  *b = *e;
  *e = t;
  }
 }
 void reverseWords(char *s) {
  char *p = s, *ws = NULL, *last = s;
  while (*p && *p == ' ') p++; // skip leading space
  ws = p;
  for ( ; *p; p++) {
  while (*p && *p != ' ') p++; // find word end
  reverse(ws, p);
  strncpy(last, ws, p-ws);
  last += (p-ws);
  while (*p && *p == ' ') p++; // for next word
  ws = p;
  if (*p == '\0') break;
  *last++ = ' ';
  }
  reverse(s, last);
  *last = '\0';
 }
 void test() {
 #define TEST(str) do { \
  char* s = strdup(str); \
  printf(""\""%s\"" => "", s); \
  reverseWords(s); \
  printf(""\""%s\""\n\n"", s); \
  free(s); \
  } while (0)
  TEST("" the blue sky is blue "");
  TEST("" "");
 }
 main()
 {
  string s;
  reverseWords(s);
  s="" "";
  reverseWords(s);
  s=""1 "";
  reverseWords(s);
  s=""love"";
  reverseWords(s);
  s=""i love cpp"";
  reverseWords(s);
  test();
 }"
384,384,"#include <ctype.h>
 #include <iostream>
 #include <string>
 using namespace std;
 void swap(char &a, char &b) {
  char temp = a;
  a = b;
  b = temp;
 }
 void reverse(string &s, int begin, int end) {
  while(begin < end) {
  swap(s[begin++], s[end--]);
  }
 }
 void reverseWords(string &s) {
  if (s.size()<=1) return;
  // reverse the whole string
  reverse(s, 0, s.size()-1);
  // reverse the each word
  for ( int begin=0, i=0; i<=s.size(); i++ ) {
  if ( isblank(s[i]) || s[i] == '\0') {
  reverse(s, begin, i-1);
  begin = i+1;
  }
  }
 }
 int main(int argc, char** argv)
 {
  string s = ""the sky is blue"";
  if ( argc > 1 ) {
  s = argv[1];
  }
  cout << s << endl;
  reverseWords(s);
  cout << s << endl;
 }"
385,385,"#include <iostream>
 #include <string>
 using namespace std;
 int romanCharToInt(char ch){
  int d = 0;
  switch(ch){
  case 'I': 
  d = 1; 
  break; 
  case 'V': 
  d = 5; 
  break; 
  case 'X': 
  d = 10; 
  break; 
  case 'L': 
  d = 50; 
  break; 
  case 'C': 
  d = 100; 
  break; 
  case 'D': 
  d = 500; 
  break; 
  case 'M': 
  d = 1000; 
  break; 
  }
  return d;
 }
 int romanToInt(string s) {
  if (s.size()<=0) return 0;
  int result = romanCharToInt(s[0]);
  for (int i=1; i<s.size(); i++){
  int prev = romanCharToInt(s[i-1]);
  int curr = romanCharToInt(s[i]);
  //if left<right such as : IV(4), XL(40), IX(9) ...
  if (prev < curr) {
  result = result - prev + (curr-prev);
  }else{
  result += curr;
  }
  }
  return result;
 }
 int main(int argc, char**argv)
 {
  string s(""XL"");
  if (argc>1){
  s = argv[1];
  }
  cout << s << "" : "" << romanToInt(s) << endl;
  return 0;
 }"
386,386,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 using namespace std;
 void reverseArray(int nums[],int start, int end){
  int temp;
  while(start < end){
  int temp = nums[start];
  nums[start++] = nums[end];
  nums[end--] = temp;
  }
 }
 /*
  * this solution is so-called three times rotate method
  * because (X^TY^T)^T = YX, so we can perform rotate operation three times to get the result
  * obviously, the algorithm consumes O(1) space and O(n) time
  */
 void rotate1(int nums[], int n, int k) {
  if (k<=0) return;
  k %= n; 
  reverseArray(nums, n-k, n-1);
  reverseArray(nums, 0, n-k-1);
  reverseArray(nums, 0, n-1); 
 }
 /*
  * How to change [0,1,2,3,4,5,6] to [4,5,6,0,1,2,3] by k = 3?
  *
  * We can change by following rules: 
  *
  * [0]->[3], [3]->[6], [6]->[2], [2]->[5], [5]->[1], [1]->[4]
  * 
  *
  */
 void rotate2(int nums[], int n, int k) {
  if (k<=0) return;
  k %= n;
  int currIdx=0, newIdx=k;
  int tmp1 = nums[currIdx], tmp2; 
  int origin = 0;
  for(int i=0; i<n; i++){
  tmp2 = nums[newIdx];
  nums[newIdx] = tmp1;
  tmp1 = tmp2; 
  currIdx = newIdx;
  //if we meet a circle, move the next one
  if (origin == currIdx) {
  origin = ++currIdx;
  tmp1 = nums[currIdx];
  }
  newIdx = (currIdx + k) % n;
  } 
 }
 void rotate(int nums[], int n, int k) {
  if (random()%2==0) {
  cout << ""[1] "";
  return rotate1(nums, n, k);
  }
  cout << ""[2] "";
  return rotate2(nums, n, k);
 }
 void printArray(int nums[], int n) {
  cout << ""[ "" ;
  for(int i=0; i<n; i++) {
  cout << nums[i] << ((i==n-1)? "" "" : "", "");
  }
  cout << ""]"" << endl;
 }
 void initArray(int nums[], int n) {
  for(int i=0; i<n; i++) {
  nums[i] = i;
  }
 }
 int main(int argc, char**argv) {
  srand(time(0));
  int nums[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  const int n = sizeof(nums)/sizeof(int);
  for (int i=0; i<n; i++) {
  initArray(nums, n);
  rotate(nums, n, i);
  printArray(nums, n);
  }
  return 0;
 }"
387,387,"// 
 // Asumming we have 4 numbers: a, b, c, d, then
 // F(0) = 0a + 1b + 2c + 3d
 // F(1) = 3a + 0b + 1c + 2d
 // F(2) = 2a + 3b + 0c + 1d
 // F(3) = 1a + 2b + 3c + 0d
 //
 // We can see how F(n) transfrom to F(n+1) 
 // F(0) - F(1) = -3a + b + c + d 
 // F(1) - F(2) = a + -3b + c + d
 // F(2) - F(3) = a + b + -3c + d
 // F(3) - F(0) = a + b + c + -3d
 // 
 // So, we can tansfrom to the following experssion: 
 // 
 // F(1) = F(0) - (a+b+c+d) + 4a 
 // F(2) = F[1] - (a+b+c+d) + 4b
 // F(3) = F[2] - (a+b+c+d) + 4c
 // 
 // Then, we can see this fomular:
 //
 // F(n) = F(n-1) - sum(array) + len(array) * array[n-1]
 // 
 class Solution {
 public: 
  int maxRotateFunction(vector<int>& A) {
  int sum = 0;
  int F = 0;
  for (int i=0; i < A.size(); i++) {
  sum += A[i];
  F += (i * A[i]);
  }
  int maxF = F;
  int len = A.size();
  //cout << ""F(0) = "" << maxF <<endl;
  for (int i=1; i< len; i++) {
  F = F - sum + len * A[i-1];
  //cout << ""F("" << i << "") = "" << F << endl;
  maxF = max(maxF, F);
  }
  return maxF;
  }
 };"
388,388,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 void rotate(vector<vector<int> > &matrix) {
  int n = matrix.size();
  for( int i=0; i<n/2; i++ ){
  int low=i, high=n-i-1;
  for (int j=low; j<high; j++){
  int tmp;
  tmp = matrix[i][j];
  // left to top 
  matrix[i][j] = matrix[n-j-1][i];
  // bottom to left
  matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
  // right to bottom
  matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
  // top to right
  matrix[j][n-i-1] = tmp;
  }
  }
 }
 void printMatrix(vector<vector<int> > &matrix) 
 {
  for(int i=0; i<matrix.size(); i++){
  for(int j=0; j< matrix[i].size(); j++) {
  printf(""%3d "", matrix[i][j]) ;
  }
  cout << endl;
  }
  cout << endl;
 }
 int main(int argc, char** argv)
 {
  int n = 2;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector< vector<int> > matrix;
  for (int i=1; i<=n; i++) {
  vector<int> v;
  for(int j=1; j<=n; j++){
  v.push_back( (i-1)*n + j );
  }
  matrix.push_back(v);
  }
  printMatrix(matrix);
  rotate(matrix);
  printMatrix(matrix);
  return 0;
 }"
389,389,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  ListNode *rotateRight(ListNode *head, int k) {
  if (!head || k<=0){
  return head;
  }
  //find the length of List
  int len=1;
  ListNode *p=head;
  while( p->next != NULL ){
  p = p->next;
  len++;
  }
  //connect the tail to head
  p->next = head;
  //find the left place (take care the case - k > len)
  k = len - k % len;
  //find the place
  for(int i=0; i<k; i++){
  p = p->next;
  }
  //break the list
  head = p->next;
  p->next = NULL;
  return head;
  }
 };"
390,390,"class Solution {
 public:
  void rotate(vector<vector<char>>& src, vector<vector<char>>& dest) {
  int m = src.size();
  for(int row=0; row<dest.size(); row++) {
  for(int col=0; col<dest[row].size(); col++) {
  dest[row][col] = src[m-col-1][row];
  }
  }
  }
  void gravity(vector<vector<char>>& box) {
  int m = box.size();
  int n = box[0].size();
  for(int col=0; col<n; col++) {
  int bottom = m - 1;
  for(int row=m-1; row>=0; row-- ) {
  if (box[row][col] == '#') {
  box[row][col] = '.';
  box[bottom][col] = '#';
  bottom--;
  }else if (box[row][col] == '*') {
  bottom = row-1;
  }
  }
  }
  }
  vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
  int row = box.size();
  int col = box[0].size();
  vector<vector<char>> result(col, vector<char>(row,'.'));
  rotate(box, result);
  gravity(result);
  return result;
  }
 };"
391,391,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  bool isSameTree(TreeNode *p, TreeNode *q) {
  if (random()%2){
  return isSameTree1(p, q);
  }
  return isSameTree2(p, q);
  }
  bool isSameTree1(TreeNode *p, TreeNode *q) {
  if(!p && !q) return true; 
  if(!p || !q) return false; 
  return (p->val == q->val) && 
  isSameTree(p->left, q->left) && 
  isSameTree(p->right, q->right);
  }
  bool isSameTree2(TreeNode *p, TreeNode *q) {
  queue<TreeNode*> q1, q2;
  q1.push(p);
  q2.push(q);
  while (q1.size()>0 && q2.size()>0 ){
  TreeNode* p1 = q1.front();
  q1.pop();
  TreeNode* p2 = q2.front();
  q2.pop();
  if (!p1 && !p2) continue;
  if (!p1 || !p2) return false;
  if ( p1->val != p2->val) {
  return false;
  }
  q1.push(p1->left);
  q2.push(p2->left);
  q1.push(p1->right);
  q2.push(p2->right);
  }
  return true;
  }
 };"
392,392,"class Solution {
 private:
  map<char, char> eq_map; // the table store the equivalent relationship
  void init() {
  for (char ch='a'; ch<='z'; ch++) {
  eq_map[ch] = ch;
  }
  }
 public:
  Solution() {
  init();
  }
  // find the tail node, 
  // if a == b == c == d, find(a) would return d;
  // find(b) would return d;
  char find(char ch) {
  while(ch != eq_map[ch]) {
  ch = eq_map[ch];
  }
  return ch;
  }
  //join x equivalent chain with y equivalent chain
  void join(char x, char y) {
  char tx = find(x);
  char ty = find(y);
  if (tx != ty) { 
  eq_map[tx] = ty;
  }
  }
  bool equationsPossible(vector<string>& equations) {
  for (auto e : equations ) {
  if (e[1] == '=' && e[0] != e[3]) { // equal
  join(e[0], e[3]);
  }
  }
  for (auto e : equations) {
  if (e[1] == '!' && (e[0] == e[3] || find(e[0]) == find(e[3]) ) ) { 
  return false;
  }
  }
  return true;
  }
 };"
393,393,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <string>
 #include <algorithm>
 using namespace std;
 // The recursive way is quite simple.
 // 1) break the string to two parts: 
 // s1[0..j] s1[j+1..n]
 // s2[0..j] s2[j+1..n]
 // 2) then
 // isScramble(s1[0..j], s2[0..j]) && isScramble(s1[j+1..n], s2[j+1..n])
 // OR
 // isScramble(s1[0..j], s2[j+1, n]) && isScramble(s1[j+1..n], s2[0..j])
 bool isScramble_recursion(string s1, string s2) {
  if (s1.size()!= s2.size() || s1.size()==0 || s2.size()==0) {
  return false;
  }
  if (s1 == s2){
  return true;
  } 
  string ss1 = s1;
  string ss2 = s2;
  sort(ss1.begin(), ss1.end()); 
  sort(ss2.begin(), ss2.end()); 
  if (ss1 != ss2 ) {
  return false;
  }
  for (int i=1; i<s1.size(); i++) {
  if ( isScramble_recursion(s1.substr(0,i), s2.substr(0,i)) && 
  isScramble_recursion(s1.substr(i, s1.size()-i), s2.substr(i, s2.size()-i)) ) {
  return true;
  }
  if ( isScramble_recursion(s1.substr(0,i), s2.substr(s2.size()-i, i)) && 
  isScramble_recursion(s1.substr(i, s1.size()-i), s2.substr(0, s2.size()-i)) ) {
  return true;
  }
  }
  return false;
 }
 /* 
  * Definition
  * 
  * dp[k][i][j] means:
  * 
  * a) s1[i] start from 'i'
  * b) s2[j] start from 'j'
  * c) 'k' is the length of substring
  * 
  * Initialization 
  * 
  * dp[1][i][j] = (s1[i] == s2[j] ? true : false)
  * 
  * Formula
  * 
  * same as the above recursive method idea
  * 
  * dp[k][i][j] = 
  * dp[divk][i][j] && dp[k-divk][i+divk][j+divk] ||
  * dp[divk][i][j+k-divk] && dp[k-divk][i+divk][j]
  * 
  * `divk` mean split the k to two parts, so 0 <= divk <= k;
 */
 bool isScramble_dp(string s1, string s2) {
  if (s1.size()!= s2.size() || s1.size()==0 || s2.size()==0) {
  return false;
  }
  if (s1 == s2){
  return true;
  }
  const int len = s1.size(); 
  // dp[len+1][len][len]
  vector< vector< vector<bool> > > dp(len+1, vector< vector<bool> >(len, vector<bool>(len) ) );
  // ignor the k=0, just for readable code.
  // initialization k=1
  for (int i=0; i<len; i++){
  for (int j=0; j<len; j++) {
  dp[1][i][j] = (s1[i] == s2[j]);
  }
  } 
  // start from k=2 to len, O(n^4) loop. 
  for (int k=2; k<=len; k++){
  for (int i=0; i<len-k+1; i++){
  for (int j=0; j<len-k+1; j++){
  dp[k][i][j] = false;
  for (int divk = 1; divk < k && dp[k][i][j]==false; divk++){
  dp[k][i][j] = ( dp[divk][i][j] && dp[k-divk][i+divk][j+divk] ) ||
  ( dp[divk][i][j+k-divk] && dp[k-divk][i+divk][j] );
  }
  }
  }
  }
  return dp[len][0][0];
 }
 bool isScramble(string s1, string s2) {
  srand(time(0));
  if (random()%2) {
  cout << ""---- recursion ---"" << endl;
  return isScramble_recursion(s1, s2);
  }
  cout << ""---- dynamic programming ---"" << endl;
  return isScramble_dp(s1, s2);
 }
 int main(int argc, char** argv)
 {
  string s1=""great"", s2=""rgtae"";
  if (argc>2){
  s1 = argv[1];
  s2 = argv[2];
  }
  cout << s1 << "", "" << s2 << endl;
  cout << isScramble(s1, s2) << endl;
  return 0;
 }"
394,394,"class Solution {
 public:
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
  return searchMatrix01(matrix, target);
  return searchMatrix02(matrix, target);
  }
  //Just simply convert the 2D matrix to 1D array.
  bool searchMatrix01(vector<vector<int>>& matrix, int target) {
  int row = matrix.size();
  int col = row>0 ? matrix[0].size() : 0;
  int len = row * col;
  int low = 0, high = len -1;
  while (low <= high) {
  int mid = low + (high - low) / 2;
  int r = mid / col;
  int c = mid % col;
  int n = matrix[r][c];
  if (n == target) return true;
  if (n < target) low = mid+1;
  else high = mid -1;
  }
  return false;
  }
  bool searchMatrix02(vector<vector<int> > &matrix, int target) {
  int idx = vertical_binary_search(matrix, target);
  if (idx<0){
  return false;
  }
  idx = binary_search(matrix[idx], target);
  return (idx < 0 ? false : true);
  }
  int vertical_binary_search(vector< vector<int> > v, int key){
  int low = 0;
  int high = v.size()-1;
  while(low <= high){
  int mid = low + (high-low)/2;
  if (v[mid][0] == key){
  return mid;
  }
  if (key < v[mid][0]){
  high = mid - 1;
  continue;
  }
  if (key > v[mid][0]){
  low = mid + 1;
  continue;
  }
  }
  return low-1; 
  }
  int binary_search(vector<int> v, int key) {
  int low = 0;
  int high = v.size()-1;
  while(low <= high){
  int mid = low + (high-low)/2;
  if (v[mid] == key){
  return mid;
  }
  if (key < v[mid]){
  high = mid - 1;
  continue;
  }
  if (key > v[mid]){
  low = mid + 1;
  continue;
  }
  }
  return -1;
  }
 };"
395,395,"class Solution {
 public:
  bool binary_search(vector<int> &v, int target) {
  int low = 0;
  int high = v.size()-1;
  while(low <= high) {
  int mid = low + (high - low)/2;
  if (target == v[mid]) return true;
  if (target < v[mid]) {
  high = mid -1;
  }else {
  low = mid + 1;
  }
  }
  return false;
  }
  //using binary_search() to search each rows - slow O(n*log(n))
  //the run time is around 140ms for all test case
  bool searchMatrix01(vector<vector<int>>& matrix, int target) {
  if (matrix.size() == 0 || matrix[0].size()==0) return false;
  for (int i=0; i<matrix.size(); i++){
  if (target < matrix[i][0] ) return false;
  if (binary_search(matrix[i], target)) return true;
  }
  return false;
  }
  //start the liner search from top right corner of matrix. - O(m+n)
  //the run time is around 64ms
  bool searchMatrix02(vector<vector<int>>& matrix, int target) {
  if (matrix.size() == 0 || matrix[0].size()==0) return false;
  int row=0, col = matrix[0].size() - 1; 
  while (row < matrix.size() && col >=0 ) {
  if (target == matrix[row][col]) return true;
  if (target < matrix[row][col]) {
  col--;
  }else{
  row++;
  }
  }
  return false;
  }
  //a bit optimization for methed 2 - the run time is 68ms
  bool searchMatrix021(vector<vector<int>>& matrix, int target) {
  if (matrix.size() == 0 || matrix[0].size()==0) return false;
  int row=0, col = matrix[0].size() - 1; 
  while (row < matrix.size() && col >=0 ) {
  if (target == matrix[row][col]) return true;
  while ( col>=0 && target < matrix[row][col]) {
  col--;
  }
  while(col >=0 && row < matrix.size() && target > matrix[row][col]){
  row++;
  }
  }
  return false;
  }
  //Optimization: using binary search methed to move `low` and `row` 
  //However, the run time is 112ms
  bool searchMatrix022(vector<vector<int>>& matrix, int target) {
  if (matrix.size() == 0 || matrix[0].size()==0) return false;
  int row=0, col = matrix[0].size() - 1; 
  while (row < matrix.size() && col >=0 ) {
  if (target == matrix[row][col]) return true;
  if (target < matrix[row][col]) {
  int start=0, end=col;
  while(start <= end){
  int mid = start + (end - start)/2;
  if (target == matrix[row][mid]) return true;
  if (target > matrix[row][mid]) {
  start = mid + 1;
  }else {
  end = mid - 1;
  }
  }
  col = end; 
  }else{
  int start=row, end=matrix.size()-1;
  while(start<=end){
  int mid = start + (end - start)/2;
  if (target == matrix[mid][col]) return true;
  if (target > matrix[mid][col]) {
  start = mid + 1;
  }else{
  end = mid -1;
  }
  }
  row = start;
  }
  }
  return false;
  }
  bool searchMatrix(vector<vector<int>>& matrix, int target) {
  return searchMatrix022(matrix, target); //112ms
  return searchMatrix021(matrix, target); //68ms
  return searchMatrix02(matrix, target); //64ms
  return searchMatrix01(matrix, target); //148ms
  }
 };"
396,396,"#include <iostream>
 #include <vector>
 using namespace std;
 int binary_search(int A[], int low, int high, int key);
 /*
  * O(log n) solution must be something like binary search.
  *
  * So, we can use the binary search to find the one postion - `pos`
  * 
  * then, we can keep using the binary search find the target in A[0..pos-1] and A[pos+1..n]
  *
  * The code below is self-explaination
  */
 vector<int> searchRange(int A[], int n, int target) {
  int pos = binary_search(A, 0, n-1, target);
  vector<int> v;
  int low = -1, high = -1;
  if (pos >=0){
  low = high = pos;
  int l = low;
  do {
  low = l;
  l = binary_search(A, 0, low - 1, target);
  }while (l>=0);
  int h = high;
  do {
  high = h;
  h = binary_search(A, high + 1, n-1, target);
  }while (h>=0);
  }
  v.push_back(low);
  v.push_back(high);
  return v;
 }
 int binary_search(int A[], int low, int high, int key){
  while (low<=high) {
  int mid = low + (high-low)/2;
  if (A[mid] == key) {
  return mid;
  }
  if (key > A[mid]) {
  low = mid + 1;
  }
  if (key < A[mid]) {
  high = mid - 1;
  }
  }
  return -1;
 }
 void printVector( vector<int>& pt)
 {
  cout << ""{ "";
  for(int j=0; j<pt.size(); j++){
  cout << pt[j] << "" "";
  }
  cout << ""} "" << endl;
 }
 int main()
 {
  const int cnt=6;
  int a[cnt] ={5, 7, 7, 8, 8, 10};
  vector<int> v;
  v = searchRange(a, cnt, 8); 
  printVector(v); 
  int b[cnt] ={5, 5, 5, 8, 8, 10};
  v = searchRange(b, cnt, 5); 
  printVector(v); 
  int c[cnt] ={5, 5, 5, 5, 5, 5};
  v = searchRange(c, cnt, 5); 
  printVector(v); 
  return 0;
 }"
397,397,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 int binary_search(int A[], int n, int key); 
 int binary_search(int A[], int l, int h, int key); 
 int rotate_search(int A[], int l, int h, int key);
 int search1(int A[], int n, int target);
 int search2(int A[], int n, int target); 
 int search(int A[], int n, int target) {
  if (random()%2){
  return search1(A, n, target);
  }
  return search2(A, n, target);
 }
 /*
  * Using binary search idea, 
  * 1) Spliting the array to two part, one part should be non-rotated, another one is rotated.
  * 2) Checking the ""key"" whether is possible in non-rotated sorted part.
  * 2.1) if it is, then go to the classcial binary searh.
  * 2.2) if it not, then keep spliting the rorated part.
  *
  */
 int search1(int A[], int n, int key) {
  if (n<=0) return -1;
  if (n==1){
  return (A[0]==key) ? 0 : -1;
  }
  int low=0, high=n-1;
  while( low<=high ){
  if (A[low] <= A[high] && ( key < A[low] || key > A[high]) ) {
  return -1;
  }
  int mid = low + (high-low)/2;
  if ( A[mid] == key ) return mid;
  //the target in non-rotated array
  if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
  high = mid - 1;
  continue;
  }
  //the target in non-rotated array
  if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
  low = mid + 1;
  continue;
  }
  //the target in rotated array
  if (A[low] > A[mid] ){
  high = mid - 1;
  continue;
  }
  //the target in rotated array
  if (A[mid] > A[high] ){
  low = mid + 1;
  continue;
  }
  }
  return -1;
 }
 int search2(int A[], int n, int target) {
  if (n<=0) return -1;
  if (n==1){
  return A[0]==target?0:-1;
  } 
  if ( A[0] < A[n-1] ){
  return binary_search(A, n, target);
  }else{
  return rotate_search(A, 0, n-1, target);
  }
 }
 int rotate_search(int A[], int low, int high, int key ) {
  if (low > high){
  return -1;
  }
  if (low==high){
  return A[low]==key?low:-1;
  } 
  int mid = low + (high-low)/2;
  if ( A[mid] == key ) return mid;
  if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
  return binary_search(A, low, mid-1, key);
  }
  if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
  return binary_search(A, mid+1, high, key);
  }
  if (A[low] > A[mid] ){
  return rotate_search(A, low, mid-1, key);
  }
  if (A[mid] > A[high] ){
  return rotate_search(A, mid+1, high, key);
  }
  return -1;
 }
 int binary_search(int A[], int n, int key) {
  int low = 0;
  int high = n-1;
  while (low <= high){
  int mid = low +(high-low)/2;
  if (A[mid] == key){
  return mid;
  }
  if ( key> A[mid] ) {
  low = mid+1;
  }else{
  high = mid-1;
  }
  }
  return -1;
 }
 int binary_search(int A[], int low, int high, int key) {
  //(low+high)/2 could encounter overflow issue
  int mid = low+(high-low)/2;
  if (low > high){
  return -1;
  }
  if (A[mid]==key){
  return mid;
  }
  if (key > A[mid]){
  binary_search(A, mid+1, high, key);
  }else{
  binary_search(A, low, mid-1, key);
  }
 }
 void rotate_array(int a[], int n, int pos){
  int i, from=0;
  pos = pos % n;
  if (n<=0) return;
  int tmp = a[0];
  for(int i=0, step=0; step<n && i<pos; step++){
  int to;
  if (from-pos < 0) {
  to = n-pos+from; 
  }else{
  to = from-pos;
  }
  int t ;
  t = a[to];
  a[to] = tmp; 
  tmp = t;
  from = to;
  if ( to == i ){
  i++;
  from++;
  tmp = a[from];
  }
  }
 }
 void printArray(int A[], int n) {
  printf(""{"");
  for(int i=0; i<n; i++) {
  printf(""%d, "", A[i]);
  }
  printf(""}\n"");
 }
 int main(int argc, char** argv)
 {
  int cnt=20;
  if (argc>1) {
  cnt = atoi(argv[1]);
  }
  srand(time(NULL)); 
  for(int n=0; n<=cnt; n++) {
  printf(""--------------------------------------\n"");
  int *a = new int[cnt];
  for(int i=0; i<cnt; i++){
  a[i]=i*2;
  }
  //printArray(a, cnt);
  int rotate = random() % cnt;
  //rotate=2;
  //printf(""rotate=%d\n"", rotate);
  rotate_array(a, cnt, rotate);
  printArray(a, cnt);
  int target = random() % (2*cnt);
  //target=6;
  printf(""target=%d\n"", target);
  int idx = search(a, cnt, target);
  if ( idx<0 ){
  printf(""not found!\n"");
  }else{
  printf(""a[%d] = %d\n"", idx, a[idx]); 
  }
  delete[] a;
  }
  return 0;
 }"
398,398,"// Using the same idea ""Search in Rotated Sorted Array""
 // but need be very careful about the following cases:
 // [3,3,3,4,5,6,3,3] 
 // [3,3,3,3,1,3]
 // After split, you don't know which part is rotated and which part is not.
 // So, you have to skip the ducplication
 // [3,3,3,4,5,6,3,3] 
 // ^ ^
 // [3,3,3,3,1,3]
 // ^ ^
 class Solution {
 public:
  bool search(int A[], int n, int key) {
  if (n<=0) return false;
  if (n==1){
  return (A[0]==key) ? true : false;
  }
  int low=0, high=n-1;
  while( low<=high ){
  if (A[low] < A[high] && ( key < A[low] || key > A[high]) ) {
  return false;
  }
  //if dupilicates, remove the duplication
  while (low < high && A[low]==A[high]){
  low++;
  }
  int mid = low + (high-low)/2;
  if ( A[mid] == key ) return true;
  //the target in non-rotated array
  if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
  high = mid - 1;
  continue;
  }
  //the target in non-rotated array
  if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
  low = mid + 1;
  continue;
  }
  //the target in rotated array
  if (A[low] > A[mid] ){
  high = mid - 1;
  continue;
  }
  //the target in rotated array
  if (A[mid] > A[high] ){
  low = mid + 1;
  continue;
  }
  //reach here means nothing found.
  low++;
  }
  return false;
  }
 };"
399,399,"#include <stdio.h>
 int binary_search(int A[], int n, int key) {
  int low = 0;
  int high = n-1;
  while (low <= high){
  int mid = low +(high-low)/2;
  if (A[mid] == key){
  return mid;
  }
  if ( key> A[mid] ) {
  low = mid+1;
  }else{
  high = mid-1;
  }
  }
  return low;
 }
 int searchInsert(int A[], int n, int target) {
  if (n==0) return n;
  return binary_search(A, n, target);
 }
 int main()
 {
  int a[]={1,3,5,6};
  printf(""%d -> %d\n"", 5, searchInsert(a, 4, 5));
  printf(""%d -> %d\n"", 2, searchInsert(a, 4, 2));
  printf(""%d -> %d\n"", 7, searchInsert(a, 4, 7));
  printf(""%d -> %d\n"", 0, searchInsert(a, 4, 0));
  return 0;
 }"
400,400,"class SeatManager {
 private:
  set<int> idle;
 public:
  SeatManager(int n) {
  for(int i=1; i<=n; i++) {
  idle.insert(i);
  }
  }
  int reserve() {
  auto it = idle.begin();
  auto seat = *it;
  idle.erase(it);
  return seat;
  }
  void unreserve(int seatNumber) {
  idle.insert(seatNumber);
  }
 };
 /**
  * Your SeatManager object will be instantiated and called as such:
  * SeatManager* obj = new SeatManager(n);
  * int param_1 = obj->reserve();
  * obj->unreserve(seatNumber);
  */"
401,401,"class Solution {
 public:
  int secondHighest(string s) {
  int first = -1, second = -1;
  for (auto& c : s){
  if (c >='0' && c<='9') {
  int n = c - '0';
  if ( n > first) {
  second = first;
  first = n;
  }else if (n < first && n > second) {
  second = n;
  }
  }
  }
  return second;
  }
 };"
402,402,"#include ""sentenceScreenFitting.h""
 #include <string.h>
 #include <iomanip>
 #include <iostream>
 #define FOR(START, END) for((START)=0;(START)<(END);(START)+=1) {
 #define END ;}
 #define N 100
 // first brute force solution
 int SentenceScreenFitting(char stc[][M], int row, int col, size_t l)
 {
  int i, j, t, s, k=0, ret=0;
  int len[N] = {0};
  FOR(i, l) len[i] = (int)strlen(stc[i]) END
  FOR(i, row)
  j = col;
  t = k;
  while (j - len[k] >= 0) {
  j -= len[k] + 1;
  if (k+1 > l-1){
  FOR(s, k-t) std::cout << stc[t+s] << ' ' END;
  std::cout << stc[t+s];
  if (j - len[0] >= 0)
  std::cout << ' ';
  k = 0;
  t = 0;
  ret++;
  } else{
  k++;
  }
  }
  FOR(s, k-t-1) std::cout << stc[t+s] << ' ' END;
  if (k-t > 0)
  std::cout << stc[t+s];
  std::cout << std::setfill ('-') << std::setw(j == col ? col:j+1) << """" << std::endl;
  END
  return ret;
 }
 /*
 int Solution::wordsTyping(vector<string>& sentence, int rows, int cols)
 {
  int i, j, t, s, k=0, ret=0, l=(int)sentence.size();
  int len[N] = {0};
  FOR(i, l) len[i] = (int)sentence[i].size() END
  FOR(i, rows)
  j = cols;
  t = k;
  while (j - len[k] >= 0) {
  j -= len[k] + 1;
  if (k+1 > l-1){
 // FOR(s, k-t) std::cout << sentence[t+s] << ' ' END;
 // std::cout << sentence[t+s];
 // if (j - len[0] >= 0)
 // std::cout << ' ';
  k = 0;
  t = 0;
  ret++;
  } else{
  k++;
  }
  }
 // FOR(s, k-t-1) std::cout << sentence[t+s] << ' ' END;
 // if (k-t > 0)
 // std::cout << sentence[t+s];
 // 
 // std::cout << std::setfill ('-') << std::setw(j == cols ? cols:j+1) << """" << std::endl;
  END
  return ret;
 }
 */
 // second boosting
 int Solution::wordsTyping(vector<string>& sentence, int rows, int cols)
 {
  int i, j, k=0, ret=0, l=(int)sentence.size();
 // int t, s;
  int jump = 0;
  int len[N] = {0};
  FOR(i, l) len[i] = (int)sentence[i].size();jump += len[i] END
  jump += l;
  FOR(i, rows)
  j = cols;
 // t = k;
  if (k == 0){
  ret += j / jump;
  j = j % jump;
  }
  while (j - len[k] >= 0) {
  j -= len[k] + 1;
  if (k+1 > l-1){
  // FOR(s, k-t) std::cout << sentence[t+s] << ' ' END;
  // std::cout << sentence[t+s];
  // if (j - len[0] >= 0)
  // std::cout << ' ';
  k = 0;
 // t = 0;
  ret += j / jump + 1;
  j = j % jump;
  } else {
  k++;
  }
  }
  // FOR(s, k-t-1) std::cout << sentence[t+s] << ' ' END;
  // if (k-t > 0)
  // std::cout << sentence[t+s];
  //
  // std::cout << std::setfill ('-') << std::setw(j == cols ? cols:j+1) << """" << std::endl;
  END
  return ret;
 }"
403,403,"class Solution {
 private:
  bool isWord(char ch) {
  return (ch >='a' && ch <= 'z' ) || ( ch >='A' && ch <= 'Z');
  }
  bool isSpace(char ch) {
  return (ch == ' ');
  }
  void split(string& s, vector<string>& words) {
  s += ' ';
  int start=0, end=0;
  while(start < s.size()) {
  while(isSpace(s[start])) start++;
  end = start;
  while(!isSpace(s[end])) end++;
  words.push_back(s.substr(start, end-start));
  start = end + 1;
  }
  }
  void print(vector<string>& v) {
  cout << ""["";
  for(int i=0; i<v.size()-1; i++) {
  cout << v[i] << "", "";
  }
  cout << v[v.size()-1] << ""]"" << endl;
  }
 public:
  bool areSentencesSimilar(string sentence1, string sentence2) {
  string& longstr = sentence1.size() >= sentence2.size() ? sentence1 : sentence2;
  string& shortstr = sentence1.size() < sentence2.size() ? sentence1 : sentence2;
  if ( longstr == shortstr ) return true;
  vector<string> words1, words2;
  split(shortstr, words1);
  split(longstr, words2);
  //print(words1); print(words2);
  int left=0, right=words1.size()-1;
  while(left< words1.size() && words1[left] == words2[left]) left++;
  int delta = words2.size() - words1.size();
  while(right>=left && words1[right] == words2[delta+right]) right--;
  //cout << left << "":"" << right << "":"" << delta << endl;
  return left > right;
  }
 };"
404,404,"#include <iostream>
 #include <sstream>
 #include <vector>
 #include <string>
 using namespace std;
 /**
  * Definition for a binary tree node.
  */
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 class Codec {
 public:
  // Encodes a tree to a single string.
  string serialize(TreeNode* root) {
  return serialize02(root);
  return serialize01(root);
  }
  // Decodes your encoded data to tree.
  TreeNode* deserialize(string data) {
  return deserialize02(data);
  return deserialize01(data);
  } 
 /*
  * ===============================================================================
  * Using pre-order to serialize and deserialize the tree. 
  * ===============================================================================
  */
 public:
  // Encodes a tree to a single string.
  string serialize01(TreeNode* root) {
  string result;
  vector<TreeNode*> v;
  serializeHelper(root, v);
  for(int i=0; i<v.size(); i++){
  result = result + (v[i]==NULL ? ""#"" : to_string(v[i]->val)) + "" "";
  }
  return result;
  }
  // Decodes your encoded data to tree.
  TreeNode* deserialize01(string data) {
  vector<TreeNode*> v;
  split(data, ' ', v);
  int index = 0;
  return deserializeHelper(v, index);
  } 
 private:
  void serializeHelper(TreeNode* root, vector<TreeNode*>& v) {
  if (root==NULL) {
  v.push_back(NULL);
  }else{
  v.push_back(root);
  serializeHelper(root->left, v);
  serializeHelper(root->right, v);
  }
  }
  TreeNode* deserializeHelper(vector<TreeNode*> &v, int& index) {
  if (index >= v.size() ) return NULL;
  TreeNode* root = v[index++];
  if (root) {
  root->left = deserializeHelper(v, index);
  root->right = deserializeHelper(v, index);
  }
  return root;
  }
  void split(const string &s, char delim, vector<TreeNode*> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
  TreeNode* node = (item==""#"" ? NULL : new TreeNode( stoi(item)) );
  elems.push_back(node);
  }
  }
 /*
  * ===============================================================================
  * Using sstream instead of vector to improve the performance
  * ===============================================================================
  */
 public:
  // Encodes a tree to a single string.
  string serialize02(TreeNode* root) {
  ostringstream out;
  serialize(root, out);
  return out.str();
  }
  // Decodes your encoded data to tree.
  TreeNode* deserialize02(string data) {
  istringstream in(data);
  return deserialize(in);
  } 
 private:
  void serialize(TreeNode* root, ostringstream& out) {
  if (root==NULL) {
  out << ""# "";
  return;
  }
  out << root->val << "" "";
  serialize(root->left, out);
  serialize(root->right, out);
  }
  TreeNode* deserialize(istringstream& in) {
  string val;
  in >> val;
  if (val == ""#"" || val.empty() ) return NULL;
  TreeNode* node = new TreeNode(stoi(val));
  node->left = deserialize(in);
  node->right = deserialize(in);
  return node;
  }
 };
 // Your Codec object will be instantiated and called as such:
 // Codec codec;
 // codec.deserialize(codec.serialize(root));
 int main(int argc, char** argv) 
 {
  string s = ""1 2 3 # # 4 5"";
  if (argc>1){
  s = argv[1];
  }
  cout << s << endl;
  Codec codec;
  cout << codec.serialize(codec.deserialize(s)) << endl;
  return 0;
 }"
405,405,"class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  void setZeroes(vector<vector<int> > &matrix) {
  if(random()%2){
  setZeroes1(matrix);
  }
  setZeroes2(matrix);
  }
  void setZeroes1(vector<vector<int> > &matrix) {
  int bRow = false, bCol=false;
  for (int r=0; r<matrix.size(); r++){
  for(int c=0; c<matrix[r].size(); c++){
  if (matrix[r][c]==0){
  if (r==0) bRow = true;
  if (c==0) bCol = true;
  matrix[0][c] = matrix[r][0] = 0;
  }
  }
  }
  for (int r=1; r<matrix.size(); r++){
  for(int c=1; c<matrix[r].size(); c++){
  if (matrix[0][c]==0 || matrix[r][0]==0) {
  matrix[r][c]=0;
  }
  }
  }
  if (bRow){
  for(int c=0; c<matrix[0].size(); c++) matrix[0][c] = 0;
  }
  if (bCol){
  for(int r=0; r<matrix.size(); r++) matrix[r][0] = 0;
  }
  }
  void setZeroes2(vector<vector<int> > &matrix) {
  bool *row = new bool[matrix.size()]();
  bool *col = new bool[matrix[0].size()]();
  for (int r=0; r<matrix.size(); r++){
  for(int c=0; c<matrix[r].size(); c++){
  if (matrix[r][c]==0){
  row[r]=true;
  col[c]=true;
  }
  }
  }
  for (int r=0; r<matrix.size(); r++){
  for(int c=0; c<matrix[r].size(); c++){
  if (row[r] || col[c]) {
  matrix[r][c]=0;
  }
  }
  }
  }
 };"
406,406,"class Solution {
 public:
  static bool comp(string a,string b){
  return a.size() < b.size();
  }
  int minimumLengthEncoding(vector<string>& words) {
  sort(words.begin(),words.end(),comp);
  int ans = 0;
  int count = 0;
  unordered_map<string,int> M;
  for(int i = 0 ; i < words.size() ; i++){
  string temp = """";
  for(int k = words[i].size() - 1 ; k >= 0 ; k--){
  temp = words[i][k] + temp;
  M[temp]++;
  }
  }
  for(int i = 0 ; i < words.size() ; i++){
  ans = ans + words[i].size();
  count++;
  if(M[words[i]] > 1){
  ans = ans - words[i].size();
  count--;
  M[words[i]]--;
  }
  }
  return ans + count;
  }
 };"
407,407,"#include <iostream>
 #include <string>
 #include <vector>
 #include <algorithm>
 using namespace std;
 bool isPalindrome(string& s, int begin, int end) {
  for (; begin<end; begin++, end-- ) {
  if ( s[begin] != s[end] ) {
  return false;
  }
  }
  return true;
 }
 // Burst Force - - Time Limit Error
 string shortestPalindrome_bf(string& s) {
  int len = s.size();
  int i;
  for (i=len-1; i>=0; i--) {
  if (isPalindrome(s, 0, i)) { 
  i++;
  break;
  }
  }
  string t = s.substr(i, len-i);
  reverse(t.begin(), t.end());
  return t+s;
 }
 //Dynamic Programming - Memory Limit Exceeded & Time Limit Error
 // Using the method of finding longest palindrome
 string shortestPalindrome_dp(string& s) {
  int len = s.size();
  if (len <=1 ) return s;
  //find longest palindrome, see ""Longest Palindromic Substring""
  vector< vector<bool> > dp(len, vector<bool>(len, false));
  for (int i=len-1; i>=0; i--){
  for(int j=i; j<len; j++){
  if (i==j || ((j-i==1 || dp[i+1][j-1]) && s[i]==s[j]) ) {
  dp[i][j] = true;
  }
  } 
  } 
  /*
  * // only use two lines -- still have Time Limit Error
  *
  * vector< vector<bool> > dp(2, vector<bool>(len, false));
  * for (int i=len-1; i>=0; i--){
  * for(int j=i; j<len; j++){
  * if (i==j || ((j-i==1 || dp[(i+1)%2][j-1]) && s[i]==s[j]) ) {
  * dp[i%2][j] = true;
  * }
  * }
  * }
  */
  //find the longest palindrome which start from first char.
  int pos = 0;
  for (int i=1; i<len; i++) {
  if (dp[0][i]) {
  pos = i+1;
  } 
  }
  string t = s.substr(pos, len - pos);
  reverse(t.begin(), t.end());
  return t+s;
 }
 /*
  * The core of KMP algorithm needs to build a partial match table for pattern, 
  * which can determin how many chars need to skip if mismatch happens.
  *
  * The best explaination of the idea of the KMP algorithm is:
  * http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
  *
  * Here, we can use KMP algorithm to solve this problem.
  *
  * 1) We need construct a mirror string base on original string. and use a uniq char for seperator.
  *
  * considering the original string is ""abab"", then the mirror string is ""abab#baba"" (# is seperator)
  *
  * 2) Build the KMP partial match table for this pattern.
  *
  * a b a b # b a b a
  * 0 0 1 2 0 0 1 2 3
  *
  * 3) Checking the last position of partial match table, it is 3. it means:
  *
  * For the entire pattern (mirror string), there has max 3 length of sub-string is both prefix and suffix.
  * 
  * This sub-string is ""aba"".
  *
  * 4) The result of 3) is really useful to solve this shorest palindrome problem.
  *
  * Because ""aba"" is the pattern which in original string and its reversed version.
  *
  * ( Note: The uniq char is used for making the noise, which can make sure 
  * the original string and its reversed version won't be mixed.
  * then, the common prefix and suffix sub-string is right )
  *
  * So, if a sub-string ""aba"" is existed in both original string and its reversed version,
  * which means, this is the longest prefix palindrome.
  *
  * 5) Then, we can take rest suffix, and reverse it and put it in front of original string.
  *
  */
 string shortestPalindrome_kmp(string& s) { 
  int len = s.size();
  if(len <= 1) return s;
  string pattern = s + '\0' + string(s.rbegin(), s.rend()); 
  //construct the partial match table
  vector<int> prefix( pattern.size() ); 
  prefix[0] = 0;
  for(int i = 1; i < prefix.size(); i++) { 
  int j = prefix[i-1]; 
  while( j > 0 && pattern[i] != pattern[j] ) {
  j = prefix[j-1]; 
  }
  if ( pattern[i] == pattern[j] ) {
  j++; 
  }
  prefix[i] = j; 
  } 
 #ifdef _DEBUG
  cout << endl;
  for(int i=0; i<pattern.size(); i++){
  cout << (pattern[i] ? pattern[i] : '#') << "" "";
  }
  cout << endl;
  for(int i=0; i<prefix.size(); i++) {
  cout << prefix[i] << "" "";
  }
  cout << endl;
  cout << ""-->"" << s.substr(0, prefix.back()) << "" "" << s.substr(prefix.back()) << endl;
 #endif
  int pos = s.size() - prefix.back(); 
  return string(s.rbegin(), s.rbegin() + pos) + s; 
 } 
 string shortestPalindrome(string s) {
  return shortestPalindrome_kmp(s); 
  return shortestPalindrome_dp(s); //Memory Limit Error
  return shortestPalindrome_bf(s); //Time Limit Error
 }
 #define TEST(s) cout << s << "" : "" << shortestPalindrome(s) << endl
 int main(int argc, char**argv)
 {
  string s = ""aabba"";
  if (argc>1){
  s = argv[1];
  }
  TEST(s);
  TEST(""a"");
  TEST(""ab"");
  TEST(""aba"");
  TEST(""abab"");
  TEST(""aabb"");
  TEST(""aacecaaa"");
  TEST(""abcd"");
  TEST(""aaabcb"");
  return 0;
 }"
408,408,"class Solution {
 public:
  Solution(vector<int> nums) : _nums(nums), _solution(nums) {
  srand(time(NULL));
  }
  /** Resets the array to its original configuration and return it. */
  vector<int> reset() {
  return _solution = _nums;
  }
  /** Returns a random shuffling of the array. */
  vector<int> shuffle() {
  //Fisher Yates
  //https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
  int i = _solution.size();
  while ( --i > 0 ) {
  int j = rand() % (i+1);
  swap(_solution[i], _solution[j]);
  }
  return _solution;
  }
 private:
  vector<int> _nums, _solution;
 };
 /**
  * Your Solution object will be instantiated and called as such:
  * Solution obj = new Solution(nums);
  * vector<int> param_1 = obj.reset();
  * vector<int> param_2 = obj.shuffle();
  */"
409,409,"class Solution {
 public: 
  string restoreString(string s, vector<int>& indices) {
  string result(s.size(), ' ');
  for (int i = 0; i < indices.size(); i++) {
  result[indices[i]] = s[i];
  }
  return result;
  }
 };"
410,410,"class Solution {
 public:
  vector<int> shuffle(vector<int>& nums, int n) {
  vector<int> result;
  for (int i=0; i<n; i++) {
  result.push_back(nums[i]);
  result.push_back(nums[i+n]);
  }
  return result;
  }
 };"
411,411,"class Solution {
 public:
  int arraySign(vector<int>& nums) {
  int negtive=0;
  for(auto& n : nums) {
  if (n==0) return 0;
  if (n < 0) negtive++;
  }
  return negtive % 2 == 0 ? 1 : -1;
  }
 };"
412,412,"#include <iostream>
 #include <string>
 #include <vector>
 #include <sstream>
 using namespace std;
 vector<string> &split(const string &s, char delim, vector<string> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
  elems.push_back(item);
  }
  return elems;
 }
 vector<string> split(const string &s, char delim) {
  vector<string> elems;
  split(s, delim, elems);
  return elems;
 }
 string simplifyPath(string path) {
  string result;
  vector<string> elems = split(path, '/'); 
  int ignor = 0;
  for(int i=elems.size()-1; i>=0; i--) {
  if (elems[i]=="""" || elems[i]==""."" ){
  continue;
  }
  if (elems[i]==""..""){
  ignor++;
  continue;
  }
  if (ignor>0){
  ignor--;
  continue;
  }
  if (result.size()==0){
  result = ""/"" + elems[i];
  }else{ 
  result = ""/"" + elems[i] + result;
  }
  }
  return result.size() ? result : ""/"";
 }
 int main(int argc, char** argv)
 {
  string path(""/a/./b/../../c/"");
  if (argc > 1 ){
  path = argv[1];
  }
  cout << path << "" : "" << simplifyPath(path) << endl;
 }"
413,413,"#include <stdio.h>
 // This is classical interview question
 // As we know, the same number XOR together will be 0,
 // So, XOR all of numbers, the result is the number which only appears once. 
 int singleNumber(int A[], int n) {
  int s = 0;
  for(int i=0; i<n; i++){
  s = s^A[i];
  }
  return s;
 }
 int main()
 {
  int a[]={1,1,2,2,3};
  printf(""%d\n"", singleNumber(a,5));
  return 0;
 }"
414,414,"class Solution {
 public:
  Solution(){
  srand(time(0));
  }
  //random invoker
  int singleNumber(int A[], int n) {
  if (rand()%2){
  return singleNumber_1(A, n);
  }
  return singleNumber_2(A, n);
  }
  /*
  * This solution is clear & straightforward implementation.
  * 
  * We use an array of 32 length(e.g. count[32]) to count the the bits for all of numbers. 
  *
  * Because the same number appear 3 times, which means the sum of i-th bits for all numbers should be 3 times.
  *
  * In other word, the sum of the i-th bits mod 3, it must be 0 or 1. 1 means that is the single number bit.
  *
  * This solution can be easy to extend to ""every element appears k times except for one.""
  *
  */
  int singleNumber_1(int A[], int n) {
  int count[32] = {0};
  int result = 0;
  for (int i = 0; i < 32; i++) {
  for (int j = 0; j < n; j++) {
  if ((A[j] >> i) & 1) {
  count[i]++;
  }
  }
  result |= ((count[i] % 3) << i);
  }
  return result;
  }
  /*
  * The following solution is popular solution on Internet, but it looks it's not easy to understand.
  *
  * Actually, it just optimizes the above soultion.
  *
  * Let's see how it improve the above.
  *
  * We use three bitmasks, 
  * 1) `ones` as a bitmask which represents the i-th bit had appeared once.
  * 2) `twos` as a bitmask which represents the i-th bit had appeared twice.
  * 3) `threes` as a bit mask which represents the i-th bit had appeared three times.
  *
  * When the i-th bit had appeared for the third time, clear the i-th bit of both `ones` and `twos` to 0.
  * The final answer will be the value of `ones`
  *
  */
  int singleNumber_2(int A[], int n) {
  int ones = 0, twos = 0, threes = 0;
  for (int i = 0; i < n; i++) {
  // `ones & A[i]` the result is the bitmask which the bits appeared twice
  twos |= ones & A[i]; 
  // XOR means remove the bit which appeared twice int `ones` 
  ones ^= A[i];
  // count the `three`
  threes = ones & twos;
  // clear the `ones` and `twos` if the i-th bit had appeared three times.
  ones &= ~threes;
  twos &= ~threes;
  }
  return ones;
  }
 };"
415,415,"/*
  * For the problem - only one number appears once when all other numbers appears exactly twice.
  * 
  * We know, we can XOR all of the array elements. Since X^X is zero, and X^0 is X, 
  * so all of the duplicated number will zero themselves out, and the only number would be the result.
  * 
  * However, this solution cannot be applied directly to finding two numbers that appear once each. 
  * 
  * Suppose that these numbers that appear once are X and Y, and all other numbers appear twice. 
  * If we decide to XOR all the array's elements, the overall result would actually be `X^Y`. 
  * 
  * Unfortunately, there is no way to extract J and K out of their XOR. 
  * 
  * But since X and Y are different, we are sure that X^Y is different than zero. 
  * 
  * This information is valuable in sense that we know pieces of information that differ.
  * If we pick up any bit that is 1 in X XOR Y, we can use it as a mask to test each element of the array. 
  * 
  * Obviously, that mask will be the discriminator between X and Y - 
  * 
  * Only one of them will have value 1 at that particular position.
  * 
  * 
  * Now that we have the mask with exactly one bit set to 1, we can walk through the array once again. 
  * 
  * But this time we are going to maintain two XORed results. 
  * 
  * - One for numbers that have bit 1 at the mask's position 
  * - Another for numbers that have bit 0 at that position
  * 
  * In this way, we are sure that all duplicates will go into the same pile. 
  * 
  * But likewise, we are sure that X and Y will go into separate piles. 
  * 
  * So, the overall result is that 
  * - the first XORed result will be equal to X 
  * - and the second XORed result will be equal to Y
  * 
 */
 class Solution {
 public:
  vector<int> singleNumber(vector<int>& nums) {
  int allxor = 0;
  for (int n : nums) {
  allxor ^= n;
  }
  int mask = 1;
  while ( (mask & allxor) == 0 ) {
  mask <<= 1;
  }
  int zero = 0;
  int one = 0;
  for (int n : nums) {
  if (n & mask ){
  one ^= n;
  }else {
  zero ^= n;
  }
  }
  vector<int> result;
  result.push_back(zero);
  result.push_back(one);
  return result;
  }
 };"
416,416,"class Solution {
 private:
  template<typename T>
  void print(T q) { 
  while(!q.empty()) {
  auto t = q.top();
  cout << t[2]<< ""["" << t[0] <<"",""<< t[1] << ""] "";
  q.pop();
  }
  std::cout << '\n';
  }
 public:
  vector<int> getOrder(vector<vector<int>>& tasks) {
  // push the index into each task.
  // [enQueueTime, ProcessingTime, index]
  for(int i=0; i<tasks.size(); i++){
  tasks[i].push_back(i); 
  }
  //Sort the tasks by enQueueTtime
  sort(tasks.begin(), tasks.end(), [&](vector<int>& lhs, vector<int>& rhs) {
  return lhs[0] < rhs[0];
  });
  //Sort function for tasks priority queue.
  auto comp = [&](vector<int>& lhs, vector<int>& rhs){
  // if the processing time is same ,get the smaller index
  if (lhs[1] == rhs[1]) return lhs[2] > rhs[2]; 
  // choosing the shorter processing time.
  return lhs[1] > rhs[1];
  };
  priority_queue<vector<int>, std::vector<vector<int>>, decltype(comp)> q (comp);
  vector<int> result;
  int i = 0;
  while (i < tasks.size()) {
  long time = tasks[i][0];
  int start = i;
  for (;i < tasks.size() && tasks[start][0] == tasks[i][0];i++ ) {
  q.push(tasks[i]);
  }
  //print(q);
  while(!q.empty()){
  //processing the task
  auto t = q.top(); q.pop();
  //cout << ""DEQUEUE: "" << t[2] << "":["" << t[0] <<"",""<< t[1] << ""]""<< endl;
  result.push_back(t[2]);
  //enQueue the tasks when CPU proceing the current task
  time += t[1];
  for(;i < tasks.size() && tasks[i][0] <= time; i++) {
  //cout << ""ENQUEUE: "" << tasks[i][2] << "":["" << tasks[i][0] <<"",""<< tasks[i][1] << ""]""<< endl;
  q.push(tasks[i]);
  }
  //print(q);
  //cout << endl;
  }
  }
  return result;
  }
 };"
417,417,"#include <iostream>
 #include <vector>
 #include <deque>
 #include <set>
 using namespace std;
 //O(nlog(k)
 vector<int> maxSlidingWindow02(vector<int>& nums, int k) {
  vector<int> result;
  //using multiset for collecting the window data (O(nlog(k) time complexity)
  multiset<int> w;
  for(int i=0; i<nums.size(); i++) {
  //remove the left item which leaves window 
  if (i >= k) {
  w.erase(w.find(nums[i-k]));
  }
  //insert the right itme which enter the window
  w.insert(nums[i]);
  if (i>=k-1) {
  result.push_back(*w.rbegin());
  }
  }
  return result;
 }
 //O(n)
 vector<int> maxSlidingWindow01(vector<int>& nums, int k) {
  vector<int> result;
  //using multiset for collecting the window data (O(nlog(k) time complexity)
  deque<int> q;
  for(int i=0; i<nums.size(); i++) {
  //remove the left item which leaves window 
  if (!q.empty() && q.front() == i - k) {
  q.pop_front();
  }
  //remove all num which less than current number from the back one by one
  while (!q.empty() && nums[q.back()] < nums[i]) {
  q.pop_back();
  }
  //insert the right itme which enter the window
  q.push_back(i);
  if (i>=k-1) {
  result.push_back(nums[q.front()]);
  }
  }
  return result;
 }
 vector<int> maxSlidingWindow(vector<int>& nums, int k) {
  return maxSlidingWindow01(nums, k);
  return maxSlidingWindow02(nums, k);
 }
 void printVector( vector<int>& v ) {
  cout << ""{ "";
  for(int i=0; i<v.size(); i++) {
  cout << v[i] << (i==v.size() ? "" "": "", "");
  }
  cout << ""}"" << endl;
 }
 int main(int argc, char** argv) 
 {
  int a[] = {1,3,-1,-3,5,3,6,7};
  int k = 3;
  vector<int> nums(a, a+sizeof(a)/sizeof(a[0]));
  printVector(nums);
  vector<int> result = maxSlidingWindow(nums, k);
  printVector(result);
 }"
418,418,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  string smallestFromLeaf(TreeNode* root) {
  string str, result=""{""; //'z'+1;
  smallestFromLeafHelper(root, str, result);
  return result;
  }
  void smallestFromLeafHelper(TreeNode* root, string str, string& result) {
  if (root->left == NULL && root->right == NULL) {
  str.insert(0, 1, char(root->val+'a'));
  result = min(result, str);
  return;
  }
  str.insert(0, 1, char(root->val+'a'));
  if (root->left) {
  smallestFromLeafHelper(root->left, str, result);
  }
  if (root->right) {
  smallestFromLeafHelper(root->right, str, result);
  }
  }
 };"
419,419,"class Solution {
 public:
  bool isEven(int& x) {
  return x % 2 == 0;
  }
  vector<int> sortArrayByParity(vector<int>& A) {
  //two pointer, one from left to right, another from right to left
  // if left is odd number and right is even number, switch them
  int l=0, r=A.size()-1;
  while ( l < r ) {
  if ( !isEven(A[l]) && isEven(A[r]) ) swap(A[l], A[r]);
  if ( isEven(A[l]) ) l++;
  if ( !isEven(A[r]) ) r--;
  }
  return A;
  }
 };"
420,420,"class Solution {
 public:
  bool isEven(int &x) {
  return x % 2 == 0;
  }
  vector<int> sortArrayByParityII(vector<int>& A) {
  //two pointer, `even` and `odd`,
  // - `even` pointer step into even position
  // - `odd` pointer step into odd position.
  // if `even` points to odd number, and `odd` points to even number switch them.
  int even = 0;
  int odd = 1;
  while(even < A.size() && odd < A.size() ) {
  if ( !isEven(A[even]) && isEven(A[odd]) ) swap( A[even], A[odd] );
  if ( isEven(A[even]) ) even += 2;
  if ( !isEven(A[odd]) ) odd += 2;
  }
  return A;
  }
 };"
421,421,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 void swap(int*a, int*b)
 {
  int t;
  t=*a;
  *a = *b;
  *b = t;
 }
 void sortColors(int a[], int n) {
  int zero=0, two=n-1;
  for(int i=0; i<=two; i++ ){
  if (a[i]==0){
  swap(&a[zero], &a[i]);
  zero++;
  }
  if (a[i]==2){
  swap(&a[two], &a[i]);
  two--; 
  i--;
  }
  }
 }
 void printArray(int a[], int n) {
  for(int i=0; i<n; i++){
  printf(""%d "", a[i]);
  }
  printf(""\n"");
 }
 int main(int argc, char** argv)
 {
  int n = 7;
  if (argc>1)
  n = atoi(argv[1]);
  srand(time(NULL));
  int *a = new int[n];
  for (int i=0; i<n; i++){
  a[i] = random()%3;
  }
  printArray(a, n);
  sortColors(a, n);
  printArray(a, n);
  delete[] a;
 }"
422,422,"class Solution {
 public:
  string sortSentence(string s) {
  const int MAX_WORDS = 9;
  string ss[MAX_WORDS];
  string word;
  for(int i=0; i<s.size(); i++){
  char ch = s[i];
  if (ch >='0' && ch <='9'){
  ss[ch-'0'-1] = word;
  word = """";
  }else if (ch != ' ') {
  word += ch;
  }
  }
  for(int i=1; i < MAX_WORDS; i++){
  if (ss[i].size() <= 0 ) continue;
  ss[0] = ss[0] +"" "" + ss[i];
  }
  return ss[0];
  }
 };"
423,423,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(NULL) {}
 };
 ListNode *mergeTwoLists(ListNode* head1, ListNode* head2);
 ListNode *sortList(ListNode *head) {
  if (head==NULL || head->next == NULL){
  return head;
  }
  //find the middle place
  ListNode *p1=head, *p2=head->next; 
  while(p2 && p2->next){
  p1 = p1->next;
  p2 = p2->next->next;
  }
  p2 = p1->next;
  p1->next = NULL;
  return mergeTwoLists(sortList(head), sortList(p2));
 }
 ListNode *mergeTwoLists(ListNode* head1, ListNode* head2){
  ListNode *p1 = head1, *p2=head2;
  static ListNode dummy(0);
  ListNode *tail = &dummy;
  while(p1 && p2){
  if(p1->val < p2->val){
  tail->next = p1;
  p1 = p1->next;
  }else{
  tail->next = p2;
  p2 = p2->next;
  }
  tail = tail->next;
  }
  if (p1) tail->next = p1;
  if (p2) tail->next = p2;
  return dummy.next;
 }
 void printList(ListNode* h)
 {
  while(h!=NULL){
  printf(""%d "", h->val);
  h = h->next;
  }
  printf(""\n"");
 }
 ListNode* createList(int a[], int n)
 {
  ListNode *head=NULL, *p=NULL;
  for(int i=0; i<n; i++){
  if (head == NULL){
  head = p = new ListNode(a[i]);
  }else{
  p->next = new ListNode(a[i]);
  p = p->next;
  }
  }
  return head;
 }
 int main(int argc, char** argv)
 {
  int n = 10;
  if (argc>1){
  n = atoi(argv[1]);
  }
  srand(time(NULL));
  int *a = new int[n];
  for(int i=0; i<n; i++){
  a[i] = random()%n + 1;
  }
  ListNode *p = createList(a, n);
  printList(p);
  printList(sortList(p));
  delete[] a;
  return 0;
 }"
424,424,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 vector<int> spiralOrder(vector<vector<int> > &matrix) {
  vector <int> v;
  int row = matrix.size();
  if (row<=0) return v;
  int col = matrix[0].size();
  if (col<=0) return v;
  int r, c;
  for (r=0, c=0; r<(row+1)/2 && c<(col+1)/2; r++, c++){
  //top
  for(int i=c; i<col-c; i++){
  v.push_back(matrix[r][i]);
  }
  //right
  for(int i=r+1; i<row-r; i++){
  v.push_back(matrix[i][col-c-1]);
  }
  //bottom
  for(int i=col-c-2; row-r-1>r && i>=c; i--){
  v.push_back(matrix[row-r-1][i]);
  }
  //left
  for(int i=row-r-2; col-c-1>c && i>r; i--){
  v.push_back(matrix[i][c]);
  }
  }
  return v;
 }
 void printArray(vector<int> v)
 {
  cout << ""["";
  for(int j=0; j<v.size(); j++) {
  printf("" %02d"", v[j]);
  }
  cout << ""]"" << endl;;
 }
 void printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  printArray(vv[i]);
  }
  cout << endl;
 }
 vector< vector<int> > createMatrix(int n, int m)
 {
  vector< vector<int> > vv;
  int cnt = 1;
  for(int i=0; i<n; i++){
  vector<int> v;
  for(int j=0; j<m; j++){
  v.push_back(cnt++);
  }
  vv.push_back(v);
  }
  return vv;
 }
 int main(int argc, char** argv)
 {
  int n=3, m=3;
  if (argc>2){
  n = atoi(argv[1]);
  m = atoi(argv[2]);
  }
  vector< vector<int> > matrix = createMatrix(n, m);
  printMatrix(matrix);
  vector<int> v = spiralOrder(matrix);
  printArray(v);
  return 0;
 }"
425,425,"#include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 vector<vector<int> > generateMatrix(int n, int m);
 vector<vector<int> > generateMatrix(int n) {
  return generateMatrix(n, n);
 }
 vector<vector<int> > generateMatrix(int n, int m) {
  vector< vector <int> > matrix(n);
  if (n<=0) return matrix;
  for(int i=0; i<n; i++){
  vector<int> v(m);
  matrix[i] = v;
  }
  int row=n, col=m;
  int r, c;
  int cnt=1;
  for (r=0, c=0; r<(row+1)/2 && c<(col+1)/2; r++, c++){
  //top
  for(int i=c; i<col-c; i++){
  matrix[r][i] = cnt++;
  }
  //right
  for(int i=r+1; i<row-r; i++){
  matrix[i][col-c-1] = cnt++;
  }
  //bottom
  for(int i=col-c-2; row-r-1>r && i>=c; i--){
  matrix[row-r-1][i] = cnt++;
  }
  //left
  for(int i=row-r-2; col-c-1>c && i>r; i--){
  matrix[i][c] = cnt++;
  }
  }
  return matrix;
 }
 void printArray(vector<int> v)
 {
  cout << ""["";
  for(int j=0; j<v.size(); j++) {
  printf("" %02d"", v[j]);
  }
  cout << ""]"" << endl;;
 }
 void printMatrix(vector< vector<int> > &vv)
 {
  for(int i=0; i<vv.size(); i++) {
  printArray(vv[i]);
  }
  cout << endl;
 }
 int main(int argc, char** argv)
 {
  int n=3, m=3;
  if (argc>1){
  m = n = atoi(argv[1]);
  }
  if (argc>2){
  m = atoi(argv[2]);
  }
  vector< vector<int> > matrix = generateMatrix(n, m);
  printMatrix(matrix);
  return 0;
 }"
426,426,"class Solution {
 public:
  // Idea
  // 1) The max of the result is the sum of the whole array.
  // 2) The min of the result is the max num among the array.
  // 3) Then, we use Binary Search to find the resullt between the `min` and the `max`
  int splitArray(vector<int>& nums, int m) {
  int min = 0, max = 0;
  for (int n : nums) {
  min = std::max(min, n);
  max += n;
  }
  while (min < max) {
  int mid = min + (max - min) / 2;
  if (hasSmallerSum(nums, m, mid)) max = mid;
  else min = mid + 1;
  }
  return min;
  }
  // Using a specific `sum` to check wheter we can get `smaller sum`
  // The idea here as below:
  // find all of possible `sub array` whose sum greater than `sum`
  // 1) if the number of `sub array` > m, whcih means the actual result is greater than `sum`
  // 2) if the number of `sub array` <= m, whcih means we can have `smaller sum`
  //
  bool hasSmallerSum(vector<int>& nums, int m, int sum) {
  int cnt = 1, curSum = 0;
  for (int n : nums) {
  curSum += n;
  if (curSum > sum) {
  curSum = n;
  cnt++;
  if (cnt > m) return false;
  }
  }
  return true;
  }
 };"
427,427,"class Solution {
 private:
  int pos;
 public:
  bool getNum(string& s, long target) {
  long n = 0;
  while(s[pos] == '0') pos++; 
  while(pos < s.size()){
  n = (n*10 + s[pos++] - '0') ;
  if (n == target) return true;
  if (n > target ) return false; // n is already greater than target
  }
  return target == n;
  }
  long firstNum(string& s, int len) {
  long n = 0;
  while(s[pos] == '0') pos++; 
  for(; pos< s.size() && len > 0; pos++, len--) {
  n = (n*10 + s[pos] - '0') ;
  }
  return n; 
  }
  bool splitString(string s) {
  pos = 0;
  long num;
  for (int len=1; len<= s.size()/2+1; len++) {
  pos = 0;
  num = firstNum(s, len); 
  if (pos >= s.size()) continue; // only have one number
  bool result = true;
  while( pos < s.size() ) {
  if (getNum(s, --num) == false){
  result = false;
  break;
  }
  }
  if (result) return true;
  }
  return false;
  }
 };"
428,428,"#include <stdlib.h>
 #include <iostream>
 using namespace std;
 int sqrt(int x) {
  if (x <=0 ) return 0;
  //the sqrt is not greater than x/2+1
  int e = x/2+1;
  int s = 0;
  // binary search
  while ( s <= e ) {
  int mid = s + (e-s)/2;
  long long sq = (long long)mid*(long long)mid;
  if (sq == x ) return mid;
  if (sq < x) {
  s = mid + 1;
  }else {
  e = mid - 1;
  }
  }
  return e; 
 }
 // http://en.wikipedia.org/wiki/Newton%27s_method
 int sqrt_nt(int x) {
  if (x == 0) return 0;
  double last = 0;
  double res = 1;
  while (res != last)
  {
  last = res;
  res = (res + x / res) / 2;
  }
  return int(res);
 }
 int main(int argc, char**argv)
 {
  int n = 2;
  if( argc > 1 ){
  n = atoi(argv[1]);
  }
  cout << ""sqrt("" << n << "") = "" << sqrt(n) << endl;
  return 0;
 }"
429,429,"class Solution {
 public:
  vector<int> sortedSquares(vector<int>& A) {
  // find the place, negative numbers are right, positive number are right.
  // two pointer, one goes left, another goes right.
  //using binary search algorithm
  const int len = A.size();
  int low = 0, high = len- 1;
  int mid =0;
  while (low <= high) {
  mid = low + (high - low)/2;
  if (A[mid] >= 0 ) high = mid - 1;
  if (A[mid] < 0 ) low = mid + 1;
  }
  //TRICKY: make sure A[mid] <= 0 or A[mid] is A[0]
  if (A[mid] > 0 && mid > 0 ) mid--;
  //cout << mid << "" - ""<< A[mid]<< endl;
  vector<int> result;
  low = mid; high = mid+1;
  while ( low >=0 && high < len ) {
  if ( abs(A[low]) < abs(A[high]) ) {
  result.push_back(A[low] * A[low]);
  low --;
  }else {
  result.push_back(A[high] * A[high]);
  high++;
  }
  }
  for (;low >= 0; low--) result.push_back(A[low] * A[low]);
  for (;high<len; high++) result.push_back(A[high] * A[high] );
  return result;
  }
 };"
430,430,"#include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #define INT_MIN (-2147483647 - 1)
 #define INT_MAX 2147483647
 int atoi(const char *str) {
  if (str==NULL || *str=='\0'){
  return 0;
  }
  int ret=0;
  for(;isspace(*str); str++);
  bool neg=false;
  if (*str=='-' || *str=='+') {
  neg = (*str=='-') ;
  str++;
  }
  for(; isdigit(*str); str++) {
  int digit = (*str-'0');
  if(neg){
  if( -ret < (INT_MIN + digit)/10 ) {
  return INT_MIN;
  }
  }else{
  if( ret > (INT_MAX - digit) /10 ) {
  return INT_MAX;
  }
  }
  ret = 10*ret + digit ;
  }
  return neg?-ret:ret;
 }
 int main()
 {
  printf(""\""%s\"" = %d\n"", ""123"", atoi(""123""));
  printf(""\""%s\"" = %d\n"", "" 123"", atoi("" 123""));
  printf(""\""%s\"" = %d\n"", ""+123"", atoi(""+123""));
  printf(""\""%s\"" = %d\n"", "" -123"", atoi("" -123""));
  printf(""\""%s\"" = %d\n"", ""123ABC"", atoi(""123ABC""));
  printf(""\""%s\"" = %d\n"", "" abc123ABC"", atoi("" abc123ABC""));
  printf(""\""%s\"" = %d\n"", ""2147483647"", atoi(""2147483647""));
  printf(""\""%s\"" = %d\n"", ""-2147483648"", atoi(""-2147483648""));
  printf(""\""%s\"" = %d\n"", ""2147483648"", atoi(""2147483648""));
  printf(""\""%s\"" = %d\n"", ""-2147483649"", atoi(""-2147483649""));
  return 0;
 }"
431,431,"class Solution {
 public:
  string strWithout3a3b(int A, int B) {
  string result;
  while (true){
  // if A == B, then just simpley repeat ""ab"" pattern;
  if (A == B) {
  for ( int i=0; i<A; i++ ) {
  result += ""ab"";
  }
  break;
  }
  // if A+B less then 3 and A != B, which means A=1,2 && B=0 or A=0 && B=1,2
  if (A+B <3) {
  while ( A-- > 0 ) result += 'a';
  while ( B-- > 0 ) result += 'b';
  break;
  }
  // if A+B >=3 and A !=B
  // if A > B, then we need consume 'a' more than 'b'
  // So, only ""aab"" can be used.
  if ( A > B ) {
  result += ""aab"";
  A -= 2;
  B--;
  continue;
  }
  // if A > B, then we need consume 'b' more than 'a'
  // So, only ""bba"" can be used.
  if (B > A ){
  result += ""bba"";
  B-=2;
  A--;
  continue;
  }
  }
  return result;
  }
 };"
432,432,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 char *strStr1(char *haystack, char *needle);
 char *strStr2(char *haystack, char *needle);
 char *strStr(char*haystack, char *needle) {
  if (random()%2){
  printf(""---KMP---\n"");
  return strStr1(haystack, needle);
  }
  printf(""---brute-force---\n"");
  return strStr2(haystack, needle);
 }
 //KMP
 char *strStr1(char *haystack, char *needle) {
  if(!haystack || !needle ) {
  return NULL;
  }
  if (!*needle ) {
  return haystack;
  }
  char *ph = haystack;
  char *pn = needle;
  for( ;*ph && *pn ; ph++, pn++ );
  //len(haystack) < len(needle)
  if (!*ph && *pn){
  return NULL; 
  }
  for(ph=ph-1; *ph; haystack++, ph++) {
  char *q=needle;
  char *p=haystack;
  int n=0;
  while(*q && *p && *p==*q){
  p++; q++;
  if (n==0 && *p == *needle){
  n = p - haystack;
  }
  }
  if (!*q){
  return haystack;
  }
  haystack += (n>0 ? n-1 : n);
  }
  return NULL;
 }
 //brute-force
 char *strStr2(char *haystack, char *needle) {
  if(!haystack || !needle ) {
  return NULL;
  }
  if (!*needle ) {
  return haystack;
  }
  char *ph = haystack;
  char* pn = needle;
  for( ;*ph && *pn ; ph++, pn++ );
  //len(haystack) < len(needle)
  if (!*ph && *pn){
  return NULL; 
  }
  ph--;
  for( ; *ph; haystack++, ph++) {
  char *q=needle;
  char *p=haystack;
  while(*q && *p && *p==*q){
  p++; q++;
  }
  if (!*q){
  return haystack;
  }
  }
  return NULL;
 }
 int main(int argc, char** argv)
 {
  srand(time(0));
  const char* haystack = ""mississippi"";
  const char* needle = ""issi"";
  printf(""%s, %s : %s\n"", haystack, needle, strStr((char*)haystack, (char*)needle));
  haystack = ""mississippi"";
  needle = ""issip"";
  printf(""%s, %s : %s\n"", haystack, needle, strStr((char*)haystack, (char*)needle));
  haystack = ""babbbbbabb"";
  needle = ""bbab"";
  printf(""%s, %s : %s\n"", haystack, needle, strStr1((char*)haystack, (char*)needle));
  if (argc>2){
  haystack = argv[1];
  needle = argv[2];
  printf(""%s, %s : %s\n"", haystack, needle, strStr((char*)haystack, (char*)needle));
  }
  return 0;
 }"
433,433,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void getCombination(vector<int>& v, int n, int k, vector<int>& solution, vector< vector<int> >& result );
 vector<vector<int> > combine(vector<int>& v, int k); 
 vector<vector<int> > combine1(vector<int>& v, int k); 
 vector<vector<int> > combine2(vector<int>& v, int k);
 vector<vector<int> > subsets(vector<int> &S) {
  vector<vector<int> > result;
  for(int i=0; i<=S.size(); i++){
  vector<vector<int> > r = combine(S, i); 
  result.insert(result.end(), r.begin(), r.end()); 
  } 
  return result;
 }
 vector<vector<int> > combine(vector<int>& v, int k) {
  if (random()%2){
  cout << ""recusive method!"" << endl;
  return combine1(v, k);
  }
  cout << ""non-recusive method!"" << endl;
  return combine2(v, k);
 }
 vector<vector<int> > combine1(vector<int> &v, int k) {
  vector<vector<int> > result;
  vector<int> solution;
  getCombination(v, v.size(), k, solution, result);
  return result;
 }
 void getCombination(vector<int> &v, int n, int k, vector<int>& solution, vector< vector<int> >& result ){
  if (k==0){
  //sort to meet LeetCode requirement
  vector<int> v = solution;
  sort(v.begin(), v.end());
  result.push_back(v);
  return;
  }
  for(int i=n; i>0; i--){
  solution.push_back(v[i-1]);
  getCombination(v, i-1, k-1, solution, result);
  solution.pop_back();
  }
 }
 vector<vector<int> > combine2(vector<int> &v, int k) {
  vector<vector<int> > result;
  vector<int> d;
  int n = v.size();
  for (int i=0; i<n; i++){
  d.push_back( (i<k) ? 1 : 0 );
  }
  //1) from the left, find the [1,0] pattern, change it to [0,1]
  //2) move all of the 1 before the pattern to the most left side
  //3) check all of 1 move to the right
  while(1){
  vector<int> tmp;
  for(int x=0; x<n; x++){
  if (d[x]) tmp.push_back(v[x]);
  }
  sort(tmp.begin(), tmp.end());
  result.push_back(tmp);
  //step 1), find [1,0] pattern
  int i;
  bool found = false;
  int ones =0;
  for(i=0; i<n-1; i++){
  if (d[i]==1 && d[i+1]==0){
  d[i]=0; d[i+1]=1;
  found = true;
  //step 2) move all of right 1 to the most left side
  for (int j=0; j<i; j++){
  d[j]=( ones > 0 ) ? 1 : 0;
  ones--;
  }
  break; 
  } 
  if (d[i]==1) ones++;
  }
  if (!found){
  break;
  }
  }
  return result;
 }
 void printResult(vector<vector<int> >& result)
 {
  for(int i=0; i<result.size(); i++){
  cout << ""{"";
  for(int j=0; j<result[i].size(); j++){
  cout << "" "" << result[i][j];
  }
  cout << "" }"" <<endl;
  }
 }
 void printArray(vector<int>& v){
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << "" }"" << endl;
 }
 int main(int argc, char** argv)
 {
  srand(time(NULL));
  int n = 3;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector<int> v;
  for(int i=n; i>0; i--){
  v.push_back(i);
  }
  printArray(v);
  vector<vector<int> > r = subsets(v);
  printResult(r);
 }"
434,434,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <algorithm>
 using namespace std;
 void getCombination(vector<int>& v, int n, int k, vector<int>& solution, vector< vector<int> >& result );
 vector<vector<int> > combine(vector<int>& v, int k); 
 vector<vector<int> > combine1(vector<int>& v, int k); 
 vector<vector<int> > combine2(vector<int>& v, int k);
 vector<vector<int> > subsets(vector<int> &S) {
  vector<vector<int> > result;
  sort(S.begin(), S.end());
  for(int i=0; i<=S.size(); i++){
  vector<vector<int> > r = combine(S, i); 
  result.insert(result.end(), r.begin(), r.end()); 
  } 
  return result;
 }
 vector<vector<int> > combine(vector<int> &v, int k) {
  vector<vector<int> > result;
  vector<int> solution;
  getCombination(v, v.size(), k, solution, result);
  return result;
 }
 void getCombination(vector<int> &v, int n, int k, vector<int>& solution, vector< vector<int> >& result ){
  if (k==0){
  //sort to meet LeetCode requirement
  vector<int> v = solution;
  sort(v.begin(), v.end());
  result.push_back(v);
  return;
  }
  for(int i=n; i>0; i--){
  solution.push_back(v[i-1]);
  getCombination(v, i-1, k-1, solution, result);
  solution.pop_back();
  //skip the duplication
  while (i>1 && v[i-1]==v[i-2]) i--;
  }
 }
 void printResult(vector<vector<int> >& result)
 {
  for(int i=0; i<result.size(); i++){
  cout << ""{"";
  for(int j=0; j<result[i].size(); j++){
  cout << "" "" << result[i][j];
  }
  cout << "" }"" <<endl;
  }
 }
 void printArray(vector<int>& v){
  cout << ""{"";
  for(int i=0; i<v.size(); i++) {
  cout << "" "" << v[i];
  }
  cout << "" }"" << endl;
 }
 int main(int argc, char** argv)
 {
  srand(time(NULL));
  int n = 3;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector<int> v;
  for(int i=n; i>0; i--){
  v.push_back(random()%n+1);
  }
  printArray(v);
  cout << ""--------------------"" <<endl;
  vector<vector<int> > r = subsets(v);
  printResult(r);
  cout << ""===================="" <<endl;
  int a[] = {1, 4, 4, 4, 4,};
  v.clear();
  v.insert(v.begin(), a, a+5);
  printArray(v);
  cout << ""--------------------"" <<endl;
  r = subsets(v);
  printResult(r);
  cout << ""===================="" <<endl;
 }"
435,435,"#include <iostream>
 #include <vector>
 #include <string>
 #include <map>
 using namespace std;
 vector<int> findSubstring(string S, vector<string> &L) {
  vector<int> result;
  if ( S.size()<=0 || L.size() <=0 ){
  return result;
  }
  int n = S.size(), m = L.size(), l = L[0].size();
  //put all of words into a map 
  map<string, int> expected;
  for(int i=0; i<m; i++){
  if (expected.find(L[i])!=expected.end()){
  expected[L[i]]++;
  }else{
  expected[L[i]]=1;
  }
  }
  for (int i=0; i<l; i++){
  map<string, int> actual;
  int count = 0; //total count
  int winLeft = i;
  for (int j=i; j<=n-l; j+=l){
  string word = S.substr(j, l);
  //if not found, then restart from j+1;
  if (expected.find(word) == expected.end() ) {
  actual.clear();
  count=0;
  winLeft = j + l;
  continue;
  }
  count++;
  //count the number of ""word""
  if (actual.find(word) == actual.end() ) {
  actual[word] = 1;
  }else{
  actual[word]++;
  }
  // If there is more appearance of ""word"" than expected
  if (actual[word] > expected[word]){
  string tmp;
  do {
  tmp = S.substr( winLeft, l );
  count--;
  actual[tmp]--;
  winLeft += l; 
  } while(tmp!=word);
  }
  // if total count equals L's size, find one result
  if ( count == m ){
  result.push_back(winLeft);
  string tmp = S.substr( winLeft, l );
  actual[tmp]--;
  winLeft += l;
  count--;
  }
  }
  }
  return result;
 }
 int main(int argc, char**argv)
 {
  string s = ""barfoobarfoothefoobarman"";
  vector<string> l;
  l.push_back(""foo"");
  l.push_back(""bar"");
  l.push_back(""foo"");
  vector<int> indics = findSubstring(s, l);
  for(int i=0; i<indics.size(); i++){
  cout << indics[i] << "" "";
  }
  cout << endl;
  return 0;
 }"
436,436,"#include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <iostream>
 #include <vector>
 using namespace std;
 const int SodukuSize = 9;
 bool row_mask[SodukuSize][SodukuSize];
 bool col_mask[SodukuSize][SodukuSize];
 bool area_mask[SodukuSize][SodukuSize];
 bool initSudokuMask(vector< vector<char> > &board){
  //reset the memory
  memset(row_mask, false, sizeof(row_mask));
  memset(col_mask, false, sizeof(col_mask));
  memset(area_mask, false, sizeof(area_mask));
  //check each rows and cols
  for(int r=0; r<board.size(); r++){
  for (int c=0; c<board[r].size(); c++){
  if (!isdigit(board[r][c])) {
  continue;
  };
  int idx = board[r][c] - '0' - 1;
  //check the rows/cols/areas
  int area = (r/3) * 3 + (c/3);
  if (row_mask[r][idx] || col_mask[c][idx] || area_mask[area][idx] ){
  return false;
  }
  row_mask[r][idx] = col_mask[c][idx] = area_mask[area][idx] = true;
  }
  }
  return true;
 }
 bool recursiveSudoKu(vector< vector<char> > &board, int row, int col){
  if (row >= SodukuSize) {
  return true;
  }
  if (col >= SodukuSize){
  return recursiveSudoKu(board, row+1, 0);
  }
  if (board[row][col] != '.'){
  return recursiveSudoKu(board, row, col+1); 
  }
  //pick a number for empty cell
  int area;
  for(int i=0; i<SodukuSize; i++){
  area = (row/3) * 3 + (col/3);
  if (row_mask[row][i] || col_mask[col][i] || area_mask[area][i] ){
  continue;
  }
  //set the number and sovle it recursively
  board[row][col] = i + '1';
  row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = true;
  if (recursiveSudoKu(board, row, col+1) == true){
  return true;
  }
  //backtrace
  board[row][col] = '.';
  row_mask[row][i] = col_mask[col][i] = area_mask[area][i] = false;
  }
  return false;
 }
 void solveSudoku(vector<vector<char> > &board) {
  if (initSudokuMask(board) == false){
  return;
  }
  recursiveSudoKu(board, 0, 0); 
 }
 int main(int argc, char**argv) {
  return 0;
 }"
437,437,"class Solution {
 public:
  string makeRange(int start, int end) {
  ostringstream oss;
  if (start != end) {
  oss << start << ""->"" << end;
  } else {
  oss << start;
  }
  return oss.str();
  }
  vector<string> summaryRanges(vector<int>& nums) {
  vector<string> result;
  int len = nums.size();
  if (len == 0) return result;
  // we have two pointer for range-starter and range-ender
  int start=nums[0], end=nums[0];
  for (int i=1; i<len; i++) {
  // if it is continous number, move the end pointer;
  if (nums[i] == end + 1) {
  end = nums[i];
  continue;
  }
  //if the number is not continous, push the range into result
  //and reset the start and end pointer
  result.push_back(makeRange(start, end));
  start = end = nums[i];
  }
  //for the last range
  result.push_back(makeRange(start, end)); 
  return result;
  }
 };"
438,438,"class Solution {
 private:
  int beauty(string& s, int start, int end) {
  int stat[26] = {0};
  for (int i=start; i<=end; i++){
  stat[s[i]-'a']++;
  }
  int max = INT_MIN, min = INT_MAX; 
  for (auto s: stat) {
  if (s == 0 ) continue;
  max = s > max ? s : max;
  min = s < min ? s : min;
  }
  return max - min;
  }
 public:
  int beautySum(string s) {
  return beautySum02(s);
  return beautySum01(s);
  }
  int beautySum01(string& s) {
  int sum = 0; 
  for (int i=0; i<s.size()-1; i++) {
  for (int j=i+1; j<s.size(); j++) {
  sum += beauty(s, i, j);
  }
  }
  return sum;
  }
  //same as beautySum01(), but optimazed slightly
  int beautySum02(string& s) {
  int sum = 0; 
  for (int i=0; i<s.size()-1; i++) {
  int stat[26] = {0};
  for (int j=i; j<s.size(); j++) {
  stat[s[j]-'a']++;
  int max = INT_MIN, min = INT_MAX; 
  for (auto& n: stat) {
  if (n <= 0 ) continue; 
  max = n > max ? n : max;
  min = n < min ? n : min;
  }
  //cout << s.substr(i, j-i+1) << "" --> ""<< max << "":"" << min << endl;
  sum += (max - min);
  }
  }
  return sum;
  }
 };"
439,439,"class Solution {
 public:
  int sumBase(int n, int k) {
  int sum = 0;
  while(n > 0) {
  sum += (n % k);
  n /= k;
  }
  return sum;
  }
 };"
440,440,"class Solution {
 public:
  vector<int> sumEvenAfterQueries(vector<int>& A, vector<vector<int>>& queries) {
  int sum = 0;
  for(int i=0; i<A.size(); i++) {
  if (A[i] % 2 == 0) sum += A[i];
  }
  vector<int> result;
  for(auto query : queries) {
  int i = query[1];
  int x = A[i] + query[0];
  if (A[i] % 2 == 0 && x %2 == 0) {
  sum += ( -A[i] + x ); 
  A[i] = x;
  } else if (A[i] % 2 != 0 && x %2 == 0) {
  sum += x;
  A[i] = x;
  } else if (A[i] % 2 == 0 && x %2 != 0) {
  sum -= A[i];
  A[i] = x;
  } else if (A[i] % 2 != 0 && x %2 != 0){ 
  A[i] = x;
  }
  result.push_back(sum);
  }
  if (result.size()<=0) result.push_back(0);
  return result;
  }
 };"
441,441,"class Solution {
 public:
  int sumOfFlooredPairs(vector<int>& nums) {
  const int MAX_NUM = 100001;
  int cnt[MAX_NUM] = {0};
  int maxn = 0;
  for(auto& n : nums) {
  cnt[n]++;
  maxn = max(maxn, n);
  }
  vector<vector<int>> stats;
  for(int i=1; i<MAX_NUM; i++) {
  if (cnt[i] > 0) {
  stats.push_back({i, cnt[i]});
  }
  cnt[i] += cnt[i-1];
  }
  const int MOD = 1e9+7;
  int result = 0;
  for(int i=0; i < stats.size(); i++) {
  int n = stats[i][0];
  int c = stats[i][1];
  for(int x=2; x <= maxn/n+1; x++) {
  int pre = (x-1) * n - 1; 
  int cur = min( x * n - 1, MAX_NUM-1);
  result = (result + (cnt[cur] - cnt[pre]) * long(x-1) * c) % MOD; 
  }
  }
  return result;
  }
 };"
442,442,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  void sumOfLeftLeaves_recursion_v1(TreeNode* root, int& result) {
  if (root == NULL ) {
  return;
  }
  if (root->left && root->left->left == NULL && root->left->right == NULL) {
  result += root->left->val;
  }
  sumOfLeftLeaves_recursion_v1(root->left, result);
  sumOfLeftLeaves_recursion_v1(root->right, result);
  }
  int sumOfLeftLeaves_recursion_v2(TreeNode* root) {
  if (root == NULL ) {
  return 0;
  }
  int result = 0;
  if (root->left && root->left->left == NULL && root->left->right == NULL) {
  result = root->left->val;
  }
  result += sumOfLeftLeaves_recursion_v2(root->left) + sumOfLeftLeaves_recursion_v2(root->right);
  return result;
  } 
  int sumOfLeftLeaves(TreeNode* root) {
  srand(time(NULL));
  if (rand()%2) {
  int result = 0;
  sumOfLeftLeaves_recursion_v1(root, result);
  return result;
  } else {
  return sumOfLeftLeaves_recursion_v2(root);
  }
  }
 };"
443,443,"class Solution {
 public:
  int getSum(int x, int y) {
  // Iterate till there is no carry 
  while (y != 0) {
  // carry now contains common 
  //set bits of x and y
  int carry = x & y; 
  // Sum of bits of x and y where at 
  //least one of the bits is not set
  x = x ^ y; 
  // Carry is shifted by one so that adding
  // it to x gives the required sum
  y = carry << 1;
  }
  return x;
  }
 };"
444,444,"class Solution {
 public:
  int sumOfUnique(vector<int>& nums) {
  return sumOfUnique_special(nums);
  return sumOfUnique_general(nums);
  }
  int sumOfUnique_general(vector<int>& nums) {
  enum stat {UNIQ, DUP};
  unordered_map<int, stat> dict;
  int sum = 0;
  for (auto i : nums) {
  if (dict.find(i) == dict.end()){
  sum += i;
  dict[i] = UNIQ;
  } else {
  if (dict[i] == UNIQ) {
  sum -= i;
  dict[i] = DUP;
  }
  }
  }
  return sum;
  }
  int sumOfUnique_special(vector<int>& nums) {
  //because we have constraint: 1 <= nums[i] <= 100
  //we can use array instead of map 
  enum stat {NO=0,UNIQ=1,DUP=2};
  stat dict[100]={NO};
  int sum = 0;
  for (auto i : nums) {
  switch(dict[i-1]) {
  case NO:
  sum += i;
  dict[i-1] = UNIQ;
  break;
  case UNIQ:
  sum -= i;
  dict[i-1] = DUP;
  break;
  default:
  continue;
  }
  }
  return sum;
  }
 };"
445,445,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  int sumNumbers(TreeNode *root) {
  if (!root) return 0;
  int sum = 0; 
  vector<TreeNode*> v;
  v.push_back(root);
  while(v.size()>0){
  TreeNode* node = v.back();
  v.pop_back();
  if (node->left){
  node->left->val += (10*node->val); 
  v.push_back(node->left);
  }
  if (node->right){
  node->right->val += (10*node->val); 
  v.push_back(node->right);
  }
  if(!node->right && !node->left){
  sum += node->val;
  }
  }
  return sum;
  }
 };"
446,446,"// As the solution we have for the ugly number II problem
 //
 // int nthUglyNumber(int n) {
 //
 // int i=0, j=0, k=0;
 // vector<int> ugly(1,1);
 //
 // while(ugly.size() < n){
 // int next = min(ugly[i]*2, ugly[j]*3, ugly[k]*5);
 // if (next == ugly[i]*2) i++;
 // if (next == ugly[j]*3) j++;
 // if (next == ugly[k]*5) k++;
 // ugly.push_back(next);
 // }
 // return ugly.back();
 // }
 //
 // The logic of solution is exacly same for both., except that instead of 3 numbers you have k numbers to consider. 
 //
 // 
 //
 class Solution {
 public:
  int nthSuperUglyNumber(int n, vector<int>& primes) {
  vector<int> ugly(1, 1);
  int len = primes.size();
  vector<int> pos(len, 0);
  while( ugly.size() < n ) {
  int next = INT_MAX;
  for(int i=0; i<len; i++) {
  next = min(next, ugly[pos[i]] * primes[i]);
  }
  for(int i=0; i<len; i++) {
  if (next == ugly[pos[i]] * primes[i]) {
  pos[i]++;
  }
  }
  ugly.push_back(next);
  }
  return ugly.back();
  }
 };"
447,447,"#include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <vector>
 #include <queue>
 using namespace std;
 void print(vector< vector<char> > &board);
 void markOpen(vector< vector<char> > &board, int row, int col, int r, int c) {
  if (r<0 || c <0 || r>=row || c>=col || board[r][c] != 'O') return;
  board[r][c]='N'; // 'N' means it's not closed
  markOpen(board, row, col, r+1, c);
  markOpen(board, row, col, r-1, c);
  markOpen(board, row, col, r, c+1);
  markOpen(board, row, col, r, c-1);
 }
 void solve_recursively(vector< vector<char> > &board) {
  if (board.size()<=0 || board[0].size()<=0) return;
  int row = board.size();
  int col = board[0].size();
  //left & right edge
  for (int r=0; r<row; r++){
  if ( board[r][0] == 'O') {
  markOpen(board, row, col, r, 0); 
  }
  if ( board[r][col-1] == 'O') {
  markOpen(board, row, col, r, col-1); 
  }
  }
  //top & bottom edge
  for (int c=1; c<col-1; c++){
  if ( board[0][c] == 'O') {
  markOpen(board, row, col, 0, c); 
  }
  if ( board[row-1][c] == 'O') {
  markOpen(board, row, col, row-1, c); 
  }
  }
  print(board);
  // change 'N' to 'O', change 'O' to 'X'
  for (int r=0; r<row; r++) {
  for (int c=0; c<col; c++) {
  if (board[r][c] == 'O') {
  board[r][c]='X';
  } else if (board[r][c] == 'N') {
  board[r][c]='O';
  }
  }
  }
 }
 /*change the recursive method to non_recursive way by using queue*/
 struct position{
  int row, col;
  void set(int r, int c) { row = r; col = c; }
  position(int r, int c): row(r), col(c) {}
 };
 void solve_non_recursively(vector< vector<char> > &board) {
  if (board.size()<=0 || board[0].size()<=0) return;
  int row = board.size();
  int col = board[0].size();
  queue<position> q;
  position p(0,0);
  //left & right edge
  for (int r=0; r<row; r++){
  if ( board[r][0] == 'O') {
  board[r][0] = 'N';
  p.set(r, 0);
  q.push(p) ; 
  }
  if ( board[r][col-1] == 'O') {
  board[r][col-1] = 'N';
  p.set(r, col-1);
  q.push(p) ; 
  }
  }
  //top & bottom edge
  for (int c=1; c<col-1; c++){
  if ( board[0][c] == 'O') {
  board[0][c] = 'N';
  p.set(0, c);
  q.push(p) ; 
  }
  if ( board[row-1][c] == 'O') {
  board[row-1][c] = 'N';
  p.set(row-1, c);
  q.push(p) ; 
  }
  }
  while (!q.empty()){
  p = q.front();
  q.pop(); 
  int r = p.row;
  int c = p.col;
  if (r < row-1 && board[r+1][c] == 'O') {
  board[r+1][c] = 'N';
  p.set(r+1, c);
  q.push(p);
  }
  if (r > 0 && board[r-1][c] == 'O') {
  board[r-1][c] = 'N';
  p.set(r-1, c);
  q.push(p);
  }
  if (c < col-1 && board[r][c+1] == 'O') {
  board[r][c+1] = 'N';
  p.set(r, c+1);
  q.push(p);
  }
  if (c>0 && board[r][c-1] == 'O') {
  board[r][c-1] = 'N';
  p.set(r, c-1);
  q.push(p);
  }
  }
  print(board);
  // change 'N' to 'O', change 'O' to 'X'
  for (int r=0; r<row; r++) {
  for (int c=0; c<col; c++) {
  if (board[r][c] == 'O') {
  board[r][c]='X';
  } else if (board[r][c] == 'N') {
  board[r][c]='O';
  }
  }
  }
 }
 // refers to <Algorithm> 4th edition.
 class UnionFind {
  int count_; // number of components
  int* rank_; // to limits tree hights
  int* id_; // id[i] parent of i
 public:
  UnionFind(int n) {
  count_ = n;
  rank_ = new int[n];
  id_ = new int[n];
  for (int i = 0; i < n; i++) {
  id_[i] = i;
  rank_[i] = 0;
  }
  }
  ~UnionFind() {
  delete [] rank_;
  delete [] id_;
  }
  int count() { return count_; }
  int find(int p) {
  while (p != id_[p]) {
  id_[p] = id_[id_[p]]; // path compression
  p = id_[p];
  }
  return p;
  }
  bool connected(int p, int q) {
  return find(p) == find(q);
  }
  void connect(int p, int q) {
  int i = find(p);
  int j = find(q);
  if (i == j) return;
  if (rank_[i] < rank_[j]) id_[i] = j;
  else if (rank_[i] > rank_[j]) id_[j] = i;
  else { // ==
  id_[j] = i;
  rank_[i]++;
  }
  count_--;
  }
 };
 class Solution {
 public:
  void solve(vector<vector<char> >& board) {
  int n = board.size();
  if (n == 0) return;
  int m = board[0].size();
  UnionFind uf(n*m+1);
  for (int i = 0; i < n; i++) {
  for (int j = 0; j < m; j++) {
  if (i == 0 || i == n-1 || j == 0 || j == m-1) { // side case, connect to dummy node
  uf.connect(i*m + j, n*m);
  continue;
  }
  char c = board[i][j]; // inner case, connect to same neighbor
  if (board[i+1][j] == c) uf.connect((i+1)*m + j, i*m + j);
  if (board[i-1][j] == c) uf.connect((i-1)*m + j, i*m + j);
  if (board[i][j+1] == c) uf.connect(i*m + (j+1), i*m + j);
  if (board[i][j-1] == c) uf.connect(i*m + (j-1), i*m + j);
  }
  }
  for (int i = 0; i < n; i++) {
  for (int j = 0; j < m; j++) {
  if (board[i][j] == 'O' && !uf.connected(i*m + j, n*m)) {
  board[i][j] = 'X';
  }
  }
  }
  }
 };
 void solve(vector< vector<char> > &board) {
  if (rand() % 2) {
  Solution().solve(board);
  return;
  }
  solve_recursively(board); 
  solve_non_recursively(board); 
 }
 void construct(vector< vector<char> > &board, int row, int col) {
  srand(time(0));
  for(int i=0; i<row; i++){
  vector<char> line;
  for(int j=0; j<col; j++){
  if (i==0 || j==0 || i==row-1 || j==col-1) 
  line.push_back(rand()%3 ? 'X' : 'O'); 
  else
  line.push_back(rand()%2 ? 'X' : 'O'); 
  }
  board.push_back(line);
  }
 }
 void print(vector< vector<char> > &board) {
  for(int i=0; i<board.size(); i++){
  for(int j=0; j<board[i].size(); j++){
  cout << board[i][j] << "" "";
  }
  cout << endl;
  }
  cout << endl;
 }
 int main(int argc, char** argv )
 {
  int row, col;
  row = col = 6;
  if (argc>1){
  row = atoi(argv[1]);
  }
  if (argc>2){
  col = atoi(argv[2]);
  }
  vector< vector<char> > data;
  construct(data, row, col);
  print(data);
  solve(data);
  print(data);
  return 0;
 }"
448,448,"/**
  * Definition for singly-linked list.
  * struct ListNode {
  * int val;
  * ListNode *next;
  * ListNode(int x) : val(x), next(NULL) {}
  * };
  */
 class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  /*
  * Here we have two ways to solve this problem:
  * 1) keep the list's nodes no change. only swap the data in the list node.
  * 2) swap the list node physically.
  */
  ListNode *swapPairs(ListNode *head) {
  if(random()%2){
  return swapPairs1(head);
  }
  return swapPairs2(head);
  }
  /*just swap the node's value instead of node*/
  ListNode *swapPairs1(ListNode *head) {
  for (ListNode *p = head; p && p->next; p = p->next->next) {
  int n = p->val;
  p->val = p->next->val;
  p->next->val = n;
  }
  return head;
  }
  /*swap the list nodes physically*/ 
  ListNode *swapPairs2(ListNode *head) {
  ListNode *h = NULL;
  //using `*p` to traverse the linked list
  for (ListNode *p = head; p && p->next; p = p->next) {
  //`n` is `p`'s next node, and swap `p` and `n` physcially
  ListNode *n = p->next;
  p->next = n->next;
  n->next = p;
  //using `h` as `p`'s previous node
  if (h){
  h->next = n;
  }
  h=p;
  //determin the really 'head' pointer
  if (head == p){
  head = n;
  }
  }
  return head;
  }
  ListNode* swapPairs3(ListNode* head) {
  // Three pointers point current, previous and next node.
  ListNode *Curr=head, *Prev=NULL, *Next=NULL;
  while (Curr && Curr->next ) {
  Next = Curr->next;
  //swap nodes
  Curr->next = Next->next;
  Prev == NULL ? head = Prev = Next : Prev->next = Next;
  Next->next = Curr;
  //set the pointers to next place.
  Prev = Curr;
  Curr = Curr->next;
  }
  return head;
  }
 };"
449,449,"/**
  * Definition for binary tree
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Solution {
 public:
  Solution(){
  srand(time(NULL));
  }
  bool isSymmetric(TreeNode *root) {
  if (root == NULL ) return true;
  return isSymmetric(root->left, root->right);
  }
  bool isSymmetric(TreeNode *p, TreeNode *q){
  if (random()%2){
  return isSymmetric1(p, q);
  }
  return isSymmetric2(p, q);
  }
  bool isSymmetric1(TreeNode *p, TreeNode *q){
  if (p==NULL && q==NULL) return true;
  if (p==NULL || q==NULL) return false;
  return (p->val == q->val) &&
  isSymmetric(p->left, q->right) &&
  isSymmetric(p->right, q->left);
  }
  bool isSymmetric2(TreeNode *p, TreeNode *q){
  queue<TreeNode*> q1;
  queue<TreeNode*> q2;
  q1.push(p);
  q2.push(q);
  while(q1.size()>0 && q2.size()>0){
  TreeNode* p1 = q1.front();
  q1.pop();
  TreeNode* p2 = q2.front();
  q2.pop();
  if (p1==NULL && p2==NULL) continue;
  if (p1==NULL || p2==NULL) return false;
  if (p1->val != p2->val) return false;
  q1.push(p1->left);
  q2.push(p2->right);
  q1.push(p1->right);
  q2.push(p2->left);
  }
  return true;
  }
 };"
450,450,"***********************************************************************************/
 class Solution {
 public:
  int findTargetSumWays(vector<int>& nums, int S) {
  long int i,j,n,tot=0,sum,zero=0;
  n = nums.size();
  for(i=0;i<n;i++){
  tot+=nums[i];
  if(nums[i]==0){
  zero++;
  }
  }
  if((S+tot)%2!=0 || S>tot){
  return 0;
  }
  sum = (S+tot)/2;
  int dp[n+1][sum+1];
  for(i=1;i<=sum;i++){
  dp[0][i]= 0;
  }
  for(i=0;i<=n;i++){
  dp[i][0]= 1;
  }
  for(i=1;i<=n;i++){
  for(j=1;j<=sum;j++){
  if(nums[i-1]==0 || nums[i-1]>j){
  dp[i][j] = dp[i-1][j];
  }
  else{
  dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
  }
  }
  }
  return pow(2,zero)*dp[n][sum];
  }
 };"
451,451,"#include <math.h>
 #include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 vector<string> fullJustify(vector<string> &words, int L) {
  vector<string> result;
  int len=0;
  int start = 0;
  int end = 0;
  double space =0;
  bool lastLine = false;
  for (int i=0; i<words.size(); i++){
  len += words[i].size();
  if (len + i - start > L || i == words.size()-1) {
  //remove the last one
  if (len + i - start > L) { 
  len -= words[i].size();
  end = i-1;
  lastLine = false;
  }else{
  end = i;
  lastLine = true;
  }
  //calculate the space number
  space = L - len;
  int mspace;
  int extra;
  if (lastLine){
  mspace = 1;
  extra = 0;
  } else {
  mspace = floor(space/(end-start));
  extra = space - mspace * (end-start);
  }
  string line = words[start];
  for (int j=start+1; j<=end; j++) {
  for(int k=0; k<mspace && space>0; k++, space--) {
  line += "" "";
  } 
  if (j-start-1 < extra){
  line += "" "";
  space--;
  } 
  line += words[j];
  }
  //add the rest space
  if (space>0){
  for(; space>0; space--) {
  line += "" "";
  }
  }
  result.push_back(line);
  start = i;
  i = end;
  len = 0;
  } 
  }
  return result;
 }
 void printVector(vector<string> &words, bool newline=false) {
  for(int i=0; i<words.size(); i++) {
  cout << ""\"""" << words[i] << ""\"", "";
  if (newline) cout << endl; 
  }
  cout << endl;
 }
 void test(const char* A[], int len, int L) {
  vector<string> words(A, A+len);
  printVector(words);
  vector<string> result = fullJustify(words, L);
  cout << endl;
  printVector(result, true);
 }
 #define TEST(a, L) test(a, sizeof(a)/sizeof(const char*), L)
 int main(int argc, char** argv)
 {
  const char* w1[]={""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""};
  TEST(w1, 16); 
  const char* w2[] = {""What"",""must"",""be"",""shall"",""be.""}; 
  TEST(w2, 12);
  const char* w3[] = {""My"",""momma"",""always"",""said,"",""Life"",""was"",""like"",""a"",""box"",""of"",""chocolates."",""You"",""never"",""know"",""what"",""you're"",""gonna"",""get.""};
  TEST(w3, 20);
  return 0;
 }"
452,452,"/*
  * Sweep line with max-heap
  * ------------------------
  * Notice that ""key points"" are either the left or right edges of the buildings. 
  * 
  * Therefore, we first obtain both the edges of all the N buildings, and store the 2N edges in a sorted array. 
  * Maintain a max-heap of building heights while scanning through the edge array: 
  * 1) If the current edge is a left edge, then add the height of its associated building to the max-heap; 
  * 2) If the edge is a right one, remove the associated height from the heap. 
  * 
  * Then we take the top value of the heap (yi) as the maximum height at the current edge position (xi). 
  * Now (xi, yi) is a potential key point. 
  * 
  * If yi is the same as the height of the last key point in the result list, it means that this key point 
  * is not a REAL key point, but rather a horizontal continuation of the last point, so it should be discarded; 
  * 
  * otherwise, we add (xi,yi) to the result list because it is a real key point. 
  * 
  * Repeat this process until all the edges are checked.
  * 
  * It takes O(NlogN) time to sort the edge array. For each of the 2N edges, 
  * it takes O(1) time to query the maximum height but O(logN) time to add 
  * or remove elements. Overall, this solution takes O(NlogN) time.
  */
 class Solution {
 public:
  vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {
  vector< pair<int, int> > edges;
  //put all of edge into a vector
  //set left edge as negtive, right edge as positive
  //so, when we sort the edges, 
  // 1) for same left point, the height would be descending order
  // 2) for same right point, the height would be ascending order
  int left, right, height;
  for(int i=0; i<buildings.size(); i++) {
  left = buildings[i][0];
  right = buildings[i][1];
  height = buildings[i][2];
  edges.push_back(make_pair(left, -height));
  edges.push_back(make_pair(right, height));
  }
  sort(edges.begin(), edges.end());
  // 1) if we meet a left edge, then we add its height into a `set`.
  // the `set` whould sort the height automatically.
  // 2) if we meet a right edge, then we remove its height from the `set`
  //
  // So, we could get the current highest height from the `set`, if the 
  // current height is different with preivous height, then we need add
  // it into the result.
  vector< pair<int, int> > result;
  multiset<int> m;
  m.insert(0);
  int pre = 0, cur = 0;
  for (int i=0; i<edges.size(); i++){
  pair<int,int> &e = edges[i];
  if (e.second < 0) {
  m.insert(-e.second);
  }else{
  m.erase(m.find(e.second));
  }
  cur = *m.rbegin();
  if (cur != pre) {
  result.push_back(make_pair(e.first, cur));
  pre = cur;
  }
  }
  return result;
  }
 };"
453,453,"class Solution {
 public:
  int nMax(vector<int>& nums, int n) {
  set<int> topN;
  for(auto num : nums) {
  topN.insert(num);
  if (topN.size() > n) topN.erase(topN.begin());
  }
  return (topN.size() >= n) ? *(topN.begin()) : *(topN.rbegin());
  }
  int thirdMax(vector<int>& nums) {
  return nMax(nums, 3);
  }
 };"
454,454,"class Solution {
 public:
  string thousandSeparator(int n) {
  if (n==0) return ""0"";
  int cnt=0;
  string result;
  while( n > 0 ){
  int m = n % 10;
  result.insert(result.begin(), ('0' + m) );
  cnt++;
  n /= 10;
  if (cnt % 3 == 0 && n > 0) {
  result = '.' + result;
  }
  }
  return result;
  }
 };"
455,455,"class Solution {
 public:
  bool threeConsecutiveOdds(vector<int>& arr) {
  int cnt = 0;
  for (auto n : arr) {
  if ( n % 2 ) cnt++;
  else cnt = 0;
  if (cnt >=3) return true;
  }
  return false;
  }
 };"
456,456,"class TimeMap {
 private:
  unordered_map<string, std::set<int>> key_time;
  unordered_map<int, string> time_value;
 public:
  /** Initialize your data structure here. */
  TimeMap() {
  }
  void set(string key, string value, int timestamp) {
  key_time[key].insert(timestamp);
  time_value[timestamp] = value;
  }
  string get(string key, int timestamp) {
  if ( key_time.find(key) == key_time.end() ) return """";
  auto it = key_time[key].lower_bound(timestamp);
  if ( *it == timestamp ) return time_value[*it];
  if ( it != key_time[key].begin() ) {
  it--;
  return time_value[*it];
  }
  return """";
  }
 };
 /**
  * Your TimeMap object will be instantiated and called as such:
  * TimeMap* obj = new TimeMap();
  * obj->set(key,value,timestamp);
  * string param_2 = obj->get(key,timestamp);
  */"
457,457,"class Solution {
 public:
  vector<int>visited;
  long long int dfs(vector<vector<int>>& adj, vector<int>& informTime, int src, int n)
  {
  long long int count = 0;
  for(int i=0;i<adj[src].size();i++)
  {
  count = max(count,dfs(adj, informTime, adj[src][i], n));
  }
  return (informTime[src]+count);
  }
  int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {
  vector<vector<int>>adj(n);
  for(int i=0;i<manager.size();i++)
  {
  if(manager[i] != -1)
  adj[manager[i]].push_back(i);
  }
  long long int time;
  visited.resize(n,0);
  visited[headID] = 1;
  time= dfs(adj, informTime, headID, n);
  return time;
  }
 };"
458,458,"class Solution {
 public:
  struct element//structure consisting of every distinct number in the vector,
  //along with its frequency
  {
  int number, frequency;
  bool operator < (const element arg) const
  {
  return frequency < arg.frequency;
  }
  };
  priority_queue <element> sol;//we use a heap so we have all of the elements sorted
  //by their frequency
  vector <int> solution;
  vector<int> topKFrequent(vector<int>& nums, int k) {
  sort(nums.begin(), nums.end());
  int i = 1;
  for(; i < nums.size(); i++)
  {
  int freq = 1;
  while(i < nums.size() && nums[i] == nums[i - 1])
  {
  i++;
  freq++;
  }
  element el;
  el.number = nums[i - 1];
  el.frequency = freq;
  sol.push(el);
  }
  if(i == nums.size())//if we have 1 distinct element as the last
  {
  element el;
  el.number = nums[nums.size() - 1];
  el.frequency = 1;
  sol.push(el);
  }
  while(k)//we extract the first k elements from the heap
  {
  solution.push_back(sol.top().number);
  sol.pop();
  k--;
  }
  return solution;
  }
 };"
459,459,"/*
 * Solution 1 - O(N)
 *
 * The total Hamming Distance is equal to the sum of all individual Hamming Distances
 * between every 2 numbers. However, given that this depends on the individual bits of
 * each number, we can see that we only need to compute the number of 1s and 0s for each
 * bit position. For example, we look at the least significant bit. Given that we need to
 * calculate the Hamming Distance for each pair of 2 numbers, we see that the answer is
 * equal to the number of 1s at this position * the number of 0s(which is the total number
 * of numbers - the number of 1s), because for each 1 we need to have a 0 to form a pair.
 * Thus, the solution is the sum of all these distances at every position.
 */
 class Solution {
 public:
  int totalHammingDistance(vector<int>& nums) {
  long long solution = 0;
  int ones[31];
  for(int i = 0; i < 31; i++)
  ones[i] = 0;
  for(vector<int>::iterator it = nums.begin(); it != nums.end(); ++it)
  {
  for(int i = 0; (1 << i) <= *it; i++) //i is the position of the bit
  if((1 << i) & *it)//to see if the bit at i-position is a 1
  ones[i]++;
  }
  for(int i = 0; i < 31; i++)
  solution += ones[i] * (nums.size() - ones[i]);
  return solution;
  }
 };"
460,460,"#include <stdio.h>
 /*
  * The idea is:
  * 1) find the highest bar.
  * 2) traverse the bar from left the highest bar.
  * becasue we have the highest bar in right, so, any bar higher than its right bar(s) can contain the water.
  * 3) traverse the bar from right the highest bar.
  * becasue we have the highest bar in left, so, any bar higher than its left bar(s) can contain the water.
  *
  * The code below is quite clear!
  *
  */
 int trap(int a[], int n) {
  int result = 0;
  //find the highest value/position
  int maxHigh = 0;
  int maxIdx = 0;
  for(int i=0; i<n; i++){
  if (a[i] > maxHigh){
  maxHigh = a[i];
  maxIdx = i;
  }
  }
  //from the left to the highest postion
  int prevHigh = 0;
  for(int i=0; i<maxIdx; i++){
  if(a[i] > prevHigh){
  prevHigh = a[i];
  }
  result += (prevHigh - a[i]);
  }
  //from the right to the highest postion
  prevHigh=0;
  for(int i=n-1; i>maxIdx; i--){
  if(a[i] > prevHigh){
  prevHigh = a[i];
  }
  result += (prevHigh - a[i]);
  }
  return result;
 }
 #define TEST(a) printf(""%d\n"", trap(a, sizeof(a)/sizeof(int)))
 int main()
 {
  int a[]={2,0,2};
  TEST(a);
  int b[]={0,1,0,2,1,0,1,3,2,1,2,1};
  TEST(b);
  return 0;
 }"
461,461,"class Solution {
 private:
  // Euclidean algorithm
  // https://en.wikipedia.org/wiki/Euclidean_algorithm
  int gcd(int a, int b) {
  while (a != b ) { 
  if (a > b ) a -= b;
  else b -= a;
  }
  return a;
  }
  void print(vector<int>& v, int len, vector<int>& nums){
  cout << ""["";
  for(int i=0; i< len; i++) {
  cout << v[i] <<""(""<< nums[v[i]]<<""), "";
  }
  cout << v[len] <<""(""<<nums[v[len]]<<"")]""<< endl;
  }
 public:
  vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {
  unordered_map<int, vector<int>> graph;
  for(auto& edge : edges) {
  graph[edge[0]].push_back(edge[1]);
  graph[edge[1]].push_back(edge[0]);
  }
  int n = nums.size();
  vector<int> result(n, -1);
  vector<int> path(n, -1);
  path[0] = 0;
  // primePos[num] = {position, level};
  vector<vector<pair<int, int>>> primePos(51, vector<pair<int, int>>());
  getCoprimesDFS(-1, 0, nums, graph, path, 0, primePos, result);
  return result;
  }
  void getCoprimesDFS(int parent, int root,
  vector<int>& nums,
  unordered_map<int, vector<int>>& graph,
  vector<int>& path, int pathLen,
  vector<vector<pair<int, int>>>& primePos,
  vector<int>& result) {
  int max_level = -1;
  // find the previous closest prime 
  for(int n = 0; n < primePos.size(); n++) {
  auto& pos = primePos[n];
  // no position || not co-prime
  if ( pos.size() <=0 || gcd(nums[root], n) != 1) continue; 
  if (pos.back().second > max_level && pos.back().first != root) {
  max_level = pos.back().second;
  result[root] = pos.back().first;
  }
  }
  primePos[nums[root]].push_back({root, pathLen});
  for (auto& child : graph[root]) {
  if (child == parent) continue; // don't go back
  path[pathLen+1] = child; // for debug
  getCoprimesDFS(root, child, nums, graph, path, pathLen + 1, primePos, result);
  }
  primePos[nums[root]].pop_back();
  }
 };"
462,462,"#include <iostream>
 #include <vector>
 using namespace std;
 class Solution {
 public:
  int minimumTotal(vector<vector<int> > &triangle) {
  vector< vector<int> > v;
  for (int i=0; i<triangle.size(); i++){
  if(i==0){
  v.push_back(triangle[i]);
  continue;
  }
  vector<int> tmp;
  for(int j=0; j<triangle[i].size(); j++){
  int x, y, z;
  x = y = z = 0x7fff;
  if ( (j-1) >= 0){
  x = v[i-1][j-1];
  }
  if (j<v[i-1].size()) {
  y = v[i-1][j];
  }
  /* won't take the previous adjacent number */
  //if ( (j+1)<v[i-1].size()) {
  // z = v[i-1][j+1];
  //}
  tmp.push_back( min(x,y,z) + triangle[i][j] );
  }
  v.push_back(tmp);
  }
  int min=0x7fff;
  if (v.size() > 0){
  vector<int> &vb = v[v.size()-1];
  for(int i=0; i<vb.size(); i++){
  if (vb[i] < min ){
  min = vb[i];
  }
  }
  }
  return min;
  }
 private:
  inline int min(int x, int y, int z){
  int n = x<y?x:y;
  return (n<z?n:z);
  }
 };
 int main()
 {
  vector< vector<int> > v;
  vector<int> i;
  i.push_back(-1);
  v.push_back(i);
  i.clear();
  i.push_back(2);
  i.push_back(3);
  v.push_back(i);
  i.clear();
  i.push_back(1);
  i.push_back(-1);
  i.push_back(-3);
  v.push_back(i);
  Solution s;
  cout << s.minimumTotal(v) << endl;;
  v.clear();
  i.clear();
  i.push_back(-1);
  v.push_back(i);
  i.clear();
  i.push_back(3);
  i.push_back(2);
  v.push_back(i);
  i.clear();
  i.push_back(-3);
  i.push_back(1);
  i.push_back(-1);
  v.push_back(i);
  cout << s.minimumTotal(v) << endl;;
  return 0;
 }"
463,463,"class Solution {
 public:
  int countTriplets(vector<int>& A) {
  int n = A.size();
  //using a map to aggregate the duplication
  unordered_map<int, int> rec;
  for (int i=0; i<n; i++) {
  for (int j=0; j<n; j++) {
  rec[A[i] & A[j]]++;
  }
  }
  int result = 0;
  for (auto &r : rec ) {
  for (int k=0; k<n; k++) {
  if ((r.first & A[k]) == 0) result+=r.second;
  }
  }
  return result;
  }
 };"
464,464,"class Solution {
 private:
  bool isAlpha(const char& ch) {
  return (ch >='a' && ch <='z') || (ch >= 'A' && ch <='Z') ;
  }
 public:
  string truncateSentence(string s, int k) {
  s += ' '; //for edge case
  bool wordStart = false;
  int i=0;
  for (; i< s.size(); i++) {
  if (!wordStart && isAlpha(s[i])) {
  wordStart = true;
  }else if (wordStart && !isAlpha(s[i])) {
  if (--k <= 0) break;
  wordStart = false;
  }
  }
  return s.substr(0, i);
  }
 };"
465,465,"class Solution {
 public:
  int tupleSameProduct(vector<int>& nums) {
  unordered_map<int, int> stat;
  for(int i = 0; i < nums.size(); i++) {
  for ( int j = i+1; j < nums.size(); j++) {
  stat[nums[i]*nums[j]]++;
  }
  }
  int result = 0;
  for ( auto [n, cnt] : stat) {
  if (cnt > 1) result += cnt*2 * (cnt-1)*2;
  }
  return result;
  }
 };"
466,466,"class Solution {
 public:
  // This problem could transfer to check two array has exactly same numbers
  bool canBeEqual(vector<int>& target, vector<int>& arr) {
  int len1 = target.size();
  int len2 = arr.size();
  if (len1 != len2) return false;
  if (len1 == 0) return true;
  unordered_map<int, int> stat;
  for (int i=0; i<len1; i++) {
  stat[target[i]]++;
  stat[arr[i]]--;
  }
  for (auto& s:stat) {
  if (s.second !=0 ) return false;
  }
  return true;
  }
 };"
467,467,"class Solution {
 private:
  static int diff(vector<int>& x) {
  return x[1] - x[0];
  }
  static bool cmpfunc(vector<int>& lhs, vector<int>& rhs) {
  return diff(lhs) > diff(rhs);
  }
 public:
  // Just simply sort the array by comparing the different cost go to A city and B city
  // then the bigger difference would be in left and right side, and the smaller difference would be in the middle
  // We could simply let the first half go to A city, and the second half go to B city.
  int twoCitySchedCost(vector<vector<int>>& costs) {
  sort(costs.begin(), costs.end(), cmpfunc);
  int result = 0;
  int len = costs.size();
  for (int i=0; i<len/2; i++) {
  result += (costs[i][0] + costs[len-i-1][1]);
  }
  return result;
  }
 };"
468,468,"class Solution {
 public:
  /*
  * The easy solution is O(n^2) run-time complexity.
  * ```
  * foreach(item1 in array) {
  * foreach(item2 in array){
  * if (item1 + item2 == target) {
  * return result
  * }
  * }
  * ```
  * 
  * We can see the nested loop just for searching, 
  * So, we can use a hashmap to reduce the searching time complexity from O(n) to O(1)
  * (the map's `key` is the number, the `value` is the position)
  * 
  * But be careful, if there are duplication numbers in array, 
  * how the map store the positions for all of same numbers?
  *
  */
  //
  // The implementation as below is bit tricky. but not difficult to understand
  //
  // 1) Traverse the array one by one
  // 2) just put the `target - num[i]`(not `num[i]`) into the map
  // so, when we checking the next num[i], if we found it is exisited in the map.
  // which means we found the second one.
  // 
  vector<int> twoSum(vector<int> &numbers, int target) {
  unordered_map<int, int> m;
  vector<int> result;
  for(int i=0; i<numbers.size(); i++){
  // not found the second one
  if (m.find(numbers[i])==m.end() ) { 
  // store the first one poisition into the second one's key
  m[target - numbers[i]] = i; 
  }else { 
  // found the second one
  result.push_back(m[numbers[i]]+1);
  result.push_back(i+1);
  break;
  }
  }
  return result;
  }
  // we also can store nums[i] into map, and find target - nums[i]
  vector<int> twoSum(vector<int>& nums, int target) {
  unordered_map<int, int> m;
  vector<int> result;
  for (int i=0; i<nums.size(); i++) {
  if ( m.find(target - nums[i]) == m.end() ) {
  m[nums[i]] = i;
  }else{
  result.push_back(m[target - nums[i]]);
  result.push_back(i);
  }
  }
  return result;
  }
 };"
469,469,"class Solution {
 public:
  vector<int> twoSum(vector<int> &numbers, int target) {
  vector<int> result;
  int low=0, high = numbers.size()-1;
  while (low < high){
  if (numbers[low] + numbers[high] == target){
  result.push_back(low+1);
  result.push_back(high+1);
  return result;
  }else{
  numbers[low] + numbers[high] > target ? high-- : low++;
  }
  }
  return result;
  }
 };"
470,470,"class TwoSum {
  private:
  unordered_map<int, int> nums;
  public:
  //O(1) add
  void add(int number) {
  nums[number]++;
  }
  //O(n) find
  bool find(int value) {
  int one, two;
  for(auto it = nums.begin(); it != nums.end(); it++){
  one = it->first;
  two = value - one;
  if ( (one == two && it->second > 1) ||
  (one != two && nums.find(two) != nums.end() ) ){
  return true;
  }
  }
  return false;
  }
 };"
471,471,"class Solution {
 public:
  //greeting algorithm
  bool isUgly(int num) {
  if ( num == 0 ) return false;
  if ( num == 1 ) return true;
  //becasue the 2,3,5 are prime numbers, so, we just simply remove each factors 
  //by keeping dividing them one by one 
  while ( num % 2 == 0 ) num /= 2;
  while ( num % 3 == 0 ) num /= 3;
  while ( num % 5 == 0 ) num /= 5;
  return num == 1;
  }
 };"
472,472,"class Solution {
 public:
  int min(int a, int b) {
  return a < b ? a:b;
  }
  int min(int a, int b, int c) {
  return min( min(a, b), c);
  }
  // 
  // The idea is we generate the ugly number instead of checking every number.
  //
  // To generate the next ugly number, we can use the existed ugly numbers to multipy 2,3,5,
  // and get the minimal one.
  //
  // Let's start from the first ugly number - [1]
  //
  // [1] next = min( 1*2=2, 1*3=3, 1*5=5) = 2
  //
  // Now we have [1,2], we can see, only the second one need be multipied by 2
  // but both 3 and 5 still need be multipied by first one. So:
  // 
  // [1,2] next = min(2*2=4, 1*3=3, 1*5=5) = 3
  //
  // Now we have [1,2,3], we can see the second one need be mulityped by 2 and 3,
  // but the 5 still needs be multipied by first one. So:
  //
  // [1,2,3] next = min (2*2, 2*3, 1*5) = 4
  //
  // and so on...
  //
  // So, we can see we need to maintain three indics in ugly number list, 
  // each one represents the place need be mulipied by 2,3,5.
  //
  // And we increase the index who's multiplication is the minimal. 
  //
  int nthUglyNumber01(int n) {
  int i=0, j=0, k=0;
  vector<int> v(1,1);
  while(v.size() < n){
  int next = min(v[i]*2, v[j]*3, v[k]*5);
  if (next == v[i]*2) i++;
  if (next == v[j]*3) j++;
  if (next == v[k]*5) k++;
  v.push_back(next);
  }
  return v.back();
  }
  // This version just uses the static variable to cache 
  // the 3 indics and the ugly number list
  int nthUglyNumber02(int n) {
  static int i=0, j=0, k=0;
  static vector<int> v(1,1);
  if (v.size()>=n) return v[n-1];
  while(v.size() < n){
  int next = min(v[i]*2, v[j]*3, v[k]*5);
  if (next == v[i]*2) i++;
  if (next == v[j]*3) j++;
  if (next == v[k]*5) k++;
  v.push_back(next);
  }
  return v.back();
  }
  int nthUglyNumber(int n) {
  return nthUglyNumber02(n); // 4ms-8ms
  return nthUglyNumber01(n); // 28ms
  }
 };"
473,473,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 int numTrees1(int n) ;
 int numTrees2(int n) ;
 int numTrees(int n) {
  return numTrees1(n);
 }
 int numTrees1(int n) {
  int *cnt = (int*)malloc((n+1)*sizeof(int));
  memset(cnt, 0, (n+1)*sizeof(int));
  cnt[0] = 1;
  cnt[1] = 1;
  for (int i=2; i<=n; i++){
  for(int j=0; j<i; j++){
  cnt[i] += cnt[j]*cnt[i-j-1];
  }
  }
  int sum = cnt[n];
  free(cnt);
  return sum;
 }
 int numTrees2(int n) {
  if (n<=0) return 0;
  if (n == 1 ) return 1;
  int sum=0;
  for (int i=1; i<=n; i++){
  if (i==1||i==n){
  sum += numTrees(n-1);
  }else{
  sum += (numTrees(i-1) * numTrees(n-i));
  }
  }
  return sum;
 }
 int main(int argc, char** argv) 
 {
  int n=2;
  if (argc>1){
  n = atoi(argv[1]);
  }
  printf(""%d=%d\n"", n, numTrees(n));
  return 0;
 }"
474,474,"#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <vector>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 vector<TreeNode*> generateTrees(int low, int high);
 vector<TreeNode*> generateTrees(int n) {
  vector<TreeNode*> v;
  v = generateTrees(1, n);
  return v;
 }
 vector<TreeNode*> generateTrees(int low, int high){
  vector<TreeNode*> v;
  if (low > high || low<=0 || high<=0){
  v.push_back(NULL);
  return v;
  }
  if (low==high){
  TreeNode* node = new TreeNode(low);
  v.push_back(node); 
  return v;
  }
  for (int i=low; i <= high; i++){
  vector<TreeNode*> vleft = generateTrees(low, i-1);
  vector<TreeNode*> vright = generateTrees(i+1, high);
  for (int l=0; l<vleft.size(); l++){
  for (int r=0; r<vright.size(); r++){
  TreeNode *root = new TreeNode(i);
  root->left = vleft[l];
  root->right = vright[r];
  v.push_back(root);
  }
  }
  }
  return v;
 }
 void printTree(TreeNode *root){
  if (root == NULL){
  printf(""# "");
  return;
  }
  printf(""%d "", root->val );
  printTree(root->left);
  printTree(root->right);
 }
 int main(int argc, char** argv) 
 {
  int n=2;
  if (argc>1){
  n = atoi(argv[1]);
  }
  vector<TreeNode*> v = generateTrees(n);
  for(int i=0; i<v.size(); i++){
  printTree(v[i]);
  printf(""\n"");
  }
  return 0;
 }"
475,475,"class Solution {
 public:
  int numUniqueEmails(vector<string>& emails) {
  unordered_map<string, int> dict;
  for (auto& email : emails) {
  string addr;
  for(int i=0; i<email.size(); i++) {
  if (email[i] == '.' ) continue;
  if (email[i] == '+') {
  while( email[++i] != '@');
  }
  if (email[i] =='@') {
  addr += email.substr(i);
  break;
  }
  addr += email[i];
  }
  dict[addr]++;
  }
  return dict.size();
  }
 };"
476,476,"class Solution {
 public:
  int uniqueMorseRepresentations(vector<string>& words) {
  string MorseTable[26] = {"".-"",""-..."",""-.-."",""-.."",""."",""..-."",""--."",
  ""...."","".."","".---"",""-.-"","".-.."",""--"",""-."",
  ""---"","".--."",""--.-"","".-."",""..."",""-"",""..-"",
  ""...-"","".--"",""-..-"",""-.--"",""--..""};
  unordered_map<string, bool> transformations;
  for (auto word : words) {
  string morse;
  for (auto ch : word) {
  morse += MorseTable[ ch - 'a' ];
  }
  transformations[morse]=true;
  }
  return transformations.size();
  }
 };"
477,477,"class Solution {
 public:
  bool uniqueOccurrences(vector<int>& arr) {
  map<int,int>myMap;
  for(int i=0;i<arr.size();i++){
  myMap[arr[i]]++;
  }
  int temp=0;
  vector<int>v;
  for (auto i : myMap) {
  v.push_back(i.second);
  }
  sort(v.begin(),v.end());
  for(int i=0;i<v.size();i++){
  if(v[i]==temp)
  return false;
  else
  temp=v[i];
  }
  return true;
  }
 };"
478,478,"#ifdef CSTYLE
 #include <stdio.h>
 #include <stdlib.h>
 void printMatrix(int*a, int m, int n)
 {
  for (int i=0; i<m; i++){
  for (int j=0; j<n; j++){
  printf(""%4d "", a[i*n+j]);
  }
  printf(""\n"");
  }
  printf(""\n"");
 }
 /*
  * Dynamic Programming
  *
  * We have a dp[i][j] represents how many paths from [0][0] to hear. So, we have the following DP formuler:
  *
  * dp[i][j] = 1 if i==0 || j==0 //the first row/column only have 1 uniqe path.
  * = dp[i-1][j] + dp[i][j-1] //the path can be from my top cell and left cell.
  */
 // using C style array
 int uniquePaths(int m, int n) {
  int* matrix = new int[m*n];
  printMatrix(matrix, m, n);
  for (int i=0; i<m; i++){
  for (int j=0; j<n; j++){
  if(i==0 || j==0){
  matrix[i*n+j]=1;
  }else{
  matrix[i*n+j] = matrix[(i-1)*n+j] + matrix[i*n+j-1];
  }
  }
  } 
  printMatrix(matrix, m, n);
  int u = matrix[m*n-1];
  delete[] matrix;
  return u;
 }
 #else
 #include <vector>
 using namespace std;
 // using C++ STL vector , the code is much easy to read
 int uniquePaths(int m, int n) {
  vector< vector <int> > dp (n, vector<int>(m, 1));
  for (int row=1; row<n; row++) {
  for (int col=1; col<m; col++) {
  dp[row][col] = dp[row-1][col] + dp[row][col-1];
  }
  }
  return dp[n-1][m-1];
 }
 #endif
 int main(int argc, char** argv)
 {
  int m=3, n=7;
  if( argc>2){
  m = atoi(argv[1]);
  n = atoi(argv[2]);
  }
  printf(""uniquePaths=%d\n"", uniquePaths(m,n));
  return 0;
 }"
479,479,"#include <iostream>
 #include <vector>
 using namespace std;
 //As same as DP solution with ""Unique Path I"", just need to consider the obstacles.
 int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
  vector<vector<unsigned int>> v (row, vector<unsigned int>(col, 0));
  unsigned int max=0;
  for (int i=0; i<obstacleGrid.size(); i++){
  for (int j=0; j<obstacleGrid[0].size(); j++){
  if(obstacleGrid[i][j] == 1){
  max = v[i][j] = 0;
  } else {
  if (i>0 && j>0) {
  max= v[i][j] = v[i-1][j] + v[i][j-1];
  }else if(i>0){
  max = v[i][j] = v[i-1][j];
  }else if(j>0){
  max = v[i][j] = v[i][j-1];
  }else{
  max = v[i][j] = 1 ;
  }
  }
  }
  }
  return max;
 }
 // the previous implemetation has too many if-else
 // the following dynamic programming is much more easy to read
 int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
  int row = obstacleGrid.size();
  int col = obstacleGrid[0].size();
  vector< vector <unsigned int> > dp (row, vector<unsigned int>(col, 0));
  dp[0][0] = obstacleGrid[0][0] ? 0 : 1;
  for (int r=1; r<row; r++) {
  dp[r][0] = obstacleGrid[r][0] ? 0 : dp[r-1][0];
  }
  for (int c=1; c<col; c++) {
  dp[0][c] = obstacleGrid[0][c] ? 0 : dp[0][c-1];
  }
  for (int r=1; r<row; r++) {
  for (int c=1; c<col; c++) {
  dp[r][c] = obstacleGrid[r][c] == 1 ? 0 : dp[r][c-1] + dp[r-1][c];
  }
  }
  return dp[row-1][col-1];
 }"
480,480,"class Solution {
 public:
  int uniquePathsIII(vector<vector<int>>& grid) {
  int path = 0;
  int startX, startY;
 if (!findStartPoint( grid, startX, startY)) return 0;
  uniquePathsHelper(grid, startX, startY, path);
  return path;
  }
  bool findStartPoint(vector<vector<int>> &grid, int& x, int& y) {
  for(int i=0; i<grid.size(); i++) {
  for(int j=0; j<grid[0].size(); j++) {
  if (grid[i][j] == 1) {
  x = i; y =j;
  return true;
  }
  }
  }
  return false;
  }
  bool check(vector<vector<int>> &grid ) {
  for(int i=0; i<grid.size(); i++) {
  for(int j=0; j<grid[0].size(); j++) {
  if (grid[i][j] == 0 ) return false;
  }
  }
  return true;
  }
  void uniquePathsHelper(vector<vector<int>> &grid, int x, int y, int& path ) {
  if (x < 0 || y < 0 || x>= grid.size() || y>=grid[0].size()) return;
  if ( grid[x][y] < 0) return;
  if ( grid[x][y] == 2) { 
  if (check(grid)) path++;
  return;
  }
  //back tracing - mark -2 means already passed.
  grid[x][y] = -2;
  uniquePathsHelper(grid, x, y-1, path); // up
  uniquePathsHelper(grid, x, y+1, path); // down
  uniquePathsHelper(grid, x+1, y, path); // right
  uniquePathsHelper(grid, x-1, y, path); // left
  grid[x][y] = 0;
  }
 };"
481,481,"class Solution {
 public:
  bool validUtf8(vector<int>& data) {
  int i = 0;
  while ( i < data.size() ) {
  if ( (data[i] & 0x80) == 0 ){
  i++;
  continue;
  }
  int len = 0;
  if ( (data[i] & 0xE0) == 0xC0 ) { // checking 110xxxxx
  len = 2;
  }else if ( (data[i] & 0xF0) == 0xE0) { // checking 1110xxxx
  len = 3;
  }else if ( (data[i] & 0xF8) == 0xF0) { // checking 11110xxx
  len = 4;
  }else {
  return false;
  }
  for (int j=i+1; j < i+len; j++) { //checking 10xxxxxx
  if ( (data[j] & 0xC0) != 0x80 ) {
  return false;
  }
  }
  i += len ;
  if (i > data.size()) {
  return false;
  }
  }
  return true;
  }
 };"
482,482,"#include <iostream>
 #include <vector>
 using namespace std;
 struct TreeNode {
  int val;
  TreeNode *left;
  TreeNode *right;
  TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };
 bool isValidBST(TreeNode *root) {
  //travel the tree by inner-order
  vector<TreeNode*> stack;
  TreeNode* node = root;
  vector<int> v;
  while (stack.size()>0 || node!=NULL) {
  if (node!=NULL){
  stack.push_back(node);
  node = node->left;
  }else{
  node = stack.back();
  stack.pop_back();
  v.push_back(node->val);
  node = node->right;
  }
  }
  //check the vector wehther sorted or not
  for(int i=0; v.size()>0 && i<v.size()-1; i++){
  if (v[i] >= v[i+1]) {
  return false;
  }
  }
  return true;
 }
 TreeNode* createTree(int a[], int n)
 {
  if (n<=0) return NULL;
  TreeNode **tree = new TreeNode*[n];
  for(int i=0; i<n; i++) {
  if (a[i]==0 ){
  tree[i] = NULL;
  continue;
  }
  tree[i] = new TreeNode(a[i]);
  }
  int pos=1;
  for(int i=0; i<n && pos<n; i++) {
  if (tree[i]){
  tree[i]->left = tree[pos++];
  if (pos<n){
  tree[i]->right = tree[pos++];
  }
  }
  }
  return tree[0];
 }
 int main()
 {
  cout << isValidBST(NULL) << endl;
  int a[]={1,1};
  cout << isValidBST(createTree(a, sizeof(a)/sizeof(int))) << endl;
  int b[]={4,2,6,1,7,5,7};
  cout << isValidBST(createTree(b, sizeof(b)/sizeof(int))) << endl;
  int c[]={4,2,6,1,3,5,7};
  cout << isValidBST(createTree(c, sizeof(c)/sizeof(int))) << endl;
  return 0;
 }"
483,483,"#include <iostream>
 using namespace std;
 bool isdigit(const char c){
  return (c>='0' && c<='9');
 }
 bool isspace(const char c) {
  return (c==' ' || c =='\t' || c=='\n' || c=='\r' || c=='\f' || c=='\v');
 }
 bool isNumber(const char *s) {
  bool point = false;
  bool hasE = false;
  //trim the space
  while(isspace(*s)) s++;
  //check empty 
  if (*s == '\0' ) return false;
  //check sign
  if (*s=='+' || *s=='-') s++;
  const char *head = s;
  for(; *s!='\0'; s++){
  // if meet point
  if ( *s == '.' ){
  if ( hasE == true || point == true){
  return false;
  }
  if ( s == head && !isdigit(*(s+1)) ){
  return false;
  }
  point = true; 
  continue; 
  }
  //if meet ""e""
  if ( *s == 'e' ){
  if ( hasE == true || s == head) {
  return false;
  }
  s++;
  if ( *s=='+' || *s=='-' ) s++;
  if ( !isdigit(*s) ) return false;
  hasE = true; 
  continue; 
  }
  //if meet space, check the rest chars are space or not
  if (isspace(*s)){
  for (; *s != '\0'; s++){
  if (!isspace(*s)) return false;
  }
  return true;
  }
  if ( !isdigit(*s) ) {
  return false;
  }
  }
  return true; 
 }
 #define TEST(s) cout << ""\"""" << s << ""\"""" << "" : "" << isNumber(s) << endl
 int main(int argc, char** argv)
 {
  const char* s=""123"";
  if(argc>1){
  s = argv[1];
  }
  TEST(s);
  TEST(""1.044"");
  TEST("" 1.044 "");
  TEST(""1.a"");
  TEST(""abc"");
  TEST(""e"");
  TEST(""1e"");
  TEST(""1e2"");
  TEST("""");
  TEST("" "");
  TEST(""1."");
  TEST("".2"");
  TEST("" . "");
  TEST(""."");
  TEST(""1.2.3"");
  TEST(""1e2e3"");
  TEST(""1.."");
  TEST(""+1."");
  TEST("" -1."");
  TEST(""6e6.5"");
  TEST(""005047e+6"");
  return 0;
 }"
484,484,"class Solution {
 public:
  bool isPalindrome(string s) {
  s = removeNoise(s);
  for(int i=0; i<s.size()/2; i++){
  if (s[i]!= s[s.size()-i-1]){
  return false;
  }
  }
  return true;
  }
  string removeNoise(string& s){
  string d;
  for(int i=0; i<s.size(); i++){
  if(::isalpha(s[i]) || ::isdigit(s[i])){
  d.push_back(::tolower(s[i]));
  }
  }
  return d;
  }
 };"
485,485,"#include <iostream>
 #include <string>
 #include <stack>
 using namespace std;
 bool isValid(string s) {
  stack<char> st;
  for(auto ch : s) {
  if (ch=='{' || ch =='[' || ch=='(' ) {
  st.push(ch);
  }else if (ch=='}' || ch ==']' || ch == ')' ){
  if (st.empty()) return false;
  char sch = st.top();
  if ( (sch=='{' && ch =='}') || (sch=='[' && ch==']') || (sch=='(' && ch==')' ) ){
  st.pop();
  }else {
  return false;
  }
  }else{
  return false;
  }
  }
  return st.empty();
 }
 int main(int argc, char**argv)
 {
  string s = ""{{}{[]()}}"";
  if (argc>1){
  s = argv[1];
  }
  cout << ""str = \"""" << (s) << ""\"""" << endl;
  cout << isValid(s) << endl;
 }"
486,486,"class Solution {
 public:
  // time limited error for the MAX_INT.
  bool isPerfectSquare1(int num) {
  //binary searching...
  int left = 0, right = num;
  while (left <= right) {
  //cout << left << "","" << right << endl;
  int mid = left + (right - left)/2;
  int n = mid * mid;
  if ( n == num) return true;
  if ( n < num ) left = mid + 1;
  else right = mid - 1;
  }
  return false; 
  }
  // the stupid way is best & fast.
  bool isPerfectSquare2(int num) {
  for (int i=1; i <= num/i ; i++ ) {
  if ( i*i == num) return true;
  }
  return false;
  }
  bool isPerfectSquare(int num) {
  return isPerfectSquare2(num);
  return isPerfectSquare1(num);
  }
 };"
487,487,"class Solution {
 public:
  bool isValidSudoku(vector<vector<char> > &board) {
  const int cnt = 9;
  bool row_mask[cnt][cnt] = {false};
  bool col_mask[cnt][cnt] = {false};
  bool area_mask[cnt][cnt] = {false};
  //check each rows and cols
  for(int r=0; r<board.size(); r++){
  for (int c=0; c<board[r].size(); c++){
  if (!isdigit(board[r][c])) continue;
  int idx = board[r][c] - '0' - 1;
  //check the rows
  if (row_mask[r][idx] == true){
  return false;
  }
  row_mask[r][idx] = true;
  //check the cols
  if (col_mask[c][idx] == true) {
  return false;
  }
  col_mask[c][idx] = true;
  //check the areas
  int area = (r/3) * 3 + (c/3);
  if (area_mask[area][idx] == true) {
  return false;
  }
  area_mask[area][idx] = true;
  }
  }
  return true;
  }
 };"
488,488,"class Solution {
 public:
  // we know the following facts:
  // 1) if we met a non-null node, then this node will generate two child node.
  // 2) if we met a null node, then this node will generate zero child node.
  //
  // so the idea is, 
  // 1) we can have a counter to calculate how many node we are going to expect 
  // 2) once we have the expected node, then we can decrease the counter.
  // 3) finally, we will check the counter is zero or not.
  //
  // the algorithm as below:
  // 1) when we meet a non-null node, just simply do `counter++`. because:
  // 1.1) we will expect 2 more node after, then we do `counter += 2`. 
  // 1.2) but the current node also meet the expection of parent node , so, it need remove 1 in counter.
  // finally, the `counter = counbter + 2 -1`
  // 2) when we meet a null node, just simply do `counter--`.
  bool isValidSerialization(string preorder) {
  vector<string> list;
  split(preorder, ',', list);
  //we initailize the counter as 1, 
  //because we expect at lease 1 node in the tree.
  int node_expected = 1;
  for (auto node : list) {
  if (node_expected == 0) return false;
  node == ""#"" ? node_expected-- : node_expected++;
  }
  return node_expected == 0;
  }
  void split(const string &s, char delim, vector<string> &elems) {
  stringstream ss(s);
  string item;
  while (getline(ss, item, delim)) {
  elems.push_back(item);
  }
  }
 };"
489,489,"/**
  * Definition for a binary tree node.
  * struct TreeNode {
  * int val;
  * TreeNode *left;
  * TreeNode *right;
  * TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  * };
  */
 class Item {
 public:
  Item(int _x, int _y, int _val):x(_x), y(_y),val(_val) {}
  int x, y;
  int val;
 };
 class ItemCmp {
 public:
  bool operator () (const Item &lhs, const Item &rhs) const {
  return lhs.y != rhs.y ? lhs.y > rhs.y : lhs.val < rhs.val;
  }
 };
 int getValue(const Item& i) {
  return i.val;
 }
 class Solution {
 public:
  vector<vector<int>> verticalTraversal(TreeNode* root) {
  set<int> rows;
  unordered_map<int, set<Item, ItemCmp>> m;
  verticalTraversalHelper(root, 0, 0, rows, m);
  vector<vector<int>> result;
  for(auto r : rows) {
  vector<int> v;
  transform(m[r].begin(), m[r].end(), back_inserter(v), getValue);
  result.push_back(v);
  }
  return result;
  }
  void verticalTraversalHelper(TreeNode* root, int x, int y,
  set<int>& rows,
  unordered_map<int, set<Item, ItemCmp>>& m) {
  if ( !root ) return;
  rows.insert(x);
  m[x].insert(Item(x, y, root->val));
  verticalTraversalHelper(root->left, x-1, y-1, rows, m); //left
  verticalTraversalHelper(root->right, x+1, y-1, rows, m); //right
  }
 };"
490,490,"class Solution {
 public:
  int videoStitching(vector<vector<int>>& clips, int T) {
  //sort the clips
  std::sort(clips.begin(), clips.end(), [](vector<int>& x, vector<int>& y) {
  return x[0] < y[0] || (x[0] == y[0] && x[1] < y[1]);
  });
  //print(clips);
  // dynamic programming
  // dp[i] is the minmal clips from [o,i]
  vector<int> dp(T+1, -1);
  for (auto c : clips) {
  //edge case: out of the range
  if (c[0] > T) continue;
  // if clip is started from 0, then just simple initalize to 1
  if (c[0] == 0) {
  for (int i=c[0]; i<=min(T,c[1]); i++) dp[i] = 1;
  continue;
  }
  //if clip is not started from 0, seprate the range to two parts
  //the first part is the greater than 0, then second part is -1
  // 1) for the first part, need figure the minimal number
  // 2) for the second part, just simple add 1 with minimal number of first part.
  if (dp[c[0]] == -1 ) continue;
  int m = dp[c[0]];
  for (int i = c[0] + 1; i<= min(T, c[1]); i++) {
  if ( dp[i] > 0 ) m = min(m, dp[i]);
  else dp[i] = m + 1;
  }
  }
  //print(dp);
  return dp[T];
  }
  //used for debug
  void print(vector<vector<int>>& clips) {
  for (auto c : clips) {
  cout << ""["" << c[0] <<"",""<< c[1] << ""]""<< "" "";
  }
  cout << endl;
  }
  void print(vector<int>& v) {
  for (auto i : v) {
  cout << i << "", "";
  }
  cout << endl;
  }
 };"
491,491,"const int MOD = (int) (1e9 + 7);
 class Solution {
 public:
  int waysToSplit(vector<int>& nums) {
  int len = nums.size();
  vector<int> presum(len, 0);
  presum[0] = nums[0];
  for(int i=1; i<nums.size(); i++){
  presum[i] = presum[i-1] + nums[i];
  }
  return waysToSplit_BS(presum); // Binary Search
  //return waysToSplit_TLE(presum); // Time Limit Error
  }
  int binary_search(vector<int>& presum, int left, int i, bool searchLeft ) {
  int len = presum.size();
  int l = i, r = len-1;
  int res = -1;
  while(l <= r) {
  int m = l + (r - l) / 2;
  // if search Left, let middle item belong to left
  // if search Right, let middle item belong to right
  int x = searchLeft? 0 : 1; 
  int right = presum[len-1] - presum[m-x];
  int mid = presum[m-x] - presum[i-1];
  if (left <= mid && mid <= right) {
  res = m;
  if (searchLeft) r = m - 1;
  else l = m + 1;
  }else if (left > mid) {
  l = m + 1;
  }else {
  r = m -1;
  }
  }
  return res;
  }
  int waysToSplit_BS(vector<int>& presum) {
  int len = presum.size();
  long cnt = 0;
  for(int i=0; i<len-2; i++){
  if (presum[i] > (presum[len-1] - presum[i]) / 2) break;
  //find the most right position
  long l = binary_search(presum, presum[i], i+1, true);
  //find the most right position
  long r = binary_search(presum, presum[i], i+1, false);
  if (l == -1 || r == -1 ) continue;
  cnt += (r-l);
  //cout << i << "" - ["" << l << "","" << r << ""]"" << endl;
  } 
  //cout << endl;
  return cnt % MOD;
  }
  int waysToSplit_TLE(vector<int>& presum) {
  int len = presum.size();
  int cnt = 0;
  int left, mid, right;
  for(int i=0; i<len-2; i++){
  left = presum[i];
  for (int j=i+1; j<len-1; j++) {
  mid = presum[j] - presum[i];
  right = presum[len-1] - presum[j];
  if (left <= mid && mid <= right) {
  cnt++;
  }
  }
  } 
  return cnt;
  }
 };"
492,492,"class Solution {
 public:
  //
  // Solution - O(N*logN)
  // --------------------
  // 1) Sorting the array with descending order
  //
  // 2) Split the sorted array into two parts,
  // and insert the 2nd half array into the 1st half array
  //
  // For example: [ 9 8 7 6 5 4 3 2 1 0 ]
  //
  // 
  // 1st Large half: . 9 . 8 . 7 . 6 . 5
  // 2nd Small half: 4 . 3 . 2 . 1 . 0 .
  // ---------------------------------------
  // Result: 4 9 3 8 2 7 1 6 0 5
  //
  // Be careful if the length of array is odd number, 
  // Such as: [5 4 3 2 1], 
  // The 2nd half is [3 2 1] instead of [2 1]
  // 
  void wiggleSort01(vector<int>& nums) {
  sort(nums.begin(), nums.end(), [](int x, int y) { return x > y; });
  int half = (nums.size() / 2);
  for (int i=0; i<half; i++) {
  int v = nums[half+i];
  nums.erase(nums.begin() + half + i );
  nums.insert(nums.begin() + (2*i), v);
  }
  cout << endl;
  }
  //
  // After checked the discussion of Leetcode, I found there is a really brilliant idea
  // which used a tricky idea - virtual index.
  // 
  // Please refer to the following link to see the full details:
  // https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing
  void wiggleSort02(vector<int>& nums) {
  int n = nums.size();
  // Find a median.
  auto midptr = nums.begin() + n / 2;
  nth_element(nums.begin(), midptr, nums.end());
  int mid = *midptr;
  // Index-rewiring.
  #define A(i) nums[(1+2*(i)) % (n|1)]
  // 3-way-partition-to-wiggly in O(n) time with O(1) space.
  int i = 0, j = 0, k = n - 1;
  while (j <= k) {
  if (A(j) > mid)
  swap(A(i++), A(j++));
  else if (A(j) < mid)
  swap(A(j), A(k--));
  else
  j++;
  }
  }
  void wiggleSort(vector<int>& nums) {
  return wiggleSort02(nums); //~140ms
  return wiggleSort01(nums); //~230ms
  }
 };"
493,493,"/* Solution
  * --------
  * 1) O(N)
  * 
  * We notice that adding a new number to an existing subsequence means finding one that
  * is smaller or bigger than the previous number, according to the difference between the
  * previous number and the number before that as we always need to alternate between increasing
  * and decreasing subsequences. If we encounter increasing or decreasing sequences of 2 or 
  * more consecutive numbers we can treat the entire subsequence as a number, because that way 
  * we can always be sure we don't miss any solution, as finding a number smaller than any 
  * number of an increasing subsequence is guaranteed to be smaller than the biggest number 
  * in the subsequence. Thus, we can only check the difference between consecutive numbers.
  * 
  * Follow up:
  * 
  * The time complexity is already O(N).
  */
 class Solution {
 public:
  int wiggleMaxLength(vector<int>& nums) {
  int solution = 0;//if we have an empty vector the solution is 0
  if(nums.size())
  {
  solution = 1;
  int bigger = 0;//0 is the starting point to be followed by either an increasing or decreasing sequence
  for(int i = 1; i < nums.size(); i++)
  {
  if(nums[i] == nums[i - 1])
  continue;//we can ignore duplicates as they can always be omitted
  else if(nums[i] > nums[i - 1])
  {
  if(bigger == 0 || bigger == 2)
  {
  bigger = 1;//1 means we now have an increasing sequence
  solution++;
  }
  }
  else //if(nums[i] < nums[i - 1])
  {
  if(bigger == 0 || bigger == 1)
  {
  bigger = 2;//2 means we now have a decreasing sequence
  solution++;
  }
  }
  }
  }
  return solution;
  }
 };"
494,494,"#include <iostream>
 #include <string>
 using namespace std;
 bool isMatch(const char *s, const char *p) {
  const char *last_s = NULL; 
  const char *last_p = NULL;
  while( *s != '\0' ){
  if (*p=='*'){
  //skip the ""*"", and mark a flag
  p++;
  //edge case
  if (*p=='\0') return true;
  //use last_s and last_p to store where the ""*"" match starts.
  last_s = s;
  last_p = p;
  }else if (*p=='?' || *s == *p){
  s++; p++;
  }else if (last_s != NULL){ // check ""last_s"" to know whether meet ""*"" before
  // if meet ""*"" previously, and the *s != *p
  // reset the p, using '*' to match this situation
  p = last_p;
  s = ++last_s; 
  }else{
  // *p is not wildcard char, 
  // doesn't match *s, 
  // there are no '*' wildcard matched before
  return false;
  }
  }
  //edge case: ""s"" is done, but ""p"" still have chars.
  while (*p == '*') p++;
  return *p == '\0';
 }
 int main(int argc, char** argv)
 {
  const char *s = ""aab"";
  const char *p = ""a*a*b"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  s = ""abbb"";
  p = ""a*b"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  s = ""abb"";
  p = ""a*bb"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  s = ""abddbbb"";
  p = ""a*d*b"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  s = ""abdb"";
  p = ""a**"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  s = ""a"";
  p = ""a**"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  /* thanks @jakwings (GitHub) find this problem */
  s = ""*aa""; // <-- it is not a pattern, it just a string where '*' is not a wildcard
  p = ""*a"";
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  if (argc>2){
  s = argv[1];
  p = argv[2];
  cout << s << "", "" << p << "" : "" << isMatch(s, p) << endl;
  }
  return 0;
 }"
495,495,"#include <iostream>
 #include <vector>
 #include <set>
 using namespace std;
 bool wordBreak(string s, set<string> &dict) {
  //using an array to mark subarray from 0 to i can be broken or not
  vector<bool> v(s.size(),false);
  for(int i=0; i<s.size(); i++){
  //check the substring from 0 to i is int dict or not
  string w = s.substr(0,i+1);
  v[i] = (dict.find(w)!=dict.end());
  //if it is, then use greedy algorithm
  if (v[i]) continue;
  //if it is not, then break it to check
  for(int j=0; j<i; j++){
  //if the substring from 0 to j can be borken, then check the substring from j to i
  if (v[j]==true){
  w = s.substr(j+1, i-j);
  v[i] = (dict.find(w)!=dict.end());
  if (v[i]) break;
  }
  }
  }
  return v.size() ? v[v.size()-1] : false;
 }
 int main()
 {
  string s; 
  set<string> dict;
  s = ""a"";
  dict.insert(""a"");
  cout << wordBreak(s, dict) << endl;
  dict.clear();
  s = ""dogs"";
  string d[]={""dog"",""s"",""gs""};
  dict.insert(d, d+3);
  cout << wordBreak(s, dict) << endl;
  return 0;
 }"
496,496,"#include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 #include <iostream>
 #include <string>
 #include <vector>
 #include <set>
 #include <map>
 using namespace std;
 // ---------------
 // Recursive Way
 // ---------------
 // The recursive method is quite straight forward.
 //
 // 1) if a substring from 0 to i is a word, then take the rest substring to evaluate. 
 // 2) during the recursion, keep tracking the result
 //
 // For example:
 //
 // s = ""catsanddog"",
 // dict = [""cat"", ""cats"", ""and"", ""sand"", ""dog""].
 //
 // 
 // +---> sand / dog ---> dog 
 // | 
 // +-------> cat / sanddog 
 // | 
 // catsanddog 
 // | 
 // +------> cats / anddog 
 // | 
 // +----> and / dog ---> dog 
 // 
 //
 // However, the recursive could produce a lot duplicated calculation, we need use a cache to avoid.
 //
 //To avoid time limit error, need to add cache
 vector<string> wordBreak(string s, set<string> &dict, map<string, vector<string> >& cache) {
  if (cache.find(s)!=cache.end()){
  return cache[s];
  }
  vector<string> result;
  for(int i=0; i<s.size(); i++){
  string w = s.substr(0,i+1);
  if (dict.find(w)!=dict.end()) {
  if (i==s.size()-1){
  result.push_back(w);
  break;
  }
  vector<string> ret = wordBreak(s.substr(i+1, s.size()-i-1), dict, cache);
  for(int j=0; j<ret.size(); j++){
  result.push_back( w + "" "" + ret[j] );
  }
  }
  }
  cache[s] = result;
  return result;
 }
 //Time limit error
 void wordBreak(string s, set<string> &dict, string str, vector<string>& result) {
  string org_str = str;
  for(int i=0; i<s.size(); i++){
  string w = s.substr(0,i+1);
  // if the current substring is a word
  if (dict.find(w)!=dict.end()) {
  str = org_str;
  if (str.size()>0){
  str +="" "";
  }
  str = str + w;
  // foud the solution, add it into the result
  if (i==s.size()-1){
  result.push_back(str);
  return;
  }
  //recursively to solve the rest subarray
  wordBreak(s.substr(i+1, s.size()-i-1), dict, str, result);
  }
  }
 }
 //---------------------
 // Dynamic Programming
 //---------------------
 //
 // Define substring[i, j] is the sub string from i to j.
 //
 // (substring[i,j] == word) : result[i] = substring[i,j] + {result[j]}
 //
 // So, it's better to evaluate it backword. 
 //
 // For example:
 //
 // s = ""catsanddog"",
 // dict = [""cat"", ""cats"", ""and"", ""sand"", ""dog""].
 // 
 // 0 c ""cat"" -- word[0,2] + {result[3]} ==> ""cat sand dog""
 // ""cats"" -- word[0,3] + {result[4]} ==> ""cats and dog"" 
 // 1 a """"
 // 2 t """"
 // 3 s ""sand"" -- word[3,6] + {result[7]} ==> ""sand dog""
 // 4 a ""and"" -- word[4,6] + {result[7]} ==> ""and dog""
 // 5 n """"
 // 6 d """"
 // 7 d ""dog""
 // 8 o """"
 // 9 g """"
 vector<string> wordBreak_dp(string s, set<string> &dict) {
  vector< vector<string> > result(s.size());
  for(int i=s.size()-1; i>=0; i--) {
  vector<string> v;
  result[i] = v;
  for(int j=i+1; j<=s.size(); j++) {
  string word = s.substr(i, j-i);
  if (dict.find(word) != dict.end()){
  if (j==s.size()){
  result[i].push_back(word);
  }else{
  for(int k=0; k<result[j].size(); k++){
  result[i].push_back(word + "" "" + result[j][k]);
  }
  }
  }
  } 
  }
  return result[0];
 }
 vector<string> wordBreak(string s, set<string> &dict) {
  vector<string> result;
  switch (random()%3) 
  {
  case 0: 
  {
  cout << ""---------Recursive Solution--------"" << endl;
  string str;
  wordBreak(s, dict, str, result);
  }
  break;
  case 1:
  {
  cout << ""----Memorized Recursive Solution----"" << endl;
  map<string, vector<string> > cache;
  result = wordBreak(s, dict, cache);
  }
  break;
  case 2:
  cout << ""----Dynamic Programming Solution----"" << endl;
  result = wordBreak_dp(s, dict);
  break;
  }
  return result;
 }
 void printVector(vector<string>& v)
 {
  for(int i=0; i<v.size(); i++){
  cout << v[i] <<endl;
  }
 }
 int main()
 {
  srand(time(NULL));
  string d[]={""cat"", ""cats"", ""and"", ""sand"", ""dog""};
  set<string> dict(d, d+5);
  string s = ""catsanddog"";
  vector<string> v = wordBreak(s, dict);
  printVector(v); 
  string d0[]={""apple"",""app"",""le"",""pie""};
  dict.clear();
  dict.insert(d0, d0+4);
  s = ""applepie"";
  v = wordBreak(s, dict);
  printVector(v); 
  string d1[]={""aaaa"",""aa"",""a""};
  dict.clear();
  dict.insert(d1, d1+3);
  s = ""aaaaaaa"";
  v = wordBreak(s, dict);
  printVector(v); 
  string d5[]={""a"",""aa"",""aaa"",""aaaa"",""aaaaa"",""aaaaaa"",""aaaaaaa"",""aaaaaaaa"",""aaaaaaaaa"",""aaaaaaaaaa""};
  dict.clear();
  dict.insert(d5, d5+10);
  s=""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"";
  v = wordBreak(s, dict);
  printVector(v); 
  return 0;
 }"
497,497,"// --------------------------- 
 // BFS non-recursive method
 // ---------------------------
 //
 // Using BFS instead of DFS is becasue the solution need the shortest transformation path.
 // 
 // So, we can change every char in the word one by one, until find all possible transformation.
 //
 // Keep this iteration, we will find the shorest path.
 //
 // For example:
 // 
 // start = ""hit""
 // end = ""cog""
 // dict = [""hot"",""dot"",""dog"",""lot"",""log"",""dit"",""hig"", ""dig"", ""cog""]
 //
 // +-----+ 
 // +-------------+ hit +--------------+ 
 // | +--+--+ | 
 // | | | 
 // +--v--+ +--v--+ +--v--+
 // | dit | +-----+ hot +---+ | hig |
 // +--+--+ | +-----+ | +--+--+
 // | | | | 
 // | +--v--+ +--v--+ +--v--+
 // +----> dot | | lot | | dig |
 // +--+--+ +--+--+ +--+--+
 // | | | 
 // +--v--+ +--v--+ | 
 // +----> dog | | log | | 
 // | +--+--+ +--+--+ | 
 // | | | | 
 // | | +--v--+ | | 
 // | +--->| cog |<-- + | 
 // | +-----+ | 
 // | | 
 // | | 
 // +----------------------------------+ 
 // 
 // 1) queue <== ""hit""
 // 2) queue <== ""dit"", ""hot"", ""hig""
 // 3) queue <== ""dot"", ""lot"", ""dig""
 // 4) queue <== ""dog"", ""log"" 
 // 
 class Solution {
 public:
  int ladderLength(string start, string end, unordered_set<string> &dict) {
  // Using a map for two purposes: 
  // 1) store the distince so far.
  // 2) remove the duplication 
  map<string, int> dis;
  dis[start] = 1;
  queue<string> q;
  q.push(start);
  while(!q.empty()){
  string word = q.front(); 
  q.pop();
  if (word == end) {
  break;
  }
  for (int i=0; i<word.size(); i++){
  string temp = word;
  for(char c='a'; c<='z'; c++){
  temp[i] = c;
  if (dict.count(temp)>0 && dis.count(temp)==0){
  dis[temp] = dis[word] + 1;
  q.push(temp);
  }
  }
  }
  }
  return (dis.count(end)==0) ? 0 : dis[end];
  }
 };"
498,498,"#include <iostream>
 #include <vector>
 #include <map>
 #include <queue>
 #include <unordered_set>
 using namespace std;
 // Solution
 //
 // 1) Using BSF algorithm build a tree like below
 // 2) Using DSF to parse the tree to the transformation path.
 //
 // For example:
 //
 // start = ""hit""
 // end = ""cog""
 // dict = [""hot"",""dot"",""dog"",""lot"",""log"",""dit"",""hig"", ""dig""]
 //
 // +-----+
 // +-------------+ hit +--------------+
 // | +--+--+ |
 // | | |
 // +--v--+ +--v--+ +--v--+
 // | dit | +-----+ hot +---+ | hig |
 // +--+--+ | +-----+ | +--+--+
 // | | | |
 // | +--v--+ +--v--+ +--v--+
 // +----> dot | | lot | | dig |
 // +--+--+ +--+--+ +--+--+
 // | | |
 // +--v--+ +--v--+ |
 // +----> dog | | log | |
 // | +--+--+ +--+--+ |
 // | | | |
 // | | +--v--+ | |
 // | +--->| cog |<-- + |
 // | +-----+ |
 // | |
 // | |
 // +----------------------------------+
 map< string, unordered_set<string> >& 
 buildTree(string& start, string& end, unordered_set<string> &dict) {
  static map< string, unordered_set<string> > parents;
  parents.clear();
  unordered_set<string> level[3];
  unordered_set<string> *previousLevel = &level[0];
  unordered_set<string> *currentLevel = &level[1];
  unordered_set<string> *newLevel = &level[2];
  unordered_set<string> *p =NULL;
  currentLevel->insert(start);
  bool reachEnd = false;
  while( !reachEnd ) {
  newLevel->clear();
  for(auto it=currentLevel->begin(); it!=currentLevel->end(); it++) { 
  for (int i=0; i<it->size(); i++) {
  string newWord = *it;
  for(char c='a'; c<='z'; c++){
  newWord[i] = c;
  if (newWord == end){
  reachEnd = true;
  parents[*it].insert(end);
  continue;
  }
  if ( dict.count(newWord)==0 || currentLevel->count(newWord)>0 || previousLevel->count(newWord)>0 ) {
  continue;
  }
  newLevel->insert(newWord);
  //parents[newWord].insert(*it);
  parents[*it].insert(newWord);
  }
  }
  } 
  if (newLevel->empty()) break;
  p = previousLevel; 
  previousLevel = currentLevel;
  currentLevel = newLevel;
  newLevel = p;
  }
  if ( !reachEnd ) {
  parents.clear();
  } 
  return parents;
 }
 void generatePath( string start, string end,
  map< string, unordered_set<string> > &parents, 
  vector<string> path,
  vector< vector<string> > &paths) {
  if (parents.find(start) == parents.end()){
  if (start == end){
  paths.push_back(path);
  }
  return;
  }
  for(auto it=parents[start].begin(); it!=parents[start].end(); it++){
  path.push_back(*it);
  generatePath(*it, end, parents, path, paths);
  path.pop_back();
  }
 }
 vector< vector<string> > 
 findLadders(string start, string end, unordered_set<string> &dict) {
  vector< vector<string> > ladders;
  vector<string> ladder;
  ladder.push_back(start);
  if (start == end){
  ladder.push_back(end);
  ladders.push_back(ladder);
  return ladders;
  }
  map< string, unordered_set<string> >& parents = buildTree(start, end, dict);
  if (parents.size()<=0) {
  return ladders;
  }
  generatePath(start, end, parents, ladder, ladders);
  return ladders;
 }
 void printLadders(vector< vector<string> > &ladders){
  int i, j;
  for (i=0; i<ladders.size(); i++){
  for (j=0; j<ladders[i].size()-1; j++){
  cout << ladders[i][j] << "" -> "";
  }
  cout << ladders[i][j] << endl; 
  }
 }
 int main(int argc, char** argv)
 {
  string start = ""hit"";
  string end = ""cog"";
  //unordered_set<string> dict ({""hot"",""dot"",""dog"",""lot"",""log""});
  unordered_set<string> dict ({""bot"",""cig"", ""cog"", ""dit"", ""dut"", ""hot"", ""hit"" ,""dot"",""dog"",""lot"",""log""});
  vector< vector<string> > ladders;
  ladders = findLadders(start, end, dict);
  printLadders(ladders);
  return 0;
 }"
499,499,"class Solution {
 private::
  vector<string> split(string str, char delimiter) {
  vector<string> internal;
  stringstream ss(str); // Turn the string into a stream.
  string tok;
  while(getline(ss, tok, delimiter)) {
  internal.push_back(tok);
  }
  return internal;
  }
 public:
  bool wordPattern(string pattern, string str) {
  unordered_map<char, string> dict_pattern;
  unordered_map<string, char> dict_string;
  int len = pattern.size();
  vector<string> strs = split(str, ' ');
  if (len != strs.size()) return false;
  for(int i=0; i<len; i++) {
  char& ch = pattern[i];
  string& s = strs[i];
  if ( dict_pattern.find(ch) == dict_pattern.end() ) {
  dict_pattern[ch] = s;
  }
  if ( dict_string.find(s) == dict_string.end() ) {
  dict_string[s] = ch;
  }
  if ( dict_pattern[ch] != s || dict_string[s] != ch ) {
  return false;
  }
  }
  return true;
  }
 };"
500,500,"#include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 bool exist(vector<vector<char> > &board, string& word, int idx, int row, int col) {
  if ( row<0 || row>=board.size() ||
  col<0 || col>=board[0].size() ||
  board[row][col] != word[idx]) {
  return false;
  }
  if (idx+1 == word.size()) return true;
  //replace to a special char to avoid duplication.
  board[row][col] = '\0';
  if ( exist(board, word, idx+1, row+1, col ) ||
  exist(board, word, idx+1, row-1, col ) ||
  exist(board, word, idx+1, row, col+1 ) ||
  exist(board, word, idx+1, row, col-1 ) ) {
  return true;
  }
  //restore the char
  board[row][col] = word[idx];
  return false;
 }
 bool exist(vector<vector<char> > &board, string word) {
  if (board.size()<=0 || word.size()<=0) return false;
  int row = board.size();
  int col = board[0].size();
  for(int i=0; i<board.size(); i++) {
  for(int j=0; j<board[i].size(); j++){
  if ( board[i][j]==word[0] ){
  if( exist(board, word, 0, i, j) ){
  return true;
  }
  }
  }
  }
  return false;
 }
 vector< vector<char> > buildBoard(char b[][5], int r, int c) {
  vector< vector<char> > board;
  for (int i=0; i<r; i++){
  vector<char> v(b[i], b[i]+c);
  cout << b[i] << endl;
  board.push_back(v);
  }
  cout << ""----------"" << endl; 
  return board;
 }
 int main(int argc, char** argv)
 {
  string s;
  char b[3][5] ={ ""ABCE"", ""SFCS"", ""ADEE"" };
  vector< vector<char> > board = buildBoard(b, 3, 4);
  s = ""SEE"";
  cout << s << "":"" << exist(board, s) << endl; 
  s = ""ABCCED"";
  cout << s << "":"" << exist(board, s) << endl; 
  s = ""ABCB"";
  cout << s << "":"" << exist(board, s) << endl; 
  if (argc>1){
  s = argv[1];
  cout << s << "":"" << exist(board, s) << endl; 
  }
  cout << endl << ""----------"" << endl; 
  char b1[3][5] ={ ""CAA"", ""AAA"", ""BCD"" };
  board = buildBoard(b1, 3, 3);
  s = ""AAB"";
  cout << s << "":"" << exist(board, s) << endl; 
  cout << endl << ""----------"" << endl; 
  char b2[3][5] ={ ""ABCE"", ""SFES"", ""ADEE"" };
  board = buildBoard(b2, 3, 4);
  s = ""ABCESEEEFS"";
  cout << s << "":"" << exist(board, s) << endl; 
  cout << endl << ""----------"" << endl; 
  char b3[3][5] ={ ""aaaa"", ""aaaa"", ""aaaa"" };
  board = buildBoard(b3, 3, 4);
  s = ""aaaaaaaaaaaaa"";
  cout << s << "":"" << exist(board, s) << endl; 
  return 0;
 }"
501,501,"const int MAX_CHARS = 26;
 class TrieNode {
  public:
  TrieNode(string s):isWord(false), word(s) {
  memset(children, 0, sizeof(children));
  }
  TrieNode* & operator [] (char ch) {
  return children[(ch - 'a') % MAX_CHARS];
  }
  TrieNode* & operator [] (int idx) {
  return children[idx % MAX_CHARS];
  }
  public:
  string word;
  bool isWord;
  private:
  TrieNode* children[MAX_CHARS];
 };
 class TrieTree {
  public:
  TrieTree():root(new TrieNode("""")) { }
  ~TrieTree() { freeTree(root); }
  TrieNode* getRoot() {
  return root;
  }
  void addWord(string& s){
  TrieNode *node = root;
  string t;
  for (int i=0; i<s.size(); i++){
  t += s[i];
  if ( (*node)[s[i]] == NULL ){
  (*node)[s[i]] = new TrieNode(t);
  }
  node = (*node)[s[i]];
  }
  node->isWord = true;
  }
  private:
  void freeTree(TrieNode* node){
  for(int i=0; i<MAX_CHARS; i++){
  if ((*node)[i]!=NULL){
  freeTree((*node)[i]);
  }
  }
  delete node;
  }
  TrieNode *root;
 };
 class Solution {
 public:
  void findWords(vector<vector<char>>& board, TrieNode* root, int row, int col, vector<string>& result){
  if (row < 0 || col < 0 || 
  row >= board.size() || 
  col >= board[row].size() ||
  board[row][col] == '\0' ) {
  return;
  }
  char ch = board[row][col];
  root = (*root)[ch];
  if (root==NULL) return;
  if (root->isWord){
  result.push_back(root->word);
  root->isWord = false;
  }
  board[row][col] = '\0';
  findWords(board, root, row, col - 1, result);
  findWords(board, root, row, col + 1, result);
  findWords(board, root, row + 1, col, result);
  findWords(board, root, row - 1, col, result);
  board[row][col] = ch;
  }
 public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
  TrieTree t;
  for (int i = 0; i<words.size(); i++){
  t.addWord(words[i]);
  }
  vector<string> result;
  for (int i = 0; i<board.size(); i++) {
  for (int j = 0; j < board[i].size(); j++) { 
  findWords(board, t.getRoot(), i, j, result);
  }
  }
  return result; 
  }
 };"
502,502,"#include <iostream>
 #include <vector>
 #include <string>
 using namespace std;
 string convert(string s, int nRows) {
  //The cases no need to do anything
  if (nRows<=1 || nRows>=s.size()) return s;
  vector<string> r(nRows);
  int row = 0;
  int step = 1;
  for(int i=0; i<s.size(); i ++) {
  if (row == nRows-1) step = -1;
  if (row == 0) step = 1;
  //cout << row <<endl;
  r[row] += s[i];
  row += step;
  }
  string result;
  for (int i=0; i<nRows; i++){
  result += r[i];
  }
  return result;
 }
 int main(int argc, char**argv){
  string s;
  int r;
  s = ""PAYPALISHIRING"";
  r = 3;
  cout << s << "" : "" << convert(s, 3) << endl;
 }"